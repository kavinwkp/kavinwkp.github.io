<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树展开为链表</title>
      <link href="2021/11/05/LeetCode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
      <url>2021/11/05/LeetCode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-114-Flatten-Binary-Tree-to-Linked-List"><a href="#LeetCode-114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="LeetCode 114. Flatten Binary Tree to Linked List"></a>LeetCode 114. Flatten Binary Tree to Linked List</h2><p>Given the <code>root</code> of a binary tree, flatten the tree into a <code>&quot;linked list&quot;</code>:</p><p>The “linked list” should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.<br>The “linked list” should be in the same order as a pre-order traversal of the binary tree.</p><p>Example 1:</p><p><img src="/2021/11/05/LeetCode-114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/114-flaten.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [1,2,5,3,4,null,6]Output: [1,null,2,null,3,null,4,null,5,null,6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void flatten(TreeNode* root) &#123;    if (!root) return;    flatten(root-&gt;left);    flatten(root-&gt;right);    if (!root-&gt;left) return;    TreeNode *tmp &#x3D; root-&gt;right;    root-&gt;right &#x3D; root-&gt;left;    root-&gt;left &#x3D; nullptr;    TreeNode *cur &#x3D; root-&gt;right;    while (cur-&gt;right) cur &#x3D; cur-&gt;right;    cur-&gt;right &#x3D; tmp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>13.2-拷贝控制与资源管理</title>
      <link href="2021/11/04/C-Primer-13-2-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
      <url>2021/11/04/C-Primer-13-2-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="13-2-拷贝控制与资源管理"><a href="#13-2-拷贝控制与资源管理" class="headerlink" title="13.2 拷贝控制与资源管理"></a>13.2 拷贝控制与资源管理</h2><h3 id="13-2-1-行为像值的类"><a href="#13-2-1-行为像值的类" class="headerlink" title="13.2.1 行为像值的类"></a>13.2.1 行为像值的类</h3><p>行为像值的类拷贝时要先拷贝源对象的资源，再释放当前对象的资源，再指向新的资源</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Person&#123;private:    string *ptr;    int age;public:    Person(const string &amp;s &#x3D; string()) : ptr(new string(s)), age(0) &#123;&#125;    Person(const Person &amp;p) : ptr(new string(*p.ptr)), age(p.age) &#123;&#125;    Person&amp; operator&#x3D;(const Person&amp; rhs) &#123;        cout &lt;&lt; &quot;copy assignment&quot; &lt;&lt; endl;        auto newptr &#x3D; new string(*rhs.ptr); &#x2F;&#x2F; 拷贝资源        delete ptr;     &#x2F;&#x2F; 释放当前对象的资源        ptr &#x3D; newptr;   &#x2F;&#x2F; 指针指向新的资源        age &#x3D; rhs.age;        return *this;    &#125;    ~Person() &#123; delete ptr; &#125;&#125;;int main(int argc, char const *argv[])&#123;    Person p1(&quot;kavin&quot;);    Person p2;    p2 &#x3D; p1;    return 0;&#125;&#x2F;&#x2F; copy assignment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-2-2-行为像指针的类"><a href="#13-2-2-行为像指针的类" class="headerlink" title="13.2.2 行为像指针的类"></a>13.2.2 行为像指针的类</h3><p>行为像指针的类拷贝时两个对象的指针指向同一块资源，使用计数器统计资源的用户数量，当用户数量为0时释放资源，类似于<code>shared_ptr</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Person&#123;private:    string *ptr;    int age;    size_t *use;public:    Person(const string &amp;s &#x3D; string()) : ptr(new string(s)), age(0), use(new size_t(1)) &#123;&#125;    Person(const Person &amp;p) : ptr(p.ptr), age(p.age), use(p.use) &#123; *use++; &#125;    Person&amp; operator&#x3D;(const Person&amp; rhs) &#123;        ++*rhs.use;     &#x2F;&#x2F; 先递增左侧对象的引用计数        if (--*use &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 再递减右侧对象的引用计数            delete ptr;            delete use;        &#125;        ptr &#x3D; rhs.ptr;        age &#x3D; rhs.age;        use &#x3D; rhs.use;        return *this;    &#125;    ~Person() &#123;        if (--*use &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 引用计数为0就释放资源            delete ptr;            delete use;        &#125;    &#125;    void info() &#123; cout &lt;&lt; *use &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[])&#123;    Person p1(&quot;kavin&quot;);    Person p2;    p2 &#x3D; p1;    p2.info();    return 0;&#125;2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.6-对象移动</title>
      <link href="2021/11/04/C-Primer-13-6-%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8/"/>
      <url>2021/11/04/C-Primer-13-6-%E5%AF%B9%E8%B1%A1%E7%A7%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="13-6-对象移动"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动</h2><p>有时候对象拷贝之后就立即销毁了，如果只是移动而不是拷贝对象会大幅度提升性能，因为移动不用重新分配内存和拷贝数据</p><ul><li>标准库容器、<code>string</code>和<code>shared_ptr</code>类既支持移动也支持拷贝，<code>IO</code>类和<code>unique_ptr</code>类可以移动但不能拷贝</li></ul><h3 id="13-6-1-右值引用"><a href="#13-6-1-右值引用" class="headerlink" title="13.6.1 右值引用"></a>13.6.1 右值引用</h3><p>右值引用只能绑定到一个将要销毁的对象，可以自由地将一个右值引用的资源移动到另一个对象中</p><p>对于常规的左值引用，不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用则相反，但不能直接绑定到一个左值上</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int i &#x3D; 10;int &amp;r1 &#x3D; i;            &#x2F;&#x2F; OK, 左值引用int &amp;&amp;r2 &#x3D; i;           &#x2F;&#x2F; Err, 不能将右值引用绑定到左值int &amp;r3 &#x3D; i * 10;       &#x2F;&#x2F; Err, i*42是一个右值const int &amp;r3 &#x3D; i * 10; &#x2F;&#x2F; OK, 可以将const引用绑定到右值int &amp;&amp;r4 &#x3D; i * 10;      &#x2F;&#x2F; OK, 右值引用cout &lt;&lt; r4 &lt;&lt; endl;     &#x2F;&#x2F; 100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是左值</li><li>返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int&amp; func1(int&amp; num) &#123;    num &#x3D; num * num;    return num;&#125;int func2(int num) &#123;    return num * num;&#125;int main(int argc, char const *argv[]) &#123;    int a &#x3D; 5;    int &amp;ref1 &#x3D; func1(a);   &#x2F;&#x2F; 返回左值    cout &lt;&lt; ref1 &lt;&lt; endl;   &#x2F;&#x2F; 25    int b &#x3D; 4;    int &amp;&amp;ref2 &#x3D; func2(b);  &#x2F;&#x2F; 返回右值    cout &lt;&lt; ref2 &lt;&lt; endl;   &#x2F;&#x2F; 16    const int &amp;ref3 &#x3D; func2(b); &#x2F;&#x2F; const引用可以绑定右值    cout &lt;&lt; ref3 &lt;&lt; endl;       &#x2F;&#x2F; 16    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>右值引用指向将要被销毁的对象，所以，我们可以从绑定到右值引用的对象“窃取”状态</p><p><strong>变量是左值</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int &amp;&amp;r1 &#x3D; 10;int &amp;&amp;r2 &#x3D; r1;  &#x2F;&#x2F; Err, r1是左值，尽管r1是右值引用，但还是一个变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="move函数"><a href="#move函数" class="headerlink" title="move函数"></a>move函数</h4><p>可以显式地将一个左值转换为对应的右值引用类型<br>可以用<code>move</code>函数来获得绑定到左值上的右值引用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int &amp;&amp;r1 &#x3D; 10;int &amp;&amp;r2 &#x3D; std::move(r1);   &#x2F;&#x2F; OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>调用<code>move</code>之后，除了对<code>r1</code>赋值或销毁外，不能再使用它</p><h3 id="13-6-2-移动构造函数和移动赋值运算符"><a href="#13-6-2-移动构造函数和移动赋值运算符" class="headerlink" title="13.6.2 移动构造函数和移动赋值运算符"></a>13.6.2 移动构造函数和移动赋值运算符</h3><h4 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><p>移动构造函数的参数是右值引用，新对象接管源对象的资源之后，把源对象的指针置空，使其成为可析构的状态</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Person&#123;private:    string *ptr;    int age;public:    Person(const string &amp;s &#x3D; string()) : ptr(new string(s)), age(0) &#123;&#125;    Person(const Person &amp;p) : ptr(new string(*p.ptr)), age(p.age) &#123;&#125;    Person &amp;operator&#x3D;(const Person &amp;rhs) &#123;        cout &lt;&lt; &quot;copy assignment&quot; &lt;&lt; endl;        auto newptr &#x3D; new string(*rhs.ptr);        delete ptr;   &#x2F;&#x2F; 释放当前对象的资源        ptr &#x3D; newptr; &#x2F;&#x2F; 指针指向新的资源        age &#x3D; rhs.age;        return *this;    &#125;    Person(Person &amp;&amp;p) noexcept &#x2F;&#x2F; 移动操作不应抛出异常        : ptr(p.ptr), age(p.age) &#123;        cout &lt;&lt; &quot;move constructor&quot; &lt;&lt; endl;        p.ptr &#x3D; nullptr; &#x2F;&#x2F; 源对象的指针置空    &#125;    ~Person() &#123;        delete ptr;    &#125;&#125;;int main(int argc, char const *argv[]) &#123;    Person p1;    Person p2 &#x3D; std::move(p1);    return 0;&#125;move constructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h4><p>先释放自身的资源，接管源对象的资源，再把源对象的指针置空</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Person &#123;private:    string *ptr;    int age;public:    Person&amp; operator&#x3D;(Person &amp;&amp;rhs) noexcept &#123;        cout &lt;&lt; &quot;move copy assignment&quot; &lt;&lt; endl;        if (this !&#x3D; &amp;rhs) &#123;            delete ptr;            ptr &#x3D; rhs.ptr;            age &#x3D; rhs.age;            rhs.ptr &#x3D; nullptr;        &#125;        return *this;    &#125;&#125;;Person func(Person&amp; p) &#123;    &#x2F;&#x2F; 函数返回右值    return p;&#125;int main(int argc, char const *argv[]) &#123;    Person p1, p2;    p2 &#x3D; func(p1);    return 0;&#125;move copy assignment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>62-不同路径</title>
      <link href="2021/11/04/LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/"/>
      <url>2021/11/04/LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-62-Unique-Paths"><a href="#LeetCode-62-Unique-Paths" class="headerlink" title="LeetCode 62. Unique Paths"></a>LeetCode 62. Unique Paths</h2><p>A robot is located at the top-left corner of a <code>m x n</code> grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>How many possible unique paths are there?</p><p>Example 1:</p><p><img src="/2021/11/04/LeetCode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/62.png" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: m &#x3D; 3, n &#x3D; 7Output: 28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="method-动态规划"><a href="#method-动态规划" class="headerlink" title="method: 动态规划"></a>method: 动态规划</h3><p>当前位置只能从左边或上边过来</p><p>注意初始化：第一行和第一列都是1</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int uniquePaths(int m, int n) &#123;    vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1));    for (int i &#x3D; 1; i &lt; m; i++) &#123;        for (int j &#x3D; 1; j &lt; n; j++) &#123;            dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1];        &#125;    &#125;    return dp[m - 1][n - 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>因为只跟上一行有关，所以只需要两行就可以了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int uniquePaths(int m, int n) &#123;    vector&lt;int&gt; pre(n, 1), cur(n, 1);    for (int i &#x3D; 1; i &lt; m; i++) &#123;        for (int j &#x3D; 1; j &lt; n; j++) &#123;            cur[j] &#x3D; cur[j - 1] + pre[j];        &#125;        swap(cur, pre);    &#125;    return pre[n - 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="再改进"><a href="#再改进" class="headerlink" title="再改进"></a>再改进</h3><p>只需要一行就够了，在下一次<code>i</code>循环<code>cur</code>就变成<code>pre</code>了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int uniquePaths(int m, int n) &#123;    vector&lt;int&gt; dp(n, 1);    for (int i &#x3D; 1; i &lt; m; i++) &#123;        for (int j &#x3D; 1; j &lt; n; j++) &#123;            dp[j] +&#x3D; dp[j - 1];        &#125;    &#125;    return dp[n - 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>70-爬楼梯</title>
      <link href="2021/11/04/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>2021/11/04/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-70-Climbing-Stairs"><a href="#LeetCode-70-Climbing-Stairs" class="headerlink" title="LeetCode 70. Climbing Stairs"></a>LeetCode 70. Climbing Stairs</h2><p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p><p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: n &#x3D; 2Output: 2Explanation: There are two ways to climb to the top.1. 1 step + 1 step2. 2 steps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>当前阶可以从<code>i-1</code>阶跳一格过来，也可以从<code>i-2</code>阶跳两格过来</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int climbStairs(int n) &#123;    if (n &#x3D;&#x3D; 1) return 1;    vector&lt;int&gt; dp(n);    dp[0] &#x3D; 1;    dp[1] &#x3D; 2;    for (int i &#x3D; 2; i &lt; dp.size(); i++) &#123;        dp[i] &#x3D; dp[i - 1] + dp[i - 2];    &#125;    return dp[n - 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>138-复制带随机指针的链表</title>
      <link href="2021/11/02/LeetCode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
      <url>2021/11/02/LeetCode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-138-Copy-List-with-Random-Pointer"><a href="#LeetCode-138-Copy-List-with-Random-Pointer" class="headerlink" title="LeetCode 138. Copy List with Random Pointer"></a>LeetCode 138. Copy List with Random Pointer</h2><p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or null.</p><p>Construct a <strong>deep copy</strong> of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list.</strong></p><p>Return <em>the head of the copied linked list.</em></p><p>The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p><p><code>val</code>: an integer representing <code>Node.val</code><br><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</p><p>Your code will <strong>only</strong> be given the head of the original linked list.</p><p>Example 1:</p><p><img src="/2021/11/02/LeetCode-138-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/138_1.png" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h3 id="method-哈希表"><a href="#method-哈希表" class="headerlink" title="method: 哈希表"></a>method: 哈希表</h3><p>第一次遍历只生成节点，用哈希表记录原节点和新节点的对应关系</p><p>然后就可以用<code>hash[cur-&gt;next]</code>获取原节点的next在新节点中的位置，以及用<code>hash[cur]-&gt;next</code>对当前的新节点的指针赋值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Node* copyRandomList(Node* head) &#123;    if (!head) return head;    unordered_map&lt;Node*, Node*&gt; hash;    Node *cur &#x3D; head;    while (cur) &#123;   &#x2F;&#x2F; 第一次遍历只生成节点        Node *tmp &#x3D; new Node(cur-&gt;val);        hash[cur] &#x3D; tmp;        cur &#x3D; cur-&gt;next;    &#125;    cur &#x3D; head;    while (cur) &#123;   &#x2F;&#x2F; 第二次遍历对指针赋值        if (cur-&gt;next) &#123;            hash[cur]-&gt;next &#x3D; hash[cur-&gt;next];        &#125;        if (cur-&gt;random) &#123;            hash[cur]-&gt;random &#x3D; hash[cur-&gt;random];        &#125;        cur &#x3D; cur-&gt;next;    &#125;    return hash[head];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>116-填充右侧指针</title>
      <link href="2021/11/02/LeetCode-116-%E5%A1%AB%E5%85%85%E5%8F%B3%E4%BE%A7%E6%8C%87%E9%92%88/"/>
      <url>2021/11/02/LeetCode-116-%E5%A1%AB%E5%85%85%E5%8F%B3%E4%BE%A7%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#LeetCode-116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="LeetCode 116. Populating Next Right Pointers in Each Node"></a>LeetCode 116. Populating Next Right Pointers in Each Node</h2><p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct Node &#123;  int val;  Node *left;  Node *right;  Node *next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Populate each next pointer to point to its next right node.</strong> If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p><p>Example 1:</p><p><img src="/2021/11/02/LeetCode-116-%E5%A1%AB%E5%85%85%E5%8F%B3%E4%BE%A7%E6%8C%87%E9%92%88/116_sample.png" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [1,2,3,4,5,6,7]Output: [1,#,2,3,#,4,5,6,7,#]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with <code>&#39;#&#39;</code> signifying the end of each level.</p><h3 id="method-层序遍历"><a href="#method-层序遍历" class="headerlink" title="method: 层序遍历"></a>method: 层序遍历</h3><p>当前节点弹出后，队列里的头结点就是同一层的下一个节点<br>每一层的最后一个节点不需要处理<code>next</code>指针</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Node* connect(Node* root) &#123;    if (!root) return root;    queue&lt;Node*&gt; q;    q.push(root);    while (!q.empty()) &#123;        int size &#x3D; q.size();        for (int i &#x3D; 0; i &lt; size; i++) &#123;            Node *cur &#x3D; q.front();            q.pop();            if (i &lt; size - 1) cur-&gt;next &#x3D; q.front();    &#x2F;&#x2F; 非最后一个节点            if (cur-&gt;left) q.push(cur-&gt;left);            if (cur-&gt;right) q.push(cur-&gt;right);        &#125;    &#125;    return root;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.1-拷贝、赋值与销毁</title>
      <link href="2021/10/26/C-Primer-13-1-%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%94%80%E6%AF%81/"/>
      <url>2021/10/26/C-Primer-13-1-%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%94%80%E6%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="13-1-拷贝、赋值与销毁"><a href="#13-1-拷贝、赋值与销毁" class="headerlink" title="13.1 拷贝、赋值与销毁"></a>13.1 拷贝、赋值与销毁</h2><h3 id="13-1-1-copy-constructor"><a href="#13-1-1-copy-constructor" class="headerlink" title="13.1.1 copy constructor"></a>13.1.1 copy constructor</h3><p>拷贝构造函数</p><p>第一个参数是引用类型<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Foo(const Foo&amp;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>代码示例</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Person&#123;private:    string name;    int age;public:    Person(string name, int age) : name(name), age(age) &#123;&#125;    Person(const Person&amp; rhs) &#123;        name &#x3D; rhs.name;        age &#x3D; rhs.age;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    Person p1(&quot;kavin&quot;, 23); &#x2F;&#x2F; 调用自定义构造函数    Person p2(p1);  &#x2F;&#x2F; 调用拷贝构造函数    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-1-2-copy-assignment-operator"><a href="#13-1-2-copy-assignment-operator" class="headerlink" title="13.1.2 copy-assignment operator"></a>13.1.2 copy-assignment operator</h3><p>拷贝赋值运算符</p><p>参数是类类型的<code>const</code>引用<br>返回值是指向其左侧运算对象的引用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Foo&amp; operator&#x3D;(const foo&amp;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代码示例</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Person &#123;private:    string name;    int age;public:    Person() &#123;&#125;    Person(string name, int age) : name(name), age(age) &#123;&#125;    Person&amp; operator&#x3D;(const Person&amp; rhs) &#123;        name &#x3D; rhs.name;        age &#x3D; rhs.age;        return *this;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    Person p1(&quot;kavin&quot;, 23); &#x2F;&#x2F; 调用自定义构造函数    Person p2;  &#x2F;&#x2F; 调用默认构造函数    p2 &#x3D; p1;    &#x2F;&#x2F; 调用拷贝赋值运算符    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-3-3-destructor"><a href="#13-3-3-destructor" class="headerlink" title="13.3.3 destructor"></a>13.3.3 destructor</h3><p>析构函数</p><p>不接受参数，也没有返回值<br>不能被重载<br>对一个给定类，只会有唯一一个析构函数<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">~Foo();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>在一个析构函数中，首先执行<strong>函数体</strong>，然后<strong>销毁成员</strong>，成员按初始化顺序的逆序销毁</p><p>如果一个类需要析构函数，那肯定也需要拷贝构造函数和拷贝赋值运算符，尤其是含有动态分配内存的类，因为合成析构函数不会delete一个指针数据成员</p><h2 id="13-2-拷贝控制与资源管理"><a href="#13-2-拷贝控制与资源管理" class="headerlink" title="13.2 拷贝控制与资源管理"></a>13.2 拷贝控制与资源管理</h2><h3 id="13-2-1-行为像值的类"><a href="#13-2-1-行为像值的类" class="headerlink" title="13.2.1 行为像值的类"></a>13.2.1 行为像值的类</h3><p>拷贝的时候需要拷贝资源</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Person &#123;private:    string *ptr;    int age;public:    Person(const string &amp;s &#x3D; string()) : ptr(new string(s)), age(0) &#123;&#125;    Person(const Person &amp;p) : ptr(new string(*p.ptr)), age(p.age) &#123;&#125;    Person&amp; operator&#x3D;(const Person&amp; rhs) &#123;        cout &lt;&lt; &quot;copy assignment&quot; &lt;&lt; endl;        auto newptr &#x3D; new string(*rhs.ptr);        delete ptr;     &#x2F;&#x2F; 释放当前对象的资源        ptr &#x3D; newptr;   &#x2F;&#x2F; 指针指向新的资源        age &#x3D; rhs.age;        return *this;    &#125;    ~Person() &#123; delete ptr; &#125;&#125;;int main(int argc, char const *argv[]) &#123;    Person p1(&quot;kavin&quot;);    Person p2;    p2 &#x3D; p1;    return 0;&#125;&#x2F;&#x2F; copy assignment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-2-2-行为像指针的类"><a href="#13-2-2-行为像指针的类" class="headerlink" title="13.2.2 行为像指针的类"></a>13.2.2 行为像指针的类</h3><p>只需要拷贝指针，赋值运算后的对象指向同一个内存区域<br>需要用一个引用计数变量记录资源被多少对象所拥有，当计数为0时要释放资源</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Person &#123;private:    string *ptr;    int age;    size_t *use;public:    Person(const string &amp;s &#x3D; string()) : ptr(new string(s)), age(0), use(new size_t(1)) &#123;&#125;    Person(const Person &amp;p) : ptr(p.ptr), age(p.age), use(p.use) &#123; *use++; &#125;    Person&amp; operator&#x3D;(const Person&amp; rhs) &#123;        ++*rhs.use;         &#x2F;&#x2F; 先递增左侧对象的引用计数        if (--*use &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 再递减右侧对象的引用计数            delete ptr;            delete use;        &#125;        ptr &#x3D; rhs.ptr;        age &#x3D; rhs.age;        use &#x3D; rhs.use;        return *this;    &#125;    ~Person() &#123;        if (--*use &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F; 引用计数为0就释放资源            delete ptr;            delete use;        &#125;    &#125;    void info();&#125;;void Person::info() &#123;    cout &lt;&lt; *ptr &lt;&lt; endl;    cout &lt;&lt; *use &lt;&lt; endl;&#125;int main(int argc, char const *argv[]) &#123;    Person p1(&quot;kavin&quot;);    Person p2;    p2 &#x3D; p1;    p2.info();    return 0;&#125;&#x2F;&#x2F; kavin&#x2F;&#x2F; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>75-颜色分类</title>
      <link href="2021/10/26/LeetCode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/"/>
      <url>2021/10/26/LeetCode-75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-75-Sort-Colors"><a href="#LeetCode-75-Sort-Colors" class="headerlink" title="LeetCode 75. Sort Colors"></a>LeetCode 75. Sort Colors</h2><p>Given an array nums with <code>n</code> objects colored <code>red, white, or blue</code>, sort them <strong>in-place</strong> so that objects of the same color are adjacent, with the colors in the order <code>red, white, and blue</code>.</p><p>We will use the integers <code>0, 1, and 2</code> to represent the color red, white, and blue, respectively.</p><p>You must solve this problem without using the library’s sort function.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [2,0,2,1,1,0]Output: [0,0,1,1,2,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>让<code>zero, one, two</code>分别为<code>0,1,2</code>的末尾指针，遍历数组</p><ul><li>如果是0，则<code>zero++, one++, two++</code></li><li>如果是1，则<code>one++, two++</code></li><li>如果是2，则<code>two++</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void sortColors(vector&lt;int&gt;&amp; nums) &#123;    int zero &#x3D; -1;    int one &#x3D; -1;    int two &#x3D; -1;    for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;        if (nums[i] &#x3D;&#x3D; 0) &#123;            nums[++two] &#x3D; 2;            nums[++one] &#x3D; 1;            nums[++zero] &#x3D; 0;        &#125;        else if (nums[i] &#x3D;&#x3D; 1) &#123;            nums[++two] &#x3D; 2;            nums[++one] &#x3D; 1;        &#125;        else &#123;            nums[++two] &#x3D; 2;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顺序不能修改，因为初始化的时候，必须最后一个赋值，以覆盖前面的值</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>115-最小栈</title>
      <link href="2021/10/25/LeetCode-115-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
      <url>2021/10/25/LeetCode-115-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-115-Min-Stack"><a href="#LeetCode-115-Min-Stack" class="headerlink" title="LeetCode 115. Min Stack"></a>LeetCode 115. Min Stack</h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><p>Implement the MinStack class:</p><ul><li><code>MinStack()</code> initializes the stack object.</li><li><code>void push(int val)</code> pushes the element val onto the stack.</li><li><code>void pop()</code> removes the element on the top of the stack.</li><li><code>int top()</code>gets the top element of the stack.</li><li><code>int getMin()</code> retrieves the minimum element in the stack.</li></ul><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 <code>min</code> 函数在该栈中，调用 <code>min</code>、<code>push</code> 及 <code>pop</code> 的时间复杂度都是 <code>O(1)</code>。</p><p>示例:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">MinStack minStack &#x3D; new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min();   --&gt; 返回 -3.minStack.pop();minStack.top();   --&gt; 返回 0.minStack.min();   --&gt; 返回 -2.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-栈"><a href="#method-栈" class="headerlink" title="method: 栈"></a>method: 栈</h2><p>如果后面的数比当前的最小值大，那么他一定会先弹出，所以没必要入栈<br>比如，<code>1 2 3</code>分别入栈<code>stackValue</code><br><code>1</code>入栈<code>stackMin</code>，<code>2</code>和<code>3</code>不用，因为<code>2</code>和<code>3</code>肯定会在<code>1</code>之前出栈<code>stackValue</code>，在此期间最小值一直是<code>1</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class MinStack &#123;public:    stack&lt;int&gt; stackValue;    stack&lt;int&gt; stackMin;    MinStack() &#123;&#125;        void push(int x) &#123;        stackValue.push(x);        if (stackMin.empty() || x &lt;&#x3D; stackMin.top())            stackMin.push(x);    &#125;        void pop() &#123;        int x &#x3D; stackValue.top();        stackValue.pop();        if (x &#x3D;&#x3D; stackMin.top()) stackMin.pop();    &#125;        int top() &#123;        return stackValue.top();    &#125;        int min() &#123;        return stackMin.top();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python常用方法</title>
      <link href="2021/10/24/Python-Python%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>2021/10/24/Python-Python%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>enumerate</li></ul><p>同时遍历下标和元素</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">a &#x3D; [1, 2, 3, 4]for i, num in enumerate(a):    print(i, num)0 11 22 33 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda环境</title>
      <link href="2021/10/23/Python-PyTorch-conda%E7%8E%AF%E5%A2%83/"/>
      <url>2021/10/23/Python-PyTorch-conda%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="新建环境"><a href="#新建环境" class="headerlink" title="新建环境"></a>新建环境</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda create -n name python&#x3D;版本<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查看环境"><a href="#查看环境" class="headerlink" title="查看环境"></a>查看环境</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda info -e# conda environments:#base                  *  D:\software\anaconda3pytorch                  D:\software\anaconda3\envs\pytorch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda activate name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda remove -n name --all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch教程-2</title>
      <link href="2021/10/23/Python-PyTorch-PyTorch%E6%95%99%E7%A8%8B-2/"/>
      <url>2021/10/23/Python-PyTorch-PyTorch%E6%95%99%E7%A8%8B-2/</url>
      
        <content type="html"><![CDATA[<ul><li>reshape</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">input &#x3D; torch.arange(12)# tensor([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])input &#x3D; torch.reshape(input, (3, 4))# tensor([[ 0,  1,  2,  3],#         [ 4,  5,  6,  7],#         [ 8,  9, 10, 11]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>view</li></ul><p>返回一个张量，数据与输入张量相同，大小不同</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">x &#x3D; torch.randn(2, 2)# tensor([[ 1.5941, -0.1812],#         [ 0.5612,  1.5465]])print(x.size())# torch.Size([2, 2])y &#x3D; x.view(4)   # 数据是一样的# tensor([ 1.5941, -0.1812,  0.5612,  1.5465])print(y.size()) # 大小可以改变# torch.Size([4])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>flatness</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">input &#x3D; torch.reshape(torch.arange(6), (2, 3))# tensor([[0, 1, 2],#         [3, 4, 5]])output &#x3D; torch.flatten(input)# tensor([0, 1, 2, 3, 4, 5])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>argmax</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">input &#x3D; torch.tensor([[1, 3, 5],                      [4, 8, 0]])print(input.argmax(1))  # 每行最大值下标tensor([2, 1])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>manual_seed</li></ul><p>随机数种子，每次运行的结果都是一样的</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">seed &#x3D; 111torch.manual_seed(seed)# tensor([[0.7156, 0.9140]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>Sequential</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">class CNN(nn.Module):    def __init__(self):        super(CNN, self).__init__()        self.model1 &#x3D; Sequential(            Conv2d(3, 32, kernel_size&#x3D;(5, 5), padding&#x3D;2),            MaxPool2d(2),            Conv2d(32, 32, kernel_size&#x3D;(5, 5), padding&#x3D;2),            MaxPool2d(2),            Conv2d(32, 64, kernel_size&#x3D;(5, 5), padding&#x3D;2),            MaxPool2d(2),            Flatten(),            Linear(1024, 64),            Linear(64, 10)        )    def forward(self, x):        x &#x3D; self.model1(x)        return xmodel &#x3D; CNN()input &#x3D; torch.ones((64, 3, 32, 32))output &#x3D; model(input)print(output.shape)# torch.Size([64, 10])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协方差</title>
      <link href="2021/10/21/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%8D%8F%E6%96%B9%E5%B7%AE/"/>
      <url>2021/10/21/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%8D%8F%E6%96%B9%E5%B7%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="协方差定义"><a href="#协方差定义" class="headerlink" title="协方差定义"></a>协方差定义</h2><p>$X,Y$是两个随机变量，$X,Y$的协方差<code>covarianxe</code>定义为</p><script type="math/tex; mode=display">cov(X,Y) = \mathbb{E}[(X-\mu_x)(Y-\mu_y)]</script><p>其中，$\mathbb{E}[X]=\mu_x$</p><h2 id="协方差矩阵定义"><a href="#协方差矩阵定义" class="headerlink" title="协方差矩阵定义"></a>协方差矩阵定义</h2><p>这里默认每一行是一个观测值，每一列是一个随机变量</p><script type="math/tex; mode=display">\mathbf{X} = \begin{bmatrix}    a_{11} & a_{12} & \dots & a_{1n} \\    a_{21} & a_{22} & \dots & a_{2n} \\    \vdots & \vdots & \ddots & \vdots \\    a_{m1} & a_{m2} & \dots & a_{mn} \\\end{bmatrix}_{m \times n} = \begin{bmatrix}    \mathbf{x_{1}} & \mathbf{x_{2}} & \dots & \mathbf{x_{n}} \\\end{bmatrix}</script><p>协方差矩阵为</p><script type="math/tex; mode=display">cov = \frac{1}{m-1}\begin{bmatrix}    cov(x_1,x_1) & cov(x_1,x_2) & \dots & cov(x_1,x_n) \\    cov(x_2,x_1) & cov(x_2,x_2) & \dots & cov(x_2,x_n) \\    \vdots & \vdots & \ddots & \vdots \\    cov(x_m,x_1) & cov(x_m,x_2) & \dots & cov(x_m,x_n) \\\end{bmatrix}</script><p>从这里也可以看出</p><ul><li>协方差矩阵是对称矩阵</li><li>对角元素就是随机变量的方差<code>variance</code><script type="math/tex; mode=display">cov(x_i, x_i) = var(x_i) = \mathbb{E}[(x_i-\mathbb{E}[x_i])(x_i-\mathbb{E}[x_i])]</script></li></ul><p><strong>例子</strong>：</p><script type="math/tex; mode=display">\mathbf{X} = \begin{bmatrix}    1 & 2 & 3 \\    3 & 1 & 1 \\\end{bmatrix} = \begin{bmatrix}    \mathbf{x_{1}} & \mathbf{x_{2}} & \mathbf{x_{3}} \\\end{bmatrix}</script><ul><li>求每个随机变量的均值</li></ul><script type="math/tex; mode=display">\mathbf{\bar{x}} = \begin{bmatrix}    \bar{x}_{1} & \bar{x}_{2} & \bar{x}_{3} \\\end{bmatrix} = \begin{bmatrix}    2 & 1.5 & 2 \\\end{bmatrix}</script><ul><li>$\mathbf{X}$的每一列减去均值</li></ul><script type="math/tex; mode=display">\mathbf{X} = \begin{bmatrix}    -1 & 0.5 & 1 \\    1 & -0.5 & -1 \\\end{bmatrix}</script><ul><li>计算协方差矩阵</li></ul><script type="math/tex; mode=display">cov = \frac{1}{m-1}\mathbf{X}^T \mathbf{X} = \frac{1}{2}\begin{bmatrix}    2 & -1 & -2 \\    -1 & 0.5 & 1 \\    -2 & 1 & 2 \\\end{bmatrix}</script><h2 id="协方差的意义"><a href="#协方差的意义" class="headerlink" title="协方差的意义"></a>协方差的意义</h2><center><img src="/2021/10/21/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%8D%8F%E6%96%B9%E5%B7%AE/111.png#pix_center" width="80%" height="80%" alt="正相关"></center><center><img src="/2021/10/21/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%8D%8F%E6%96%B9%E5%B7%AE/222.png#pix_center" width="80%" height="80%" alt="负相关"></center><center><img src="/2021/10/21/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%8D%8F%E6%96%B9%E5%B7%AE/233.png#pix_center" width="80%" height="80%" alt="不相关"></center><p>在图中的区域（1）中，有$X &gt; \mathbb{E}[X], Y &gt; \mathbb{E}[Y]$，所以$(X - \mathbb{E}[X])(Y - \mathbb{E}[Y]) &gt; 0$<br>在图中的区域（2）中，有$X &lt; \mathbb{E}[X], Y &gt; \mathbb{E}[Y]$，所以$(X - \mathbb{E}[X])(Y-\mathbb{E}[Y]) &lt; 0$<br>在图中的区域（3）中，有$X &gt; \mathbb{E}[X], Y&gt;\mathbb{E}[Y]$，所以$(X - \mathbb{E}[X])(Y - \mathbb{E}[Y]) &gt; 0$<br>在图中的区域（4）中，有$X &gt; \mathbb{E}[X], Y &gt; \mathbb{E}[Y]$，所以$(X - \mathbb{E}[X])(Y - \mathbb{E}[Y]) &gt; 0$</p><ul><li><p>当$X$与$Y$正相关时，它们的分布大部分在区域（1）和（3）中，小部分在区域（2）和（4）中，所以平均来说，有$\mathbb{E}[(X-\mathbb{E}[X])(Y-\mathbb{E}[Y])] &gt; 0$</p></li><li><p>当$X$与$Y$负相关时，它们的分布大部分在区域（2）和（4）中，小部分在区域（1）和（3）中，所以平均来说，有$\mathbb{E}[(X-\mathbb{E}[X])(Y-\mathbb{E}[Y])]&lt;  0$</p></li><li><p>当$X$与$Y$不相关时，它们在区域（1）和（3）中的分布，与在区域（2）和（4）中的分布几乎一样多，所以平均来说，有$\mathbb{E}[(X-\mathbb{E}[X])(Y-\mathbb{E}[Y])] = 0$</p></li></ul><p>所以，我们可以定义一个表示$X, Y$相互关系的数字特征，也就是<strong>协方差</strong></p><script type="math/tex; mode=display">cov(X,Y) = \mathbb{E}[(X-\mathbb{E}[X])(Y-\mathbb{E}[Y])]</script><ul><li>$cov(X, Y) &gt; 0$时，表明$X$与$Y$正相关</li><li>$cov(X, Y) &lt; 0$时，表明$X$与$Y$负相关</li><li>$cov(X, Y) = 0$时，表明$X$与$Y$不相关</li></ul><p>这就是协方差的意义</p>]]></content>
      
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch教程-1</title>
      <link href="2021/10/20/Python-PyTorch-PyTorch%E6%95%99%E7%A8%8B-1/"/>
      <url>2021/10/20/Python-PyTorch-PyTorch%E6%95%99%E7%A8%8B-1/</url>
      
        <content type="html"><![CDATA[<p>查看<code>torch</code>版本号</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">print(torch.__version__)# 1.9.1+cu111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="张量初始化"><a href="#张量初始化" class="headerlink" title="张量初始化"></a>张量初始化</h2><p>(1) 直接从数据初始化</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">data &#x3D; [[1, 2], [3, 4]]x_data &#x3D; torch.tensor(data)print(x_data)# tensor([[1, 2],#         [3, 4]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2) 从<code>numpy</code>初始化</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">np_array &#x3D; np.array(data)print(np_array)# [[1 2]#  [3 4]]x_np &#x3D; torch.from_numpy(np_array)print(x_np)# tensor([[1, 2],#         [3, 4]], dtype&#x3D;torch.int32)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(3) 从另一个张量初始化</p><p><code>ones_like</code>会保持和原始数据同样的大小，数值替换为1<br>指定<code>dtype</code>可以修改数据类型</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">x_ones &#x3D; torch.ones_like(x_data) # 返回的tensor默认具有相同的torch.dtype和torch.deviceprint(f&quot;Ones Tensor: \n &#123;x_ones&#125; \n&quot;)# Ones Tensor: #  tensor([[1, 1],#         [1, 1]]) x_rand &#x3D; torch.rand_like(x_data, dtype&#x3D;torch.float) # 指定新的数据类型print(f&quot;Random Tensor: \n &#123;x_rand&#125; \n&quot;)# Random Tensor: #  tensor([[0.5542, 0.4023],#         [0.5633, 0.9819]]) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(4) 指定大小创建</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">shape &#x3D; (2, 3,)rand_tensor &#x3D; torch.rand(shape)ones_tensor &#x3D; torch.ones(shape)zeros_tensor &#x3D; torch.zeros(shape)print(f&quot;Random Tensor: \n &#123;rand_tensor&#125; \n&quot;)# Random Tensor: #  tensor([[0.5704, 0.2910, 0.4899],#         [0.9169, 0.8592, 0.7099]]) print(f&quot;Ones Tensor: \n &#123;ones_tensor&#125; \n&quot;)# Ones Tensor: #  tensor([[1., 1., 1.],#         [1., 1., 1.]]) print(f&quot;Zeros Tensor: \n &#123;zeros_tensor&#125;&quot;)# Zeros Tensor: #  tensor([[0., 0., 0.],#         [0., 0., 0.]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="张量属性"><a href="#张量属性" class="headerlink" title="张量属性"></a>张量属性</h2><ul><li><code>shape</code>：张量大小</li><li><code>dtype</code>：张量数据类型</li><li><code>device</code>：存储在什么设备上</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">tensor &#x3D; torch.rand(3, 4)print(f&quot;Shape of tensor: &#123;tensor.shape&#125;&quot;)print(f&quot;Datatype of tensor: &#123;tensor.dtype&#125;&quot;)print(f&quot;Device tensor is stored on: &#123;tensor.device&#125;&quot;)# Shape of tensor: torch.Size([3, 4])# Datatype of tensor: torch.float32# Device tensor is stored on: cpu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="张量操作"><a href="#张量操作" class="headerlink" title="张量操作"></a>张量操作</h2><p>(1) 移动到<code>GPU</code></p><pre class="line-numbers language-py" data-language="py"><code class="language-py">if torch.cuda.is_available():  tensor &#x3D; tensor.to(&#39;cuda&#39;)  print(f&quot;Device tensor is stored on: &#123;tensor.device&#125;&quot;)# Device tensor is stored on: cuda:0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>(2) 和<code>numpy</code>类似的索引</p><p>第1列赋值为0<br><pre class="line-numbers language-py" data-language="py"><code class="language-py">tensor &#x3D; torch.ones(4, 4)tensor[:,1] &#x3D; 0print(tensor)# tensor([[1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>(3) 连接多个张量</p><p>按列连接<br><pre class="line-numbers language-py" data-language="py"><code class="language-py">t1 &#x3D; torch.cat([tensor, tensor, tensor], dim&#x3D;0)print(t1)# tensor([[1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>按行连接<br><pre class="line-numbers language-py" data-language="py"><code class="language-py">t1 &#x3D; torch.cat([tensor, tensor, tensor], dim&#x3D;1)print(t1)# tensor([[1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],#         [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],#         [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.],#         [1., 0., 1., 1., 1., 0., 1., 1., 1., 0., 1., 1.]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>(4) 张量相乘</p><p>对应元素相乘<br><pre class="line-numbers language-py" data-language="py"><code class="language-py">print(f&quot;tensor.mul(tensor) \n &#123;tensor.mul(tensor)&#125; \n&quot;)# tensor.mul(tensor) #  tensor([[1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.]]) print(f&quot;tensor * tensor \n &#123;tensor * tensor&#125;&quot;)# tensor * tensor #  tensor([[1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>矩阵乘法</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">print(f&quot;tensor.matmul(tensor.T) \n &#123;tensor.matmul(tensor.T)&#125; \n&quot;)# tensor.matmul(tensor.T) #  tensor([[3., 3., 3., 3.],#         [3., 3., 3., 3.],#         [3., 3., 3., 3.],#         [3., 3., 3., 3.]]) print(f&quot;tensor @ tensor.T \n &#123;tensor @ tensor.T&#125;&quot;)# tensor @ tensor.T #  tensor([[3., 3., 3., 3.],#         [3., 3., 3., 3.],#         [3., 3., 3., 3.],#         [3., 3., 3., 3.]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(5) 直接更改元素</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">print(tensor, &quot;\n&quot;)# tensor([[1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.],#         [1., 0., 1., 1.]]) tensor.add_(5)print(tensor)# tensor([[6., 5., 6., 6.],#         [6., 5., 6., 6.],#         [6., 5., 6., 6.],#         [6., 5., 6., 6.]])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注</strong>：<code>PyTorch</code>操作<code>inplace</code>版本都有后缀<code>_</code>, 例如<code>x.copy_(y), x.t_()</code></p><h2 id="与numpy的转换"><a href="#与numpy的转换" class="headerlink" title="与numpy的转换"></a>与numpy的转换</h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">t &#x3D; torch.ones(5)print(f&quot;t: &#123;t&#125;&quot;)# t: tensor([1., 1., 1., 1., 1.])n &#x3D; t.numpy()print(f&quot;n: &#123;n&#125;&quot;)# n: [1. 1. 1. 1. 1.]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>张量与<code>numpy</code>共享存储空间，<code>tensor</code>改变，<code>numpy</code>也会改变</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">t.add_(1)print(f&quot;t: &#123;t&#125;&quot;)# t: tensor([2., 2., 2., 2., 2.])print(f&quot;n: &#123;n&#125;&quot;)# n: [2. 2. 2. 2. 2.]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>numpy</code>转为<code>tensor</code></p><pre class="line-numbers language-py" data-language="py"><code class="language-py">n &#x3D; np.ones(5)print(f&quot;n: &#123;n&#125;&quot;)# n: [1. 1. 1. 1. 1.]t &#x3D; torch.from_numpy(n)print(f&quot;t: &#123;t&#125;&quot;)# t: tensor([1., 1., 1., 1., 1.], dtype&#x3D;torch.float64)np.add(n, 1, out&#x3D;n)print(f&quot;n: &#123;n&#125;&quot;)# n: [2. 2. 2. 2. 2.]print(f&quot;t: &#123;t&#125;&quot;)# t: tensor([2., 2., 2., 2., 2.], dtype&#x3D;torch.float64)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝与浅拷贝</title>
      <link href="2021/10/16/Python-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>2021/10/16/Python-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="Python标签"><a href="#Python标签" class="headerlink" title="Python标签"></a>Python标签</h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">res &#x3D; []def func(obj):    res.append(obj)a &#x3D; [1, 2, 3]print(id(a))        # 2897774181960func(a)print(id(res[0]))   # 2409845052424print(&quot;res: &quot;, res)a.append(4)print(&quot;res: &quot;, res)res:  [[1, 2, 3]]res:  [[1, 2, 3, 4]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从输出可以看到，<code>a</code>和<code>res[0]</code>的<code>id</code>一样，说明指向了同一块内存空间，所以<code>a</code>改变了之后<code>res[0]</code>也跟着改变了，你以为拷贝了，其实并没有</p><p>原因：</p><p><code>Python</code>没有变量，我们平时所说的变量其实只是<strong>标签</strong>，是<strong>引用</strong>。<br>执行：<code>values=[0,1,2]</code>的时候，<code>python</code>做的事情是首先创建一个列表对象<code>[0,1,2]</code>，然后给它贴上名为<code>values</code>的标签。如果随后执行<code>values=[3,4,5]</code>的话，<code>python</code>做的事情是创建另一个列表对象<code>[3,4,5]</code>，然后把刚才那张名为<code>values</code>的标签从前面的<code>[0,1,2]</code>对象上撕下来，重新贴到<code>[3,4,5]</code>这个对象上。</p><p>所以，这里的<code>a</code>和<code>res[0]</code>就相当于两张标签贴到了同一个对象<code>[1,2,3]</code>上</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>解决办法是用拷贝，这里先说浅拷贝<code>shallow copy</code></p><p>注意：<code>[:]</code>生成对象的拷贝或者是复制序列，不再是引用和共享变量，但此法只能顶层复制</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">res &#x3D; []def func(obj):    res.append(obj[:])  # 这里不一样a &#x3D; [1, 2, 3]print(id(a))        # 1558831191048func(a)print(id(res[0]))   # 1558832493512print(&quot;res: &quot;, res)a.append(4)print(&quot;a: &quot;, a)print(&quot;res: &quot;, res)res:  [[1, 2, 3]]a:  [1, 2, 3, 4]res:  [[1, 2, 3]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<code>a</code>和<code>res[0]</code>的<code>id</code>不一样了，<code>a</code>改变了之后，<code>res[0]</code>没有改变，对于这种场景，浅拷贝就适用了，但如果包含子对象，浅拷贝就有问题了</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">a &#x3D; [0, [1, 2], 3]b &#x3D; a[:]a[0] &#x3D; 8a[1][1] &#x3D; 9print(a)  # [8, [1, 9], 3]print(b)  # [0, [1, 9], 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<code>b[1][1]</code>也跟着改变了，这就是浅拷贝只做顶层拷贝的效果</p><center><img src="/2021/10/16/Python-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/copy.png#pic_center" width="50%" height="50%"></center><p>原因从图里就可以看出来了，<code>a[1]</code>和<code>b[1]</code>还是指向了同一个对象</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>解决办法使用深拷贝</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import copya &#x3D; [0, [1, 2], 3]b &#x3D; copy.deepcopy(a)print(id(a[1]))  # 2071720571784print(id(b[1]))  # 2071721298184a[0] &#x3D; 8a[1][1] &#x3D; 9print(a)  # [8, [1, 9], 3]print(b)  # [0, [1, 2], 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>深拷贝之后就指向两个完全不同的对象了</p><p>对象也是一样</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import copyclass Person:    def __init__(self):        self.num &#x3D; [1, 2]p1 &#x3D; Person()print(p1.num)   # [1, 2]p2 &#x3D; p1         # 指向同一个内存print(p2.num)   # [1, 2]p3 &#x3D; copy.deepcopy(p1)  # 深拷贝print(p3.num)   # [1, 2]p1.num.append(3)print(p1.num)   # [1, 2, 3]print(p2.num)   # [1, 2, 3] 也改变了print(p3.num)   # [1, 2] 没有改变<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率分布函数</title>
      <link href="2021/10/14/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87%E8%AE%BA-%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0/"/>
      <url>2021/10/14/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87%E8%AE%BA-%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Discrete-Random-Variable"><a href="#Discrete-Random-Variable" class="headerlink" title="Discrete Random Variable"></a>Discrete Random Variable</h3><p>离散型随机变量，随机变量的取值是有穷可列举的<br>通常用大写字母表示随机变量，用小写字母表示随机变量的观测值</p><h4 id="Probabolity-Mass-Function"><a href="#Probabolity-Mass-Function" class="headerlink" title="Probabolity Mass Function"></a>Probabolity Mass Function</h4><p>直译为概率质量函数，教科书常用<strong>概率分布</strong>，表明随机变量有哪几种取值可能，每种所对应的概率是多少，所以严格来讲应该叫<strong>离散型随机变量值分布与概率分布</strong></p><p>用数学语言来讲，<strong>概率分布</strong>是表示所有$P(X=x)$或$p(x)$的图、表、公式</p><p>例如抛骰子</p><p><img src="/2021/10/14/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87%E8%AE%BA-%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0/table2.png" alt></p><center><img src="/2021/10/14/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87%E8%AE%BA-%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0/111.png#pic_center" width="50%" height="50%"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">概率分布</div></center><h4 id="Cumulative-Distribution-Function"><a href="#Cumulative-Distribution-Function" class="headerlink" title="Cumulative Distribution Function"></a>Cumulative Distribution Function</h4><p>直译为<strong>累计分布函数</strong>，教科书直接叫<strong>分布函数</strong>，是对概率分布的<strong>累加</strong></p><p><img src="/2021/10/14/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87%E8%AE%BA-%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0/222.png" alt></p><p>可以看到</p><script type="math/tex; mode=display">F_X(x = 4) = \mathbb{P}(X \leq 4) = \sum_{x_i=1}^{4}p(x_i)</script><h4 id="Expectation-Mean"><a href="#Expectation-Mean" class="headerlink" title="Expectation/Mean"></a>Expectation/Mean</h4><p>对于离散随机变量$X$，函数$h(X)$关于变量$X$的期望是</p><script type="math/tex; mode=display">\mathbb{E}_{X\sim p(\cdot)}[h(X)] = \sum_{x \in \mathcal{X}}p(x) \cdot h(x)</script><h3 id="Continuous-Random-Variable"><a href="#Continuous-Random-Variable" class="headerlink" title="Continuous Random Variable"></a>Continuous Random Variable</h3><p>连续型随机变量</p><h4 id="Probability-Density-Function"><a href="#Probability-Density-Function" class="headerlink" title="Probability Density Function"></a>Probability Density Function</h4><p>连续型随机变量的概率分布，称为<strong>概率密度函数</strong></p><p>性质：</p><ol><li>函数值大于等于0</li><li>在区间$(-\infty, +\infty)$上的积分为1</li><li>连续型随机变量的取值为区间$(a, b]$，其概率等于概率密度函数在相应区间上的面积</li></ol><script type="math/tex; mode=display">\mathbb{P}\left\{a < X \leq b\right\} = F_X(b) - F_X(a) = \int_{a}^{b}f(x)dx</script><h4 id="Cumulative-Distribution-Function-1"><a href="#Cumulative-Distribution-Function-1" class="headerlink" title="Cumulative Distribution Function"></a>Cumulative Distribution Function</h4><p>连续型随机变量也是叫<strong>分布函数</strong>，由概率密度函数积分得到</p><script type="math/tex; mode=display">\mathbb{P} \left\{X \leq x\right\} = F_X(x) = \int_{-\infty}^{x}f(u)du</script><p><img src="/2021/10/14/%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87%E8%AE%BA-%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0/222333.png" alt></p><p>所以，概率密度函数与横轴的面积就是对应分布函数的函数值</p><h4 id="Expectation-Mean-1"><a href="#Expectation-Mean-1" class="headerlink" title="Expectation/Mean"></a>Expectation/Mean</h4><p>对于连续随机变量$X$，概率密度函数为$p(x)$，对$X$求期望</p><script type="math/tex; mode=display">\mathbb{E}_{X \sim p(\cdot)}[X] = \int_{\mathcal{X}} x \cdot p(x) dx</script><p>花体$\mathcal{X}$是随机变量$X$的取值范围</p><p>函数$h(X)$关于变量$X$的期望是</p><script type="math/tex; mode=display">\mathbb{E}_{X\sim p(\cdot)}[h(X)] = \int_{\mathcal{X}} h(x) \cdot p(x) dx</script><p>对某个随机随机变量求期望就可以消掉该变量</p><p>例如：$g(X,Y)=\frac{1}{5}XY$为二元函数，$X$的取值范围为$[0,10]$，概率密度函数为$p(x)=\frac{1}{10}$，对$X$求期望</p><script type="math/tex; mode=display">\begin{align*}\mathbb{E}_{X \sim p(\cdot) }[g(X,Y)] &= \int_{\mathcal{X}}g(x, Y) \cdot p(x) dx \\&= \int_{0}^{10}\frac{1}{5}xY \cdot \frac{1}{10} dx \\&= Y\end{align*}</script><p>可以看到，结果是不含随机变量$X$的，只包含随机变量$Y$</p><h4 id="Conditional-Expectation-Mean"><a href="#Conditional-Expectation-Mean" class="headerlink" title="Conditional Expectation/Mean"></a>Conditional Expectation/Mean</h4><p>如果在$Y=y$条件下$X$的条件概率密度函数为$f(x|Y=y)$，那么$X$的条件期望为</p><script type="math/tex; mode=display">\mathbb{E}_{X \sim f(\cdot | Y=y)} [X|Y=y] = \int_{\mathcal{X}} x \cdot f(x | Y=y) dx</script><p>或者直接写成</p><script type="math/tex; mode=display">\mathbb{E}_{X \sim f(\cdot | y)} [X|Y=y] = \int_{\mathcal{X}} x \cdot f(x | y) dx</script><p>从这里可以看出来，对$X$求期望会消掉$X$，所以条件期望$\mathbb{E}[X|Y=y]$的结果是一个$Y=y$条件下的确定的值<br>如果$Y$没有取值，那$\mathbb{E}[X|Y]$依然是一个关于$Y$的随机变量，有概率密度为$f(y)$，就可以求期望</p><script type="math/tex; mode=display">\begin{align*}\mathbb{E}_{Y \sim p(\cdot)} [\mathbb{E} [X|Y] ] &= \int_{\mathcal{Y}} {\color{teal}{\int_{\mathcal{X}} x f(x|y) dx}} \cdot f(y) dy \\&= \int_{\mathcal{Y}} \int_{\mathcal{X}} x \cdot {\color{Tomato}{f(x|y)f(y)}} dx  dy \\&= \int_{\mathcal{Y}} \int_{\mathcal{X}} x {\color{Tomato}{f(x,y)}} dy \\&= \mathbb{E}\left[X\right]\end{align*}</script><p>这里用到了贝叶斯公式</p><script type="math/tex; mode=display">f(x|y) = \frac{f(x, y)}{f(y)}</script>]]></content>
      
      
      <categories>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件</title>
      <link href="2021/10/10/Linux-%E6%96%87%E4%BB%B6/"/>
      <url>2021/10/10/Linux-%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">#!&#x2F;usr&#x2F;bin&#x2F;env python3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用哪个解释器去解释/运行脚本</p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">7 &#x3D; 4 + 2 + 1r(可读) w(可写) x(可执行)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>分为三个部分:</p><ul><li><code>Owner</code></li><li><code>Group</code></li><li><code>Others</code></li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">644 -rw-r--r-- 所有者可读可写755 -rwxr-xr-x 所有者可读可写可执行777 -rwxrwxrwx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h2><p><code>mv</code>: 英文<code>move</code>，移动文件，重命名<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv hwllo.txt hello.txt  # 重命名mv dir1 dir2            # 移动文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p><code>cp</code>: 英文<code>copy</code>，复制文件<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cp a.txt a_copy.txtcp -r dir1 dir2     # 复制文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p><code>rm</code>: 英文<code>remove</code>，删除文件，没有回收站<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm a.txt        # 删除单个文件rm a.txt b.txt c.txt    # 删除多个文件rm -r dir1      # 删除文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><code>$PATH</code>: 以<code>:</code>分割的文件夹列表<br>指明到哪里去找可执行文件(按照文件夹的顺序查找)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PATH&#x3D;$PATH:$PWD     # 把当前目录追加到PATH中<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只对当前终端有效<br>要对全局有效的话要加入到<code>.bashrc</code>或<code>.zshrc</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征值与特征向量</title>
      <link href="2021/10/09/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/"/>
      <url>2021/10/09/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>设$A$为$n \times n$阶方阵，若存在常数$\lambda$及$n$维<strong>非零</strong>向量$\boldsymbol{v}$，使得$A \boldsymbol{v} = \lambda \boldsymbol{v}$，则称$\lambda$是矩阵$A$的特征值<code>eigenvalue</code>，$\boldsymbol{v}$是$A$属于特征值$\lambda$的特征向量<code>eigenvector</code></p><p>向量$\boldsymbol{v}$左乘矩阵$A$意味着对向量$\boldsymbol{v}$做变换，等式右边是一个常数乘以向量，说明只有拉伸变换，没有旋转变换</p><h2 id="求矩阵特征值与特征向量"><a href="#求矩阵特征值与特征向量" class="headerlink" title="求矩阵特征值与特征向量"></a>求矩阵特征值与特征向量</h2><p>解方程$(A - \lambda I) \boldsymbol{v} = \boldsymbol{0}$，等价于$det(A - \lambda I) = 0$</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>矩阵$\begin{bmatrix}3 &amp; 1 \\ 0 &amp; 2\end{bmatrix}$的特征值为$\lambda_1 = 2, \lambda_2 = 3$，对应的特征向量是$y=-x$和$y=0$上的向量，说明这两条直线上的向量分别被拉伸了2倍和3倍</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">R &#x3D; [3 1; 0 2];[V, D] &#x3D; eig(R) &#x2F;&#x2F; 给出的是单位特征向量V &#x3D;    1.0000   -0.7071         0    0.7071D &#x3D;    3    0    0    2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>(1) 求矩阵的高次幂</p><p>我们知道对角矩阵的$N$次幂就是对角元素的$N$次幂</p><script type="math/tex; mode=display">\begin{bmatrix}a & 0 \\ 0 & b\end{bmatrix}^n = \begin{bmatrix}a^n & 0 \\ 0 & b^n\end{bmatrix}</script><p>因为$A\boldsymbol{v} = \lambda \boldsymbol{v}$<br>所以</p><script type="math/tex; mode=display">\begin{aligned}& \quad \enspace \boldsymbol{v}^{-1} A \boldsymbol{v} = \boldsymbol{v}^{-1} \lambda \boldsymbol{v} = \lambda \\& \Leftrightarrow A = \boldsymbol{v} \lambda \boldsymbol{v}^{-1} \\& \Leftrightarrow A^n = \boldsymbol{v} \lambda \boldsymbol{v}^{-1} \boldsymbol{v} \lambda \boldsymbol{v}^{-1} \ldots \boldsymbol{v} \lambda \boldsymbol{v}^{-1} = \boldsymbol{v} \lambda^n \boldsymbol{v}^{-1}\end{aligned}</script><p>例子：<br>直接算</p><script type="math/tex; mode=display">\begin{bmatrix}3 & 1 \\ 0 & 2\end{bmatrix}^2 = \begin{bmatrix}9 & 5 \\ 0 & 4\end{bmatrix}</script><p>用特征值和特征向量算</p><script type="math/tex; mode=display">\begin{bmatrix}3 & 1 \\ 0 & 2\end{bmatrix}^2 = \begin{bmatrix}1 & 1 \\ 0 & -1\end{bmatrix}\begin{bmatrix}3^2 & 0 \\ 0 & 2^2\end{bmatrix}\begin{bmatrix}1 & 1 \\ 0 & -1\end{bmatrix}^{-1} = \begin{bmatrix}9 & 5 \\ 0 & 4\end{bmatrix}</script><p>结果是一样的</p><p>(2) 旋转轴</p><p>对于三维旋转矩阵，特征向量就是在变换中没有旋转的向量，也就是旋转轴，所以可以通过求旋转矩阵的特征向量得到<strong>旋转轴</strong></p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半正定矩阵</title>
      <link href="2021/10/09/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%8D%8A%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5/"/>
      <url>2021/10/09/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%8D%8A%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>半正定矩阵的定义为：给定一个大小为$n \times n$的实对称矩阵$M$，若对于任意长度为$n$的非零向量$X$，有$X^{T}MX \ge 0$恒成立，则矩阵$M$是一个<strong>半正定矩阵</strong>，若有$X^{T}MX &gt; 0$恒成立，则矩阵$M$是一个<strong>正定矩阵</strong></p><p>理解：<br>$X$是<strong>向量</strong>，$M$看成<strong>变换矩阵</strong><br>向量左乘矩阵，相当于对向量做<strong>线性变换</strong>，记变换后的结果为$Y$，则半正定矩阵可写成：$X^{T}Y \ge 0$，即为两个向量的内积，根据向量夹角公式有</p><script type="math/tex; mode=display">cos\theta = \frac{X^{T} Y}{||X|| \cdot ||Y||}</script><p>所以半正定矩阵的含义：向量$X$经过$M$矩阵变换后的结果与自身的夹角小于等于$90^{\circ}$，这样的矩阵称为半正定矩阵</p><h2 id="半正定判断"><a href="#半正定判断" class="headerlink" title="半正定判断"></a>半正定判断</h2><h3 id="特征值判断"><a href="#特征值判断" class="headerlink" title="特征值判断"></a>特征值判断</h3><ul><li>半正定：所有特征值都大于等于0</li><li>正定：所以特征值都大于0</li></ul><h3 id="matlab求特征值"><a href="#matlab求特征值" class="headerlink" title="matlab求特征值"></a>matlab求特征值</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">A &#x3D; [1 2 3; 4 5 6; 7 8 9];[V, D] &#x3D; eig(A);    &#x2F;&#x2F; V是特征向量，D是对应的特征值V &#x3D;   -0.2320   -0.7858    0.4082   -0.5253   -0.0868   -0.8165   -0.8187    0.6123    0.4082D &#x3D;   16.1168         0         0         0   -1.1168         0         0         0   -0.0000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有负的特征值，所以A不是半正定矩阵</p><h3 id="行列式判断"><a href="#行列式判断" class="headerlink" title="行列式判断"></a>行列式判断</h3><p>如果矩阵$M$的行列式$|M|$的各阶顺序主子式都大于0，则矩阵$M$为正定矩阵<br>如果奇数阶为负，偶数阶为正，则矩阵$M$为负定矩阵</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>多元函数$f(\boldsymbol{x})$在点$\boldsymbol{x}_k$取极值的必要条件是</p><script type="math/tex; mode=display">\nabla f(\boldsymbol{x}_k) = 0</script><p>在$\boldsymbol{x}_k$点泰勒展开</p><script type="math/tex; mode=display">f(\boldsymbol{x}) - f(\boldsymbol{x}_k) \approx [\nabla f(\boldsymbol{x}_k)]^{\mathrm{T}}[\boldsymbol{x} - \boldsymbol{x}_k] + \frac{1}{2} [\boldsymbol{x} - \boldsymbol{x}_k]^{\mathrm{T}} \boldsymbol{H}(\boldsymbol{x}_k) [\boldsymbol{x} - \boldsymbol{x}_k]</script><p>令$\Delta \boldsymbol{x} = \boldsymbol{x} - \boldsymbol{x}_k$，代入可得</p><script type="math/tex; mode=display">f(\boldsymbol{x}) - f(\boldsymbol{x}_k) \approx \frac{1}{2} \Delta \boldsymbol{x}^{\mathrm{T}} \boldsymbol{H}(\boldsymbol{x}_k) \Delta \boldsymbol{x}</script><p>要让$\boldsymbol{x}_k$为<font color="red">极小值点</font>，就必须保证$\boldsymbol{x}_k$领域内的一切$\boldsymbol{x}$，恒有$f(\boldsymbol{x}_k) &lt; f(\boldsymbol{x})$，也就是$\Delta \boldsymbol{x}^{\mathrm{T}} \boldsymbol{H}(\boldsymbol{x}_k) \Delta \boldsymbol{x} &gt; 0$，所以$\boldsymbol{H}(\boldsymbol{x}_k)$必须为<font color="red">正定矩阵</font><br>类似的，若要保证$\boldsymbol{x}_k$为<font color="blue">极大值点</font>，$\boldsymbol{H}(\boldsymbol{x}_k)$必须为<font color="blue">负定矩阵</font></p><p><strong>总结</strong><br>对于多元函数$f(\boldsymbol{x})$，如果$\boldsymbol{x}_k$是驻点，也就是$\nabla f(\boldsymbol{x}_k) = 0$，那么</p><ul><li>若$\boldsymbol{H}(\boldsymbol{x}_k)$为正定矩阵，则$\boldsymbol{x}_k$为极小值</li><li>若$\boldsymbol{H}(\boldsymbol{x}_k)$为负定矩阵，则$\boldsymbol{x}_k$为极大值</li></ul><script type="math/tex; mode=display">\boldsymbol{H}_{ij} = \frac{\partial ^2 f}{\partial x_i \partial x_j}</script><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>求$f(\boldsymbol{x}) = x_1^2+x_2^2-6x_1-4x_2+9$的极值<br>先求梯度向量</p><script type="math/tex; mode=display">\nabla f(\boldsymbol{x}) = \begin{bmatrix}    2x_1-6 \\    2x_2-4\end{bmatrix}</script><p>再求<code>Hessian</code>矩阵</p><script type="math/tex; mode=display">\boldsymbol{H}(\boldsymbol{x}) = \begin{bmatrix}    2 & 0 \\    0 & 2\end{bmatrix}</script><p>令$\nabla f(\boldsymbol{x}) = 0$可得驻点为$\boldsymbol{x}_k = \begin{bmatrix}3 &amp; 2 \end{bmatrix}^\mathrm{T}$，又因为$\boldsymbol{H}(\boldsymbol{x}_k)$为正定矩阵，所以$\boldsymbol{x}_k$是极小值点，对应极小值为$f(\boldsymbol{x}) = -4$</p><p><code>matlab</code>验证</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">n &#x3D; [-10:0.1:10;-10:0.1:10];[x1, x2] &#x3D; meshgrid(n(1,:), n(2,:));f &#x3D; x1.^2 + x2.^2 - 6*x1 - 4*x2 + 9;minval &#x3D; min(min(f));[row, column] &#x3D; find(f &#x3D;&#x3D; minval);mesh(x1, x2, f);x1(row, column);x2(row, column);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/10/09/%E6%95%B0%E5%AD%A6-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%8D%8A%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5/ff.png" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">minval &#x3D; -4x1 &#x3D; 3x2 &#x3D; 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>91-解码方法</title>
      <link href="2021/10/07/LeetCode-91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/"/>
      <url>2021/10/07/LeetCode-91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-91-Decode-Ways"><a href="#LeetCode-91-Decode-Ways" class="headerlink" title="LeetCode 91. Decode Ways"></a>LeetCode 91. Decode Ways</h2><p>A message containing letters from <code>A-Z</code> can be encoded into <code>numbers</code> using the following mapping:<br><pre class="line-numbers language-none"><code class="language-none">&#39;A&#39; -&gt; &quot;1&quot;&#39;B&#39; -&gt; &quot;2&quot;...&#39;Z&#39; -&gt; &quot;26&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, “11106” can be mapped into:<br><pre class="line-numbers language-none"><code class="language-none">&quot;AAJF&quot; with the grouping (1 1 10 6)&quot;KJF&quot; with the grouping (11 10 6)Note that the grouping (1 11 06) is invalid because &quot;06&quot; cannot be mapped into &#39;F&#39; since &quot;6&quot; is different from &quot;06&quot;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>Given a string <code>s</code> containing <strong>only digits</strong>, return the number of ways to decode it.</p><p>The answer is guaranteed to fit in a <code>32-bit</code> integer.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;12&quot;Output: 2Explanation: &quot;12&quot; could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;226&quot;Output: 3Explanation: &quot;226&quot; could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-1-记忆化搜索"><a href="#method-1-记忆化搜索" class="headerlink" title="method 1: 记忆化搜索"></a>method 1: 记忆化搜索</h2><p>一个字符串的解码方法=去除第一个字符的解码方法+去除前连个字符</p><p>记忆化方法，<code>map</code>存储每个下标对应的解码数，重复处理下标时可以立即返回</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unordered_map&lt;int, int&gt; hash;int reversal(string&amp; s, int l, int r) &#123;    if (hash[l]) return hash[l];    if (s[l] &#x3D;&#x3D; &#39;0&#39;) return 0;  &#x2F;&#x2F; 首字母为0，不合法    if (l &gt;&#x3D; r) return 1;       &#x2F;&#x2F; 只有一个字符或空    int res &#x3D; reversal(s, l + 1, r);    int num &#x3D; (s[l] - &#39;0&#39;) * 10 + (s[l + 1] - &#39;0&#39;);    if (num &gt;&#x3D; 10 &amp;&amp; num &lt;&#x3D; 26)        res +&#x3D; reversal(s, l + 2, r);    hash[l] &#x3D; res;    return res;&#125;int numDecodings(string s) &#123;    return reversal(s, 0, s.size() -1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-动态规划"><a href="#method-2-动态规划" class="headerlink" title="method 2: 动态规划"></a>method 2: 动态规划</h2><p>基本模型是<code>dp[i] = dp[i-1] + dp[i-2]</code><br>不过要加一些条件，如果<code>s[i]</code>有效，就是<code>dp[i] += dp[i-1]</code><br>如果<code>s[i-1]s[i]</code>也有效，再加上<code>dp[i-2]</code></p><p><code>dp[1]</code>要特殊处理一下，不然会越界取到<code>dp[-1]</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool isValue(char c) &#123;    if (c !&#x3D; &#39;0&#39;) return true;    return false;&#125;bool isValue(char c1, char c2) &#123;    int num &#x3D; (c1 - &#39;0&#39;) * 10 + (c2 - &#39;0&#39;);    if (num &gt;&#x3D; 10 &amp;&amp; num &lt;&#x3D; 26) return true;    return false;&#125;int numDecodings(string s) &#123;    if (s.size() &#x3D;&#x3D; 0 || s[0] &#x3D;&#x3D; &#39;0&#39;) return 0;    if (s.size() &#x3D;&#x3D; 1) return 1;    vector&lt;int&gt; dp(s.size());    dp[0] &#x3D; 1;  &#x2F;&#x2F; 已经确保s[0]有效，还要考虑dp[1]    if (!isValue(s[1]) &amp;&amp; !isValue(s[0], s[1])) return 0;    if (isValue(s[1])) dp[1] +&#x3D; 1;    if (isValue(s[0], s[1])) dp[1] +&#x3D; 1;    for (int i &#x3D; 2; i &lt; s.size(); i++) &#123;        if (!isValue(s[i]) &amp;&amp; !isValue(s[i - 1], s[i]))             return 0;        if (isValue(s[i])) dp[i] +&#x3D; dp[i - 1];        if (isValue(s[i - 1], s[i])) dp[i] +&#x3D; dp[i - 2];    &#125;    return dp.back();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用变量替换滚动数组</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int numDecodings(string s) &#123;    if (s.size() &#x3D;&#x3D; 0 || s[0] &#x3D;&#x3D; &#39;0&#39;) return 0;    if (s.size() &#x3D;&#x3D; 1) return 1;    int w1 &#x3D; 1;     &#x2F;&#x2F; 相当于dp[i-1]    int w2 &#x3D; 1;     &#x2F;&#x2F; 相当于dp[i-2]    for (int i &#x3D; 1; i &lt; s.size(); i++) &#123;        int w &#x3D; 0;  &#x2F;&#x2F; 相当于dp[i]        if (!isValue(s[i]) &amp;&amp; !isValue(s[i - 1], s[i])) return 0;        if (isValue(s[i])) w +&#x3D; w1;        if (isValue(s[i - 1], s[i])) w +&#x3D; w2;        w2 &#x3D; w1;    &#x2F;&#x2F; dp[i-1]在下一次迭代就变成了dp[i-2]        w1 &#x3D; w;     &#x2F;&#x2F; dp[i]在下一次迭代就变成了dp[i-1]    &#125;    return w1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>189-旋转数组</title>
      <link href="2021/10/07/LeetCode-189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/"/>
      <url>2021/10/07/LeetCode-189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-189-Rotate-Array"><a href="#LeetCode-189-Rotate-Array" class="headerlink" title="LeetCode 189. Rotate Array"></a>LeetCode 189. Rotate Array</h2><p>Given an array, <strong>rotate</strong> the array to the right by <code>k</code> steps, where k is non-negative.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>把<code>nums[i]</code>赋值到移动后的位置，注意取模</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void rotate(vector&lt;int&gt;&amp; nums, int k) &#123;    vector&lt;int&gt; res(nums.size());    for (int i &#x3D; 0; i &lt; res.size(); i++) &#123;        res[(i + k) % nums.size()] &#x3D; nums[i];    &#125;    nums &#x3D; res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32-基础</title>
      <link href="2021/10/01/%E5%B5%8C%E5%85%A5%E5%BC%8F-stm32-%E5%9F%BA%E7%A1%80/"/>
      <url>2021/10/01/%E5%B5%8C%E5%85%A5%E5%BC%8F-stm32-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="LED"><a href="#LED" class="headerlink" title="LED"></a>LED</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#ifndef __LED_H#define __LED_H #include &quot;sys.h&quot;#define LED0 PBout(5)   &#x2F;&#x2F; PB5#define LED1 PEout(5)   &#x2F;&#x2F; PE5void LED_Init(void);    &#x2F;&#x2F;初始化#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h3><p><code>RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE)</code>: 使能端口的时钟<br><code>GPIO_Init(GPIOB, &amp;GPIO_InitStructure)</code>: 端口初始化</p><p><code>GPIO_InitTypeDef</code>的成员变量：</p><ul><li><code>GPIO_Pin</code>: 指定哪个端口</li><li><code>GPIO_Mode</code>: 输入输出的模式<ul><li><code>GPIO_Mode_Out_PP</code>: 推挽输出(Push Pull)</li><li><code>GPIO_Mode_IPU</code>: 上拉输入(Input Up)</li><li><code>GPIO_Mode_IPD</code>: 下拉输入(Input Down)</li></ul></li><li><code>GPIO_Speed</code>: 端口速度<ul><li><code>GPIO_Speed_50MHz</code></li><li><code>GPIO_Speed_10MHz</code></li></ul></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;led.h&quot;void LED_Init(void) &#123;    GPIO_InitTypeDef GPIO_InitStructure;    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOE, ENABLE); &#x2F;&#x2F;使能PB,PE端口时钟    GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_5;           &#x2F;&#x2F; LED0--&gt;PB.5 端口配置    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_Out_PP;    &#x2F;&#x2F; 推挽输出    GPIO_InitStructure.GPIO_Speed &#x3D; GPIO_Speed_50MHz;   &#x2F;&#x2F; IO口速度为50MHz    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);              &#x2F;&#x2F; 根据设定参数初始化GPIOB.5    GPIO_SetBits(GPIOB,GPIO_Pin_5);                     &#x2F;&#x2F; PB.5 输出高    GPIO_InitStructure.GPIO_Pin &#x3D; GPIO_Pin_5;   &#x2F;&#x2F; LED1--&gt;PE.5 端口配置, 推挽输出    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);      &#x2F;&#x2F; 推挽输出，IO口速度为50MHz    GPIO_SetBits(GPIOE,GPIO_Pin_5);             &#x2F;&#x2F; PE.5 输出高&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="main文件"><a href="#main文件" class="headerlink" title="main文件"></a>main文件</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;sys.h&quot;#include &quot;delay.h&quot;#include &quot;usart.h&quot;#include &quot;led.h&quot;int main(void) &#123;    delay_init();   &#x2F;&#x2F;延时函数初始化      LED_Init();     &#x2F;&#x2F;初始化与LED连接的硬件接口    while (1) &#123;        LED0 &#x3D; 0;   &#x2F;&#x2F; LED0亮        LED1 &#x3D; 1;   &#x2F;&#x2F; LED1灭        delay_ms(300);        LED0 &#x3D; 1;   &#x2F;&#x2F; LED0灭        LED1 &#x3D; 0;   &#x2F;&#x2F; LED1亮        delay_ms(300);    &#125;&#125;&#x2F;&#x2F; 库函数写法int main(void) &#123;    delay_init();    LED_Init();    while (1) &#123;        GPIO_ResetBits(GPIOB,GPIO_Pin_5);   &#x2F;&#x2F;LED0引脚GPIOB.5拉低，亮 等同LED0&#x3D;0;        GPIO_SetBits(GPIOE,GPIO_Pin_5);     &#x2F;&#x2F;LED1引脚GPIOE.5拉高，灭 等同LED1&#x3D;1;        delay_ms(300);        GPIO_SetBits(GPIOB,GPIO_Pin_5);     &#x2F;&#x2F;LED0引脚GPIOB.5拉高，灭 等同LED0&#x3D;1;        GPIO_ResetBits(GPIOE,GPIO_Pin_5);   &#x2F;&#x2F;LED1引脚GPIOE.5拉低，亮 等同LED1&#x3D;0;        delay_ms(300);    &#125;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="按键输入"><a href="#按键输入" class="headerlink" title="按键输入"></a>按键输入</h2><h3 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#ifndef __KEY_H#define __KEY_H #include &quot;sys.h&quot;#define KEY0    GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_4)&#x2F;&#x2F;读取按键0#define KEY1    GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_3)&#x2F;&#x2F;读取按键1#define WK_UP   GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)&#x2F;&#x2F;读取按键3(WK_UP) #define KEY0_PRES   1&#x2F;&#x2F;KEY0按下#define KEY1_PRES   2&#x2F;&#x2F;KEY1按下#define WKUP_PRES   3&#x2F;&#x2F;KEY_UP按下void KEY_Init(void);    &#x2F;&#x2F;IO初始化u8 KEY_Scan(u8);        &#x2F;&#x2F;按键扫描函数#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="源文件-1"><a href="#源文件-1" class="headerlink" title="源文件"></a>源文件</h3><p>按键对应的端口要设置为<strong>上拉或下拉输入</strong><br>通过按键扫描函数的返回值确定是哪个按键被按下了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;stm32f10x.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot; #include &quot;delay.h&quot;void KEY_Init(void) &#123;    GPIO_InitTypeDef GPIO_InitStructure;    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOE,ENABLE);&#x2F;&#x2F;使能PORTA,PORTE时钟    GPIO_InitStructure.GPIO_Pin  &#x3D; GPIO_Pin_4|GPIO_Pin_3;   &#x2F;&#x2F;KEY0-KEY1    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_IPU;           &#x2F;&#x2F;上拉输入    GPIO_Init(GPIOE, &amp;GPIO_InitStructure);                  &#x2F;&#x2F;初始化GPIOE3&#x2F;4    &#x2F;&#x2F;初始化 WK_UP--&gt;GPIOA.0  下拉输入    GPIO_InitStructure.GPIO_Pin  &#x3D; GPIO_Pin_0;    GPIO_InitStructure.GPIO_Mode &#x3D; GPIO_Mode_IPD; &#x2F;&#x2F;PA0设置成输入，默认下拉      GPIO_Init(GPIOA, &amp;GPIO_InitStructure);&#x2F;&#x2F;初始化GPIOA.0&#125;u8 KEY_Scan(u8 mode) &#123;    static u8 key_up &#x3D; 1;   &#x2F;&#x2F;按键按松开标志    if (mode) key_up &#x3D; 1;   &#x2F;&#x2F;支持连按    if (key_up &amp;&amp; (KEY0&#x3D;&#x3D;0 || KEY1&#x3D;&#x3D;0 || WK_UP&#x3D;&#x3D;1)) &#123;        delay_ms(10);       &#x2F;&#x2F;去抖动         key_up &#x3D; 0;        if (KEY0 &#x3D;&#x3D; 0) return KEY0_PRES;        else if (KEY1 &#x3D;&#x3D; 0) return KEY1_PRES;        else if (WK_UP &#x3D;&#x3D; 1) return WKUP_PRES;    &#125; else if (KEY0&#x3D;&#x3D;1 &amp;&amp; KEY1&#x3D;&#x3D;1 &amp;&amp; WK_UP&#x3D;&#x3D;0) key_up &#x3D; 1;    return 0;               &#x2F;&#x2F; 无按键按下&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>根据按键扫描函数的返回值做相应的动作</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;led.h&quot;#include &quot;delay.h&quot;#include &quot;key.h&quot;#include &quot;sys.h&quot;#include &quot;beep.h&quot;int main(void) &#123;    u8 key &#x3D; 0;    delay_init();   &#x2F;&#x2F;延时函数初始化    LED_Init();     &#x2F;&#x2F;初始化与LED连接的硬件接口    BEEP_Init();    &#x2F;&#x2F;初始化蜂鸣器端口    KEY_Init();     &#x2F;&#x2F;初始化与按键连接的硬件接口    LED0 &#x3D; 0;       &#x2F;&#x2F;先点亮红灯    while (1) &#123;        key &#x3D; KEY_Scan(0);      &#x2F;&#x2F;得到键值        if (key) &#123;              &#x2F;&#x2F; 返回非0说明有按键被按下了            switch (key) &#123;                case WKUP_PRES: &#x2F;&#x2F;控制蜂鸣器                    BEEP &#x3D; !BEEP;                    break;                 case KEY1_PRES: &#x2F;&#x2F;LED1翻转                     LED1 &#x3D; !LED1;                    break;                case KEY0_PRES: &#x2F;&#x2F;LED0,LED1同时翻转                     LED0 &#x3D; !LED0;                    LED1 &#x3D; !LED1;                    break;            &#125;        &#125; else delay_ms(10);     &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>直升机动力学</title>
      <link href="2021/09/29/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E7%9B%B4%E5%8D%87%E6%9C%BA%E5%8A%A8%E5%8A%9B%E5%AD%A6/"/>
      <url>2021/09/29/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E7%9B%B4%E5%8D%87%E6%9C%BA%E5%8A%A8%E5%8A%9B%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>$t_{cD}$：相对于桨盘轴（disc axes）的推力系数，$t_{cD}=\frac{T_D}{\rho sA\Omega^2 R^2}$</p><p>$\bar{V}$：无量纲化前飞速度，除以推力速度，$\bar{V}=\frac{V}{v_0}=\hat{V}\frac{\Omega R}{v_0} \approx \mu_D \frac{\Omega R}{v_0}$</p><p>$\hat{V}$：前飞速度与叶尖速度的比值，$\hat{V}=\frac{V}{\Omega R}$</p><p>$v_{i0}$：平均诱导速度</p><p>$\bar{v_{i0}}$：无量纲化平均诱导速度，$\bar{v_{i0}}=\frac{v_{i0}}{v_0}$</p><p>$v_0$：悬停时的平均诱导速度（推力速度），$v_0=\sqrt{\frac{T}{2\rho A}}$</p><p>$\mu$：气流平行于桨盘平面的速度分量与叶尖速度的比值$\mu = \frac{V_\infty \cos \alpha_D}{\Omega R} \approx \frac{V_\infty}{\Omega R}\approx \hat{V}$</p><p>$\lambda_i$：悬停参数，$\lambda_i=\frac{v_{i0}}{\Omega R} or \frac{v_i}{\Omega R}$</p><h2 id="诱导功率"><a href="#诱导功率" class="headerlink" title="诱导功率"></a>诱导功率</h2><p>推力 = 质量流量 * 诱导速度的变化量</p><script type="math/tex; mode=display">\begin{equation}T = (2v)\rho A \sqrt{(V_\infty cos \alpha_{TPP})^2 + (V_\infty sin \alpha_{TPP} + v)^2}\end{equation}</script><p>$v$: 诱导速度<br>$\alpha_{TPP}$: 气流与桨盘平面的夹角<br>$V_\infty$: 气流速度</p><p>近似处理：$\alpha_{TPP} \approx 0, \cos \alpha_{TPP} \approx 1, \sin \alpha_{TPP} \approx 0$，简化为</p><script type="math/tex; mode=display">\begin{equation}T = (2v)\rho A \sqrt{V_\infty^2 + v^2}\end{equation}</script><p>前飞速度约等于气流速度$V \approx V_\infty$<br>悬停时，诱导速度$v_0=\sqrt{\frac{T}{2 \rho A}} \approx \sqrt{\frac{W}{2 \rho A}}$，代入上式可得</p><script type="math/tex; mode=display">\begin{equation}v = \sqrt{\sqrt{\frac{V^4}{4}+v_0^2}-\frac{V^2}{2}}=v_0\sqrt{\sqrt{\frac{V^4}{4v_0^4}+1}-\frac{V^2}{2v_0^2}}\end{equation}</script><p>所以诱导功率为</p><script type="math/tex; mode=display">\begin{equation}P_{indecued} = Tv \approx Wv = W v_0\sqrt{\sqrt{\frac{V^4}{4v_0^4}+1}-\frac{V^2}{2v_0^2}}\end{equation}</script><p>考虑非均匀诱导速度的影响，引入系数$\kappa \approx 1.1$</p><script type="math/tex; mode=display">\begin{equation}P_{indecued} = \kappa Tv \approx \kappa Wv = \kappa W v_0\sqrt{\sqrt{\frac{V^4}{4v_0^4}+1}-\frac{V^2}{2v_0^2}}\end{equation}</script><p><img src="/2021/09/29/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E7%9B%B4%E5%8D%87%E6%9C%BA%E5%8A%A8%E5%8A%9B%E5%AD%A6/1111.svg" alt></p><h2 id="型阻功率"><a href="#型阻功率" class="headerlink" title="型阻功率"></a>型阻功率</h2><p>与螺旋桨转动方向相切的速度为</p><script type="math/tex; mode=display">\begin{equation}U_T = \Omega r + V_\infty \sin \psi\end{equation}</script><p>翼型阻力表示为</p><script type="math/tex; mode=display">\begin{equation}D^\prime = \frac{1}{2} \rho U_T^2 c C_{d,0}\end{equation}</script><p>型阻功率</p><script type="math/tex; mode=display">\begin{equation}P_{profile} = \frac{b}{2 * \pi} \int_{0}^{2\pi}{\int_{0}^{R}{D^\prime U_T dr d\psi}} = \frac{1}{8}\rho \sigma C_{d,0} A \Omega ^3 R^3 (1 + 3\mu^2)\end{equation}</script><p><img src="/2021/09/29/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E7%9B%B4%E5%8D%87%E6%9C%BA%E5%8A%A8%E5%8A%9B%E5%AD%A6/222.svg" alt></p><h2 id="废阻功率"><a href="#废阻功率" class="headerlink" title="废阻功率"></a>废阻功率</h2><p>机身阻力</p><script type="math/tex; mode=display">\begin{equation}D = \frac{1}{2}\rho S_{FP} V^2\end{equation}</script><p>$S_{FP}$is equivalent flat plate area.</p><script type="math/tex; mode=display">\begin{equation}P_{parasite} = \frac{1}{2} \rho S_{FP} V^3\end{equation}</script><p><img src="/2021/09/29/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E7%9B%B4%E5%8D%87%E6%9C%BA%E5%8A%A8%E5%8A%9B%E5%AD%A6/333.svg" alt></p><h2 id="总飞行功率"><a href="#总飞行功率" class="headerlink" title="总飞行功率"></a>总飞行功率</h2><p><img src="/2021/09/29/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E7%9B%B4%E5%8D%87%E6%9C%BA%E5%8A%A8%E5%8A%9B%E5%AD%A6/total.svg" alt></p><h2 id="爬升功率"><a href="#爬升功率" class="headerlink" title="爬升功率"></a>爬升功率</h2><p>展开成一元二次方程形式</p><script type="math/tex; mode=display">\begin{equation}v^2+v_cv-\frac{W}{2\rho A} = 0\end{equation}</script><p>解出诱导速度</p><script type="math/tex; mode=display">\begin{equation}v = -\frac{1}{2}v_c+\frac{1}{2}\sqrt{v_c^2+\frac{2W}{\rho A}}\end{equation}</script><p>爬升功率表示为</p><script type="math/tex; mode=display">\begin{equation}P_{climb} = Wv_c\end{equation}</script><p>诱导功率</p><script type="math/tex; mode=display">\begin{equation}P_{induced} = Wv = -\frac{1}{2}Wv_c+\frac{1}{2}W\sqrt{v_c^2+\frac{2W}{\rho A}}\end{equation}</script><p>还要加上型阻功率</p><script type="math/tex; mode=display">\begin{equation}P_{prfile} = \frac{1}{8}C_{d,0}\rho A \sigma \Omega^3 R^3 \end{equation}</script><p>总爬升功率为</p><script type="math/tex; mode=display">\begin{equation}P_{prfile} + P_{induced} + P_{climb} = \frac{1}{8}C_{d,0}\rho A \sigma \Omega^3 R^3 + \frac{1}{2}Wv_c+\frac{1}{2}W\sqrt{v_c^2+\frac{2W}{\rho A}}\end{equation}</script><p><img src="/2021/09/29/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E7%9B%B4%E5%8D%87%E6%9C%BA%E5%8A%A8%E5%8A%9B%E5%AD%A6/4444.svg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 多旋翼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>43-字符串相乘</title>
      <link href="2021/09/28/LeetCode-43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/"/>
      <url>2021/09/28/LeetCode-43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-43-Multiply-Strings"><a href="#LeetCode-43-Multiply-Strings" class="headerlink" title="LeetCode 43. Multiply Strings"></a>LeetCode 43. Multiply Strings</h2><p>Given two <code>non-negative</code> integers <code>num1</code> and <code>num2</code> represented as strings, return the <strong>product</strong> of <code>num1</code> and <code>num2</code>, also represented as a <code>string</code>.</p><p>Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: num1 &#x3D; &quot;2&quot;, num2 &#x3D; &quot;3&quot;Output: &quot;6&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: num1 &#x3D; &quot;123&quot;, num2 &#x3D; &quot;456&quot;Output: &quot;56088&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-模拟高精乘法"><a href="#method-模拟高精乘法" class="headerlink" title="method: 模拟高精乘法"></a>method: 模拟高精乘法</h2><p>从最低位开始从后往前计算，先把结果放到数组里，因为要从前往后放结果，所以需要做一个转换，再把多余的零弹出，再反向转换到字符串</p><p>从后往前遍历的<code>index</code>转换为从前往后的对应位置是<code>size - index - 1</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string multiply(string num1, string num2) &#123;    vector&lt;int&gt; mul(num1.size() + num2.size());    for (int i &#x3D; num1.size() - 1; i &gt;&#x3D; 0; i--) &#123;        for (int j &#x3D; num2.size() - 1; j &gt;&#x3D; 0; j--) &#123;            int idx &#x3D; num1.size() + num2.size() - i - j - 2;            mul[idx] +&#x3D; (num1[i] - &#39;0&#39;) * (num2[j] - &#39;0&#39;);            if (mul[idx] &gt; 9) &#123;                mul[idx + 1] +&#x3D; mul[idx] &#x2F; 10;                mul[idx] %&#x3D; 10;            &#125;        &#125;    &#125;    while (!mul.empty() &amp;&amp; mul.back() &#x3D;&#x3D; 0) mul.pop_back();    if (mul.empty()) return &quot;0&quot;;        string res;    for (int i &#x3D; mul.size() - 1; i &gt;&#x3D; 0; i--) &#123;        res.push_back(mul[i] + &#39;0&#39;);    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python符号方程</title>
      <link href="2021/09/28/Python-Python%E7%AC%A6%E5%8F%B7%E6%96%B9%E7%A8%8B/"/>
      <url>2021/09/28/Python-Python%E7%AC%A6%E5%8F%B7%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="sympy求解符号方程"><a href="#sympy求解符号方程" class="headerlink" title="sympy求解符号方程"></a>sympy求解符号方程</h2><p><code>sympy.solve()</code>求解方程<br><code>evalf</code>代入数值</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import sympysympy.init_printing()a, b, c, x &#x3D; sympy.symbols(&#39;a, b, c, x&#39;)func &#x3D; a * x * x + b * x + cprint(&#39;符号解:&#39;, sympy.solve(func, x))print(&#39;数值解:&#39;, sympy.solve(func.evalf(subs&#x3D;&#123;a: 1, b: -3, c: 2&#125;), x))符号解: [(-b + sqrt(-4*a*c + b**2))&#x2F;(2*a), -(b + sqrt(-4*a*c + b**2))&#x2F;(2*a)]数值解: [1.00000000000000, 2.00000000000000]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以这样写</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">a, b, c, x &#x3D; sympy.symbols(&#39;a, b, c, x&#39;)func &#x3D; a * x * x + b * x + cres &#x3D; sympy.solve(func, x)print(res)print(res[0].subs([(a, 1), (b, -3), (c, 2)]))print(res[1].subs([(a, 1), (b, -3), (c, 2)]))符号解: [(-b + sqrt(-4*a*c + b**2))&#x2F;(2*a), -(b + sqrt(-4*a*c + b**2))&#x2F;(2*a)]21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>73-矩阵置零</title>
      <link href="2021/09/27/LeetCode-73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
      <url>2021/09/27/LeetCode-73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-73-Set-Matrix-Zeroes"><a href="#LeetCode-73-Set-Matrix-Zeroes" class="headerlink" title="LeetCode 73. Set Matrix Zeroes"></a>LeetCode 73. Set Matrix Zeroes</h2><p>Given an <code>m x n</code> integer matrix matrix, if an element is <code>0</code>, set its entire <code>row</code> and <code>column</code> to <code>0&#39;s</code>, and return the matrix.</p><p>You must do it <strong>in place</strong>.</p><p>Example 1:<br><img src="/2021/09/27/LeetCode-73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/73_0.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: matrix &#x3D; [[1,1,1],[1,0,1],[1,1,1]]Output: [[1,0,1],[0,0,0],[1,0,1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><img src="/2021/09/27/LeetCode-73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/73_1.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: matrix &#x3D; [[0,1,2,0],[3,4,5,2],[1,3,1,5]]Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>如果<code>matrix[i][j]</code>为零，就把<code>matrix[i][0]</code>和<code>matrix[0][j]</code>置零，后面再遍历的时候就看<code>matrix[i][0]</code>和<code>matrix[0][j]</code>决定是否将元素置零</p><p>但是<code>matrix[0][0]</code>会出现混淆，无法确定是第<code>0</code>行还是第<code>0</code>列导致的置零，所以用两个变量来特判</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;    int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();    bool row0 &#x3D; false, col0 &#x3D; false;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        if (matrix[i][0] &#x3D;&#x3D; 0) &#123;            col0 &#x3D; true;            break;        &#125;    &#125;    for (int j &#x3D; 0; j &lt; m; j++) &#123;        if (matrix[0][j] &#x3D;&#x3D; 0) &#123;            row0 &#x3D; true;            break;        &#125;    &#125;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        for (int j &#x3D; 0; j &lt; m; j++) &#123;            if (matrix[i][j] &#x3D;&#x3D; 0) &#123;                matrix[i][0] &#x3D; 0;                matrix[0][j] &#x3D; 0;            &#125;        &#125;    &#125;    for (int i &#x3D; 1; i &lt; n; i++) &#123;        for (int j &#x3D; 1; j &lt; m; j++) &#123;            if (matrix[i][0] &#x3D;&#x3D; 0 || matrix[0][j] &#x3D;&#x3D; 0)                matrix[i][j] &#x3D; 0;        &#125;    &#125;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        if (col0) matrix[i][0] &#x3D; 0;    &#125;    for (int j &#x3D; 0; j &lt; m; j++) &#123;        if (row0) matrix[0][j] &#x3D; 0;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>147-链表插入排序</title>
      <link href="2021/09/25/LeetCode-147-%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>2021/09/25/LeetCode-147-%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-147-Insertion-Sort-List"><a href="#LeetCode-147-Insertion-Sort-List" class="headerlink" title="LeetCode 147. Insertion Sort List"></a>LeetCode 147. Insertion Sort List</h2><p>Given the <code>head</code> of a singly linked list, <code>sort</code> the list using <code>insertion sort</code>, and return the sorted list’s head.</p><p><img src="/2021/09/25/LeetCode-147-%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/147.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [4,2,1,3]Output: [1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method:"></a>method:</h2><p><code>head</code>指向要插入的元素，<code>pre</code>遍历已排序的链表，找到第一个大于<code>head-&gt;val</code>的元素或者最末尾的元素，插入<code>head</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* insertionSortList(ListNode* head) &#123;    ListNode *dummy &#x3D; new ListNode(0);    ListNode *pre &#x3D; dummy;    while (head) &#123;        ListNode *tmp &#x3D; head-&gt;next;        while (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;val &lt; head-&gt;val)             pre &#x3D; pre-&gt;next;        head-&gt;next &#x3D; pre-&gt;next;        pre-&gt;next &#x3D; head;        head &#x3D; tmp;        pre &#x3D; dummy;    &#125;    return dummy-&gt;next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>416-分割等和子集</title>
      <link href="2021/09/25/LeetCode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
      <url>2021/09/25/LeetCode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-416-Partition-Equal-Subset-Sum"><a href="#LeetCode-416-Partition-Equal-Subset-Sum" class="headerlink" title="LeetCode 416. Partition Equal Subset Sum"></a>LeetCode 416. Partition Equal Subset Sum</h2><p>Given a non-empty array <code>nums</code> containing only <code>positive</code> integers, find if the array can be partitioned into <code>two subsets</code> such that the sum of elements in both subsets is <code>equal</code>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [1,5,11,5]Output: trueExplanation: The array can be partitioned as [1, 5, 5] and [11].<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-01背包"><a href="#method-01背包" class="headerlink" title="method: 01背包"></a>method: 01背包</h2><p>背包重量为数组和的一半，看最后是否能刚好放满</p><p>每个元素都是一件物品，重量和价值相等</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool canPartition(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;int&gt; dp(10010, 0);    int sum &#x3D; 0;    for (int i &#x3D; 0; i &lt; nums.size(); i++)        sum +&#x3D; nums[i];    if (sum % 2) return false;    sum &#x2F;&#x3D; 2;    for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;        for (int j &#x3D; sum; j &gt;&#x3D; nums[i]; j--) &#123;            dp[j] &#x3D; max(dp[j], dp[j - nums[i]] + nums[i]);        &#125;    &#125;    return dp[sum] &#x3D;&#x3D; sum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>223-矩形面积</title>
      <link href="2021/09/25/LeetCode-223-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/"/>
      <url>2021/09/25/LeetCode-223-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-223-Rectangle-Area"><a href="#LeetCode-223-Rectangle-Area" class="headerlink" title="LeetCode 223. Rectangle Area"></a>LeetCode 223. Rectangle Area</h2><p>Given the coordinates of two rectilinear rectangles in a 2D plane, return the total area covered by the two rectangles.</p><p>The first rectangle is defined by its bottom-left corner <code>(ax1, ay1)</code> and its top-right corner <code>(ax2, ay2)</code>.</p><p>The second rectangle is defined by its bottom-left corner <code>(bx1, by1)</code> and its top-right corner <code>(bx2, by2)</code>.</p><p>Example 1:</p><p><img src="/2021/09/25/LeetCode-223-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/223.png" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Rectangle AreaInput: ax1 &#x3D; -3, ay1 &#x3D; 0, ax2 &#x3D; 3, ay2 &#x3D; 4, bx1 &#x3D; 0, by1 &#x3D; -1, bx2 &#x3D; 9, by2 &#x3D; 2Output: 45<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>要计算出重叠部分的面积，再用总面积减去重叠面积</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) &#123;    int area &#x3D; (ax2-ax1) * (ay2-ay1) + (bx2-bx1) * (by2-by1);    int dx &#x3D; min(ax2, bx2) - max(ax1, bx1);    if (dx &lt; 0) return area;    &#x2F;&#x2F; x方向没有重叠    int dy &#x3D; min(ay2, by2) - max(ay1, by1);    if (dy &lt; 0) return area;    &#x2F;&#x2F; y方向没有重叠    return area - dx * dy;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基本操作</title>
      <link href="2021/09/24/Linux-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>2021/09/24/Linux-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">-d  --delete：删除-D  --delete --force的快捷键-f  --force：强制-m  --move：移动或重命名-M  --move --force的快捷键-r  --remote：远程-a  --all：所有<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改并提交"><a href="#修改并提交" class="headerlink" title="修改并提交"></a>修改并提交</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">git add .git commit -m &quot;***&quot;git push origin main -u<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><h4 id="添加子模块"><a href="#添加子模块" class="headerlink" title="添加子模块"></a>添加子模块</h4><p>如果添加子项目，需要先执行<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">git submodule add 链接 放在哪个目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>再提交</p><p><code>clone</code>的时候不会<code>clone</code>子项目，需要进入项目后执行<br><pre class="line-numbers language-none"><code class="language-none">git submodule update --init --recursive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>才会把子项目<code>clone</code>下来</p><h4 id="删除子模块"><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm -rf 子模块目录 # 删除子模块目录及源码vi .gitmodules  # 删除.gitmodules文件中子模块相关条目vi .git&#x2F;config  # 删除配置项中子模块相关条目rm .git&#x2F;module&#x2F;*  # 删除模块下的子模块目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>删除后提交</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>查看本地所有分支</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ git branch* main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看远程所有分支<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ git branch -r  origin&#x2F;HEAD -&gt; origin&#x2F;main  origin&#x2F;main  origin&#x2F;master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><p>查看本地和远程所有分支<br>当前本地分支前带有<code>*</code>号且为绿色，远程分支为红色<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ git branch -a* main  remotes&#x2F;origin&#x2F;HEAD -&gt; origin&#x2F;main  remotes&#x2F;origin&#x2F;main  remotes&#x2F;origin&#x2F;master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><center><img src="/2021/09/24/Linux-git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/111.png#pic_center" width="40%" height="40%"></center><p>分支不存在则新建本地分支，存在则切换本地分支<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">git branch &lt;branch-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>删除本地分支<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">git branch -d &lt;branch-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>删除远程分支<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">git branch -d -r &lt;branch-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>删除后，还要推送到服务器上才行，即<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">git push origin :&lt;branch-name&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>148-排序链表</title>
      <link href="2021/09/24/LeetCode-148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>2021/09/24/LeetCode-148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-148-Sort-List"><a href="#LeetCode-148-Sort-List" class="headerlink" title="LeetCode 148. Sort List"></a>LeetCode 148. Sort List</h2><p>Given the head of a linked list, return the list after <strong>sorting it in ascending order</strong>.</p><p>Example 1:<br><img src="/2021/09/24/LeetCode-148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/148.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [4,2,1,3]Output: [1,2,3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="归并排序模板"><a href="#归并排序模板" class="headerlink" title="归并排序模板"></a>归并排序模板</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void merge(vector&lt;int&gt;&amp; nums, int l, int mid, int r) &#123;    vector&lt;int&gt; res(r - l + 1); &#x2F;&#x2F; 和区间大小相同的数组    int cnt &#x3D; 0;    int p1 &#x3D; l, p2 &#x3D; mid + 1;   &#x2F;&#x2F; 左半区间和右半区间的指针    while (p1 &lt;&#x3D; mid &amp;&amp; p2 &lt;&#x3D; r) &#123;        if (nums[p1] &lt; nums[p2])    &#x2F;&#x2F; 取较小值填充            res[cnt++] &#x3D; nums[p1++];        else            res[cnt++] &#x3D; nums[p2++];    &#125;    while (p1 &lt;&#x3D; mid) res[cnt++] &#x3D; nums[p1++];  &#x2F;&#x2F; 如果还有    while (p2 &lt;&#x3D; l) res[cnt++] &#x3D; nums[p2++];    for (uint32_t i &#x3D; 0; i &lt; res.size(); i++) &#123;        nums[i + l] &#x3D; res[i];   &#x2F;&#x2F; 还原回去    &#125;&#125;void mergeSort(vector&lt;int&gt;&amp; nums, int l, int r) &#123;    if (left &gt;&#x3D; right) return;      &#x2F;&#x2F; 递归结束条件，区间至少1个元素    int mid &#x3D; (l + r) &#x2F; 2;    mergeSort(nums, l, mid);        &#x2F;&#x2F; 递归左半区间    mergeSort(nums, mid + 1, r);    &#x2F;&#x2F; 递归右半区间    merge(nums, l, mid, r);&#125;int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; nums &#x3D; &#123;4, 1, 3, 2, 5&#125;;    mergeSort(nums, 0, nums.size() - 1);    for (auto n : nums) &#123;        cout &lt;&lt; n &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;1 2 3 4 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-归并排序"><a href="#method-归并排序" class="headerlink" title="method: 归并排序"></a>method: 归并排序</h2><p>把链表从中间位置断开，就像归并排序的<code>mid</code>一样</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* merge(ListNode* l1, ListNode* l2) &#123;    ListNode *dummy &#x3D; new ListNode(0);    ListNode *head &#x3D; dummy;    while (l1 &amp;&amp; l2) &#123;        if (l1-&gt;val &lt; l2-&gt;val) &#123;            head-&gt;next &#x3D; l1;            l1 &#x3D; l1-&gt;next;        &#125;        else &#123;            head-&gt;next &#x3D; l2;            l2 &#x3D; l2-&gt;next;        &#125;        head &#x3D; head-&gt;next;    &#125;    if (l1) head-&gt;next &#x3D; l1;    if (l2) head-&gt;next &#x3D; l2;    return dummy-&gt;next;&#125;ListNode* sortList(ListNode* head) &#123;    if (!head || !head-&gt;next) return head;    ListNode *fast &#x3D; head;    ListNode *slow &#x3D; head;    ListNode *pre &#x3D; nullptr;    while (fast &amp;&amp; fast-&gt;next) &#123;        pre &#x3D; slow;        slow &#x3D; slow-&gt;next;        fast &#x3D; fast-&gt;next-&gt;next;    &#125;    pre-&gt;next &#x3D; nullptr;    &#x2F;&#x2F; 把链表从中间断开    ListNode *l1 &#x3D; sortList(head);    ListNode *l2 &#x3D; sortList(slow);    return merge(l1, l2);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相关报道</title>
      <link href="2021/09/24/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%81%93/"/>
      <url>2021/09/24/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E7%9B%B8%E5%85%B3%E6%8A%A5%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h2 id="外卖无人机"><a href="#外卖无人机" class="headerlink" title="外卖无人机"></a>外卖无人机</h2><p><a href="https://www.cnki.com.cn/Article/CJFDTotal-MHGL201806006.htm">中国首批无人机送餐航线获批准</a></p><p>无人机送餐、送生鲜好处很多，既降低了送餐成本和风险，又能在天气恶劣或地形复杂的送餐条件下尽快把外卖送到消费者手中。中国电子商务协会行业专家张健表示，从提高效率、增强体验度来说，无人机即时送餐业务符合新零售的特征。<br>苏宁金融研究院新产业研究中心评论称，首批无人机航线启用，标志着“未来物流”战略的落地迈出重要一步，即时配送行业加快从劳动密集型向技术密集型进化。</p><p><a href="https://baijiahao.baidu.com/s?id=1601792193483090627&amp;wfr=spider&amp;for=pc">饿了么获批中国首条外卖无人机配送航线，外卖平均 20 分钟送达</a></p><p>2018 年 5 月 29 日，饿了么在上海宣布获准开辟中国第一批无人机及时配送航线，将送餐无人机正式投入商业运营。<br>饿了么本次获准飞行的无人机航线共有 17 条，均在上海金山工业园区内，这些航线的平均路程为 2.2 公里，每条航线每天飞行 3-4 个架次，覆盖的配送面积为 58 平方公里，可以服务 100 多家外卖商家。</p><h2 id="物流无人机"><a href="#物流无人机" class="headerlink" title="物流无人机"></a>物流无人机</h2><p><a href="https://baike.baidu.com/tashuo/browse/content?id=82c735fad8ce6f2a5af719fd&amp;lemmaId=193664&amp;fromLemmaModule=pcBottom&amp;lemmaTitle=DHL">DHL 和亿航展开合作，在中国推出无人机送货服务</a></p><p>现在用无人机或无人车来送货，已经成了一件很普通的事。根据 Geek.com 的报道，DHL 早在 5 月 19 日就和亿航确定合作协议，并获得了无人机配送航线的批准。接下来，DHL 将会用亿航专供的无人机 Falcon 来完成配送任务。</p>]]></content>
      
      
      <categories>
          
          <category> 多旋翼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>129-根到叶子节点的和</title>
      <link href="2021/09/24/LeetCode-129-%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C/"/>
      <url>2021/09/24/LeetCode-129-%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-129-Sum-Root-to-Leaf-Numbers"><a href="#LeetCode-129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="LeetCode 129. Sum Root to Leaf Numbers"></a>LeetCode 129. Sum Root to Leaf Numbers</h2><p>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p><p>Each root-to-leaf path in the tree represents a number.</p><p>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.<br>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a 32-bit integer.</p><p>A leaf node is a node with no children.</p><p>Example 1:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [1,2,3]Output: 25Explanation:The root-to-leaf path 1-&gt;2 represents the number 12.The root-to-leaf path 1-&gt;3 represents the number 13.Therefore, sum &#x3D; 12 + 13 &#x3D; 25.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-回溯"><a href="#method-回溯" class="headerlink" title="method: 回溯"></a>method: 回溯</h2><p>每条根到叶子节点的路径都可以组成一个数字，求这些数字的和</p><p>简单的回溯，可以先加上节点的值，再往这个节点递归</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int res &#x3D; 0;int sum &#x3D; 0;void traversal(TreeNode* root) &#123;    if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;        res +&#x3D; sum;        return;    &#125;    if (root-&gt;left) &#123;        sum &#x3D; sum * 10 + root-&gt;left-&gt;val;        traversal(root-&gt;left);        sum &#x2F;&#x3D; 10;    &#125;    if (root-&gt;right) &#123;        sum &#x3D; sum * 10 + root-&gt;right-&gt;val;        traversal(root-&gt;right);        sum &#x2F;&#x3D; 10;    &#125;&#125;int sumNumbers(TreeNode* root) &#123;    sum &#x3D; root-&gt;val;    &#x2F;&#x2F; 先取值    traversal(root);    &#x2F;&#x2F; 再递归    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以先往这个节点递归，再加上这个节点的值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int res &#x3D; 0;int sum &#x3D; 0;void traversal(TreeNode* root) &#123;    sum &#x3D; sum * 10 + root-&gt;val;     &#x2F;&#x2F; 再取值    if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;        res +&#x3D; sum;        return;    &#125;    if (root-&gt;left) &#123;        traversal(root-&gt;left);        sum &#x2F;&#x3D; 10;    &#125;    if (root-&gt;right) &#123;        traversal(root-&gt;right);        sum &#x2F;&#x3D; 10;    &#125;&#125;int sumNumbers(TreeNode* root) &#123;    traversal(root);    &#x2F;&#x2F; 先递归    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>84-柱形图中最大矩形</title>
      <link href="2021/09/24/LeetCode-84-%E6%9F%B1%E5%BD%A2%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
      <url>2021/09/24/LeetCode-84-%E6%9F%B1%E5%BD%A2%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-84-Largest-Rectangle-in-Histogram"><a href="#LeetCode-84-Largest-Rectangle-in-Histogram" class="headerlink" title="LeetCode 84. Largest Rectangle in Histogram"></a>LeetCode 84. Largest Rectangle in Histogram</h2><p>Given an array of integers <code>heights</code> representing the histogram’s bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.</p><p>Example 1:<br><img src="/2021/09/24/LeetCode-84-%E6%9F%B1%E5%BD%A2%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/84.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: heights &#x3D; [2,1,5,6,2,3]Output: 10Explanation: The above is a histogram where width of each bar is 1.The largest rectangle is shown in the red area, which has an area &#x3D; 10 units.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-单调栈"><a href="#method-单调栈" class="headerlink" title="method: 单调栈"></a>method: 单调栈</h2><p>计算区间中元素个数</p><ul><li>左闭右闭<code>[i, j]: i-j+1</code></li><li>左闭右开<code>[i, j): j-i</code></li><li>左开右开<code>(i, j): j-i-1</code></li></ul><p>维护一个从栈底到栈顶单调递增的栈，如果新来的元素比栈顶元素大就入栈，小就栈顶元素出栈。<br>计算面积的逻辑，高度就是栈顶元素的高度，宽度的确定：</p><ul><li>如果栈是空的，说明从下标0开始的所有元素都比栈顶元素大，而新来的元素的高度比他小，所以他能到达的宽度区间就是<code>[0, i)</code>，即为<code>i</code></li><li>如果栈非空，那么栈顶元素肯定比他小，并且新来的元素也比他小，所以他能到达的宽度区间是<code>(st.top, i)</code>，即为<code>i-st.top-1</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123;    stack&lt;int&gt; st;    int res &#x3D; 0;    heights.push_back(0);    for (int i &#x3D; 0; i &lt; heights.size(); i++) &#123;        while (!st.empty() &amp;&amp; heights[i] &lt; heights[st.top()]) &#123;            int topIdx &#x3D; st.top();            st.pop();            int h &#x3D; heights[topIdx];            int w &#x3D; st.empty() ? i : i - st.top() - 1;            res &#x3D; max(res, h * w);        &#125;        st.push(i);    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13-罗马数字转整数</title>
      <link href="2021/09/23/LeetCode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
      <url>2021/09/23/LeetCode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-13-Roman-to-Integer"><a href="#LeetCode-13-Roman-to-Integer" class="headerlink" title="LeetCode 13. Roman to Integer"></a>LeetCode 13. Roman to Integer</h2><p>Roman numerals are represented by seven different symbols: <code>I, V, X, L, C, D and M</code>.<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Symbol       ValueI             1V             5X             10L             50C             100D             500M             1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="mathod"><a href="#mathod" class="headerlink" title="mathod"></a>mathod</h2><p>当前数字比他后面的数字小，就减去当前的数字，比后面数字大，就加上当前数字</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int romanToInt(string s) &#123;    unordered_map&lt;char, int&gt; hash;    hash[&#39;I&#39;] &#x3D; 1;    hash[&#39;V&#39;] &#x3D; 5;    hash[&#39;X&#39;] &#x3D; 10;    hash[&#39;L&#39;] &#x3D; 50;    hash[&#39;C&#39;] &#x3D; 100;    hash[&#39;D&#39;] &#x3D; 500;    hash[&#39;M&#39;] &#x3D; 1000;    int res &#x3D; 0;    for (int i &#x3D; 0; i &lt; s.size() - 1; i++) &#123;        if (hash[s[i]] &lt; hash[s[i + 1]]) res -&#x3D; hash[s[i]];        else res +&#x3D; hash[s[i]];    &#125;    res +&#x3D; hash[s.back()];    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>23-合并k个升序链表</title>
      <link href="2021/09/23/LeetCode-23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>2021/09/23/LeetCode-23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-23-Merge-k-Sorted-Lists"><a href="#LeetCode-23-Merge-k-Sorted-Lists" class="headerlink" title="LeetCode 23. Merge k Sorted Lists"></a>LeetCode 23. Merge k Sorted Lists</h2><p>You are given an array of <code>k</code> linked-lists lists, each linked-list is sorted in <code>ascending</code> order.</p><p>Merge all the linked-lists into one sorted linked-list and return it.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: lists &#x3D; [[1,4,5],[1,3,4],[2,6]]Output: [1,1,2,3,4,4,5,6]Explanation: The linked-lists are:[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]merging them into one sorted list:1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-小根堆"><a href="#method-小根堆" class="headerlink" title="method: 小根堆"></a>method: 小根堆</h2><p>把链表的值和序号放进小根堆排序，会按照值的大小从小到大排序，然后通过序号找到是哪条链表的，如果他还有值，就继续插入堆中</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;    ListNode *dummy &#x3D; new ListNode(0);    ListNode *head &#x3D; dummy;    priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, greater&lt;pair&lt;int,int&gt;&gt;&gt; q;    for (int i &#x3D; 0; i &lt; lists.size(); i++) &#123;   &#x2F;&#x2F; 先把每条链的头结点放进来        if (lists[i]) q.push(pair(lists[i]-&gt;val, i));    &#125;    while (!q.empty()) &#123;        int index &#x3D; q.top().second;        q.pop();        head-&gt;next &#x3D; lists[index];        head &#x3D; head-&gt;next;        lists[index] &#x3D; lists[index]-&gt;next;        if (lists[index]) q.push(pair(lists[index]-&gt;val, index));        &#x2F;&#x2F; 如果还有就继续放入    &#125;    return dummy-&gt;next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表总结</title>
      <link href="2021/09/23/LeetCode-%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/"/>
      <url>2021/09/23/LeetCode-%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><p>用数组获得链表，用尾插法，迭代正向输出，递归反向输出</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct ListNode &#123;    int val;    ListNode *next;    ListNode() : val(0), next(nullptr) &#123;&#125;    ListNode(int x) : val(x), next(nullptr) &#123;&#125;    ListNode(int x, ListNode *ne) : val(x), next(ne) &#123;&#125;&#125;;void dispListNode(ListNode *head) &#123;    while (head) &#123;        cout &lt;&lt; head-&gt;val &lt;&lt; &quot; &quot;;        head &#x3D; head-&gt;next;    &#125;&#125;void revDispListNode(ListNode *head) &#123;    if (!head) return;    revDispListNode(head-&gt;next);    cout &lt;&lt; head-&gt;val &lt;&lt; &quot; &quot;;&#125;ListNode* getListNode(vector&lt;int&gt;&amp; nums) &#123;    ListNode *head &#x3D; new ListNode(-1);    ListNode *dummy &#x3D; head;    for (auto&amp; n : nums) &#123;        ListNode *node &#x3D; new ListNode(n);        head-&gt;next &#x3D; node;        head &#x3D; head-&gt;next;    &#125;    return dummy-&gt;next;&#125;int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; nums &#x3D; &#123;1, 2, 3, 4&#125;;    ListNode *head &#x3D; getListNode(nums);    dispListNode(head);    cout &lt;&lt; endl;    revDispListNode(head);    cout &lt;&lt; endl;    return 0;&#125;1 2 3 44 3 2 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组总结</title>
      <link href="2021/09/23/LeetCode-%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/"/>
      <url>2021/09/23/LeetCode-%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>基础的，统计连续出现的1</p><p><a href="https://kavinwkp.github.io/2021/06/17/LeetCode-485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/">485-最大连续1的个数</a><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;    int cnt &#x3D; 0, res &#x3D; 0;    for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;        cnt &#x3D; nums[i] ? cnt + 1 : 0;        res &#x3D; max(res, cnt);    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>相同的0和1，尽管是字符串，但思想还是一样的<br><a href="https://kavinwkp.github.io/2021/06/17/LeetCode-485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/">485-最大连续1的个数</a><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int countBinarySubstrings(string s) &#123;    int pre &#x3D; 0, cur &#x3D; 1;    int count &#x3D; 0;    for (int i &#x3D; 1; i &lt; s.size(); ++i) &#123;        if (s[i] &#x3D;&#x3D; s[i - 1]) &#123;            cur++;   &#x2F;&#x2F; 记录相同的0或1        &#125;        else &#123;            pre &#x3D; cur;            cur &#x3D; 1; &#x2F;&#x2F; 出现不同就置1        &#125;        if (pre &gt;&#x3D; cur) count++;    &#x2F;&#x2F; pre大于cur说明可以匹配    &#125;    return count;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>统计数组中出现次数最多的数字</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int findMaxFreq(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;int&gt; nums &#x3D; &#123;1, 1, 2, 2, 3, 3, 3&#125;;    int res &#x3D; 0;    int cnt &#x3D; 1;    for (uint32_t i &#x3D; 1; i &lt; nums.size(); i++) &#123;        if (nums[i] &#x3D;&#x3D; nums[i - 1]) cnt++;        else cnt &#x3D; 1;        res &#x3D; max(res, cnt);    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>统计第k大的元素</p><p><a href="https://kavinwkp.github.io/2021/05/29/LeetCode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/">215-数组中的第k个最大元素</a></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;    for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;        q.push(nums[i]);        if (q.size() &gt; k) q.pop();  &#x2F;&#x2F; 超过k个要把最小的出队    &#125;    return q.top();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>统计出现频率最高的k个元素</p><ul><li>需要统计所有数字的出现次数，用哈希表</li><li>凡是需要最高或最低的k个元素或第k个元素，都要用到优先队列</li></ul><p><a href="https://kavinwkp.github.io/2021/09/22/LeetCode-347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/">347-前k个高频元素</a><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class cmp &#123;public:    bool operator()(const pair&lt;int,int&gt;&amp; lhs, const pair&lt;int,int&gt;&amp; rhs) &#123;        return lhs.second &gt; rhs.second; &#x2F;&#x2F; 跟sort不一样，反过来了    &#125;&#125;;vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;    unordered_map&lt;int, int&gt; hash;    for (auto n : nums) hash[n]++;    priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, cmp&gt; q;    for (auto it &#x3D; hash.begin(); it !&#x3D; hash.end(); it++) &#123;        q.push(*it);        if (q.size() &gt; k) q.pop();  &#x2F;&#x2F; 大于k个要把最小的出队    &#125;     vector&lt;int&gt; res(k);    for (int i &#x3D; k - 1; i &gt;&#x3D; 0; i--) &#123;        res[i] &#x3D; q.top().first;        q.pop();    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>移除某个特定元素</p><p><a href="https://kavinwkp.github.io/2021/05/27/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/">27-移除元素</a></p><p>同向双指针<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;    int l &#x3D; 0, r &#x3D; 0;    while (r &lt; nums.size()) &#123;        if (nums[r] !&#x3D; val) &#123;            nums[l] &#x3D; nums[r];            l++;        &#125;        r++;    &#125;    return l;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>反向双指针<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;    if (nums.empty()) return 0;    int l &#x3D; 0, r &#x3D; nums.size() - 1;    while (l &lt; r) &#123;        while (l &lt; r &amp;&amp; nums[l] !&#x3D; val) l++;        while (l &lt; r &amp;&amp; nums[r] &#x3D;&#x3D; val) r--;        swap(nums, l, r);    &#125;    return (nums[l] &#x3D;&#x3D; val ? l : l + 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>保留N个重复项</p><p><a href="https://kavinwkp.github.io/2021/04/27/LeetCode-26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/">26/80-删除有序数组中的重复项</a></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;    if (nums.size() &lt; N) return nums.size();    int fast &#x3D; N, slow &#x3D; N;    while (fast &lt; nums.size()) &#123;        if (nums[fast] !&#x3D; nums[slow - N]) &#123;            nums[slow] &#x3D; nums[fast];            slow++;            fast++;        &#125;        else fast++;    &#125;    return slow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="奇怪的遍历方式"><a href="#奇怪的遍历方式" class="headerlink" title="奇怪的遍历方式"></a>奇怪的遍历方式</h2><p>螺旋遍历二维数组，注意区间都要一样左开右闭</p><p><a href="https://kavinwkp.github.io/2021/06/05/LeetCode-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/">54-螺旋矩阵</a></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;    int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();    vector&lt;int&gt; res(n * m, 0);    int n1 &#x3D; n, m1 &#x3D; m;    int offset &#x3D; 1;    int startx &#x3D; 0, starty &#x3D; 0;    int cnt &#x3D; 0;    int i &#x3D; 0, j &#x3D; 0;    while (n1 &gt; 1 &amp;&amp; m1 &gt; 1) &#123;        i &#x3D; startx, j &#x3D; starty;        for (; j &lt; starty + m - offset; j++) res[cnt++] &#x3D; matrix[i][j];        for (; i &lt; startx + n - offset; i++) res[cnt++] &#x3D; matrix[i][j];        for (; j &gt; starty; j--) res[cnt++] &#x3D; matrix[i][j];  &#x2F;&#x2F; 大于起始位置        for (; i &gt; startx; i--) res[cnt++] &#x3D; matrix[i][j];        n1 -&#x3D; 2;        m1 -&#x3D; 2;        offset +&#x3D; 2;        startx++;        starty++;    &#125;    i &#x3D; startx, j &#x3D; starty;    if (n1 &#x3D;&#x3D; 1 &amp;&amp; m1 &#x3D;&#x3D; 1) res[cnt++] &#x3D; matrix[i][j];  &#x2F;&#x2F; 剩一个    else if (n1 &#x3D;&#x3D; 1 &amp;&amp; m1 &gt; 1) &#123;   &#x2F;&#x2F; 剩一行        for (; j &lt; starty + m1; j++) res[cnt++] &#x3D; matrix[i][j];    &#125;    else if (n1 &gt; 1 &amp;&amp; m1 &#x3D;&#x3D; 1) &#123;   &#x2F;&#x2F; 剩一列        for (; i &lt; startx + n1; i++) res[cnt++] &#x3D; matrix[i][j];    &#125;    else return res;    &#x2F;&#x2F; 没剩下，直接返回    return res;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>347-前k个高频元素</title>
      <link href="2021/09/22/LeetCode-347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
      <url>2021/09/22/LeetCode-347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-347-Top-K-Frequent-Elements"><a href="#LeetCode-347-Top-K-Frequent-Elements" class="headerlink" title="LeetCode 347. Top K Frequent Elements"></a>LeetCode 347. Top K Frequent Elements</h2><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return the <code>k most frequent elements</code>. You may return the answer in any order.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2Output: [1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-小根堆"><a href="#method-小根堆" class="headerlink" title="method: 小根堆"></a>method: 小根堆</h2><p>哈希表存储每个数字出现次数<br>用<code>pair&lt;int,int&gt;</code>存储数值和出现的频率，所以要自定义优先队列的排序方式</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class cmp &#123;public:    bool operator()(const pair&lt;int,int&gt;&amp; lhs, const pair&lt;int,int&gt;&amp; rhs) &#123;        return lhs.second &gt; rhs.second; &#x2F;&#x2F; 跟sort不一样，反过来了    &#125;&#125;;vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;    unordered_map&lt;int, int&gt; hash;    for (auto n : nums) hash[n]++;    priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, cmp&gt; q;    for (auto it &#x3D; hash.begin(); it !&#x3D; hash.end(); it++) &#123;        q.push(*it);        if (q.size() &gt; k) q.pop();  &#x2F;&#x2F; 大于k个要把最小的出队    &#125;     vector&lt;int&gt; res(k);    for (int i &#x3D; k - 1; i &gt;&#x3D; 0; i--) &#123;        res[i] &#x3D; q.top().first;        q.pop();    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k个为一组反转链表</title>
      <link href="2021/09/22/LeetCode-25-k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>2021/09/22/LeetCode-25-k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-25-Reverse-Nodes-in-k-Group"><a href="#LeetCode-25-Reverse-Nodes-in-k-Group" class="headerlink" title="LeetCode 25. Reverse Nodes in k-Group"></a>LeetCode 25. Reverse Nodes in k-Group</h2><p>Given a linked list, reverse the nodes of a linked list <code>k</code> at a time and return its modified list.</p><p><code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.</p><p>You may not alter the values in the list’s nodes, only nodes themselves may be changed.</p><p>Example 1:<br><img src="/2021/09/22/LeetCode-25-k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/25.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [1,2,3,4,5], k &#x3D; 2Output: [2,1,4,3,5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-模拟"><a href="#method-模拟" class="headerlink" title="method: 模拟"></a>method: 模拟</h2><p><code>[head+1,tail]</code>组成要反转的区间，反转跟之前迭代一样，只是改一下退出循环条件</p><p>反转完的处理<br><img src="/2021/09/22/LeetCode-25-k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/25_2.png" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* reverseKGroup(ListNode* head, int k) &#123;    ListNode *dummy &#x3D; new ListNode(0, head);    head &#x3D; dummy;    while (head) &#123;        ListNode *tail &#x3D; head;        for (int i &#x3D; 0; i &lt; k &amp;&amp; tail; i++) tail &#x3D; tail-&gt;next;  &#x2F;&#x2F; 移动到这组末尾        if (!tail) return dummy-&gt;next;  &#x2F;&#x2F; 最后一组不够k个        ListNode *pre &#x3D; head-&gt;next;        ListNode *cur &#x3D; head-&gt;next-&gt;next;        while (pre !&#x3D; tail) &#123;            ListNode *tmp &#x3D; cur-&gt;next;            cur-&gt;next &#x3D; pre;            pre &#x3D; cur;            cur &#x3D; tmp;        &#125;        head-&gt;next-&gt;next &#x3D; cur; &#x2F;&#x2F; 1        head-&gt;next &#x3D; tail;      &#x2F;&#x2F; 2        for (int i &#x3D; 0; i &lt; k; i++) head &#x3D; head-&gt;next;  &#x2F;&#x2F; 3移动到下一个要反转的位置    &#125;    return dummy-&gt;next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多旋翼动力学</title>
      <link href="2021/09/21/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC%E5%8A%A8%E5%8A%9B%E5%AD%A6/"/>
      <url>2021/09/21/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC%E5%8A%A8%E5%8A%9B%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="多旋翼动量定理"><a href="#多旋翼动量定理" class="headerlink" title="多旋翼动量定理"></a>多旋翼动量定理</h2><h3 id="惯性系"><a href="#惯性系" class="headerlink" title="惯性系"></a>惯性系</h3><script type="math/tex; mode=display">m\dot{v} = mg + R \sum_{k=1}^{4}{F_k}</script><p>因为$F_k$是体轴系下多旋翼的升力，所以要左乘旋转矩阵转换到地理坐标系下<br>同时，因为$F_k$都是垂直于机体平面，沿体轴$z_b$方向，所以旋转矩阵只需要最后一列，展开写就是</p><script type="math/tex; mode=display">m\begin{bmatrix}\ddot{x} \\ \ddot{y} \\ \ddot{z}\end{bmatrix} = m\begin{bmatrix}0 \\ 0 \\ g\end{bmatrix} + (f_1+f_2+f_3+f_4)\begin{bmatrix}cos\psi sin\theta cos\phi + sin\psi sin\phi \\sin\psi sin\theta cos\phi - sin\phi cos\psi \\cos\theta cos\phi\end{bmatrix}</script><h3 id="体轴系"><a href="#体轴系" class="headerlink" title="体轴系"></a>体轴系</h3><script type="math/tex; mode=display">m(\dot{v} + \hat{\omega}_b v) = R^\mathrm{T}mg + \sum_{k=1}^{4}{F_k}</script><p>$mg$是地理坐标系下的，左乘旋转矩阵的转置转换到体轴系</p><p>写成矩阵形式，体轴系下角速度为$\omega_b = \begin{bmatrix}p &amp; q &amp; r\end{bmatrix}^\mathrm{T}$</p><script type="math/tex; mode=display">m\begin{bmatrix}\dot{u} \\ \dot{v} \\ \dot{w}\end{bmatrix} + m\begin{bmatrix}qw - rv \\ ru - pw \\pv - qw\end{bmatrix} = mg\begin{bmatrix}-sin\theta \\cos\theta sin\phi \\cos\theta cos\phi\end{bmatrix} - \begin{bmatrix}0 \\ 0 \\ f_1 + f_2 + f_3 + f_4\end{bmatrix}</script><h2 id="多旋翼动量矩定理"><a href="#多旋翼动量矩定理" class="headerlink" title="多旋翼动量矩定理"></a>多旋翼动量矩定理</h2><h3 id="体轴系-1"><a href="#体轴系-1" class="headerlink" title="体轴系"></a>体轴系</h3><p><img src="/2021/09/21/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC%E5%8A%A8%E5%8A%9B%E5%AD%A6/multirotor.png" alt></p><script type="math/tex; mode=display">I\dot{\omega} + \hat{\omega} I \omega = \sum_{k=1}^{4}{r_k \times F_k} - \hat{\omega} \sum_{k=1}^{4}{I_k\omega_k} - \sum_{k=1}^{4}{\tilde{\tau}_k}</script><p>这里定义$z$轴垂直于机身向下<br>$\hat{\omega} \sum_{k=1}^{4}{I_k\omega_k}$称为陀螺力矩</p><p>$\omega_1 = \begin{bmatrix}0\\0\\ -\Omega_1 \end{bmatrix}\quad\omega_2 = \begin{bmatrix}0\\0\\ -\Omega_2 \end{bmatrix}\quad\omega_3 = \begin{bmatrix}0\\0\\ \Omega_3 \end{bmatrix}\quad\omega_4 = \begin{bmatrix}0\\0\\ \Omega_4 \end{bmatrix}$<br>$I_k$是螺旋桨的转动惯量，因为旋翼角速度垂直于自身，所以只需考虑旋翼$z$轴的转动惯量<br>所以</p><script type="math/tex; mode=display">I_k = \begin{bmatrix}0 & 0 & 0 \\0 & 0 & 0 \\0 & 0 & I_r\end{bmatrix}</script><p>所以</p><script type="math/tex; mode=display">\sum_{k=1}^{4}{I_k\omega_k} = I_r\begin{bmatrix}0 \\ 0 \\ -\Omega_1-\Omega_2+\Omega_3+\Omega_4\end{bmatrix} \\\hat{\omega} \sum_{k=1}^{4}{I_k\omega_k} = I_r\begin{bmatrix}0 & -r & q \\r & 0 & -p \\-q & p & 0 \end{bmatrix}\begin{bmatrix}0 \\ 0 \\ -\Omega_1-\Omega_2+\Omega_3+\Omega_4\end{bmatrix} = \begin{bmatrix}I_r q (-\Omega_1-\Omega_2+\Omega_3+\Omega_4) \\I_r p (\Omega_1+\Omega_2-\Omega_3-\Omega_4) \\0\end{bmatrix}</script><p>$\tilde{\tau}_k$是电机给螺旋桨的扭矩<br>$\tilde{\tau}_1 = \begin{bmatrix}0\\0\\ -\tau_1 \end{bmatrix}\quad\tilde{\tau}_2 = \begin{bmatrix}0\\0\\ -\tau_2 \end{bmatrix}\quad\tilde{\tau}_3 = \begin{bmatrix}0\\0\\ \tau_3 \end{bmatrix}\quad\tilde{\tau}_4 = \begin{bmatrix}0\\0\\ \tau_4 \end{bmatrix}$</p><p>所以机体动量矩定理展开就是</p><script type="math/tex; mode=display">\begin{align*}  & I_x\dot{p} + (I_z-I_y)qr = \frac{\sqrt{2}}{4}l(-f_1+f_2+f_3-f_4) + I_rq(\Omega_1+\Omega_2-\Omega_3-\Omega_4) \\  & I_y\dot{q} + (I_x-I_z)pr = \frac{\sqrt{2}}{4}l(f_1-f_2+f_3-f_4) - I_rp(\Omega_1+\Omega_2-\Omega_3-\Omega_4) \\  & I_z\dot{r} + (I_y-I_x)pq = \tau_1 + \tau_2 - \tau_3 - \tau_4 \\\end{align*}</script>]]></content>
      
      
      <categories>
          
          <category> 多旋翼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>56-区间合并</title>
      <link href="2021/09/21/LeetCode-56-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
      <url>2021/09/21/LeetCode-56-%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-56-Merge-Intervals"><a href="#LeetCode-56-Merge-Intervals" class="headerlink" title="LeetCode 56. Merge Intervals"></a>LeetCode 56. Merge Intervals</h2><p>Given an array of <code>intervals</code> where <code>intervals[i] = [starti, endi]</code>, merge all <strong>overlapping</strong> intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-模拟"><a href="#method-模拟" class="headerlink" title="method: 模拟"></a>method: 模拟</h2><p>先按左区间排序，左区间相同再按右区间排序<br>如果后一个区间的左区间小于当前区间的右区间，就可以合并，取两个区间的右区间的较大值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;    if (intervals.size() &lt;&#x3D; 1) return intervals;    sort(intervals.begin(), intervals.end());   &#x2F;&#x2F; 区间排序    vector&lt;vector&lt;int&gt;&gt; res;    res.push_back(intervals[0]);    for (int i &#x3D; 1; i &lt; intervals.size(); i++) &#123;        if (intervals[i][0] &lt;&#x3D; res.back()[1])            res.back()[1] &#x3D; max(res.back()[1], intervals[i][1]);        else             res.push_back(intervals[i]);    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21-合并两个排序的链表</title>
      <link href="2021/09/18/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
      <url>2021/09/18/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-21-Merge-Two-Sorted-Lists"><a href="#LeetCode-21-Merge-Two-Sorted-Lists" class="headerlink" title="LeetCode 21. Merge Two Sorted Lists"></a>LeetCode 21. Merge Two Sorted Lists</h2><p>Merge two <strong>sorted</strong> linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.</p><p>Example 1:</p><p><img src="/2021/09/18/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/21.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]Output: [1,1,2,3,4,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method-1-模拟"><a href="#method-1-模拟" class="headerlink" title="method 1: 模拟"></a>method 1: 模拟</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;    if (!l1) return l2;    if (!l2) return l1;    ListNode *dummy &#x3D; new ListNode(0);    ListNode *head &#x3D; dummy;    while (l1 &amp;&amp; l2) &#123;        if (l1-&gt;val &lt; l2-&gt;val) &#123;            head-&gt;next &#x3D; l1;            l1 &#x3D; l1-&gt;next;        &#125;        else &#123;            head-&gt;next &#x3D; l2;            l2 &#x3D; l2-&gt;next;        &#125;        head &#x3D; head-&gt;next;    &#125;    if (l1) head-&gt;next &#x3D; l1;    if (l2) head-&gt;next &#x3D; l2;    return dummy-&gt;next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-递归"><a href="#method-2-递归" class="headerlink" title="method 2: 递归"></a>method 2: 递归</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;    if (!l1) return l2;    if (!l2) return l1;    if (l1-&gt;val &lt; l2-&gt;val) &#123;        l1-&gt;next &#x3D; mergeTwoLists(l1-&gt;next, l2);        return l1;    &#125;    else &#123;        l2-&gt;next &#x3D; mergeTwoLists(l1, l2-&gt;next);        return l2;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8-字符串转换整数</title>
      <link href="2021/09/18/LeetCode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"/>
      <url>2021/09/18/LeetCode-8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-8-String-to-Integer-atoi"><a href="#LeetCode-8-String-to-Integer-atoi" class="headerlink" title="LeetCode 8. String to Integer (atoi)"></a>LeetCode 8. String to Integer (atoi)</h2><p>Implement the <code>myAtoi(string s)</code> function, which converts a <strong>string</strong> to a <strong>32-bit signed integer</strong> (similar to C/C++’s atoi function).</p><p>The algorithm for myAtoi(string s) is as follows:</p><p>Read in and ignore <strong>any leading whitespace</strong>.<br>Check if the next character (if not already at the end of the string) is <code>&#39;-&#39;</code> or <code>&#39;+&#39;</code>. Read this character in if it is either. This determines if the final result is <strong>negative</strong> or <strong>positive</strong> respectively. Assume the result is positive if neither is present.<br>Read in next the characters until the next <strong>non-digit</strong> charcter or the end of the input is reached. The rest of the string is ignored.<br>Convert these digits into an integer (i.e. “123” -&gt; 123, “0032” -&gt; 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).<br>If the integer is out of the 32-bit signed integer range <code>[-2^31, 2^31 - 1]</code>, then clamp the integer so that it remains in the range. Specifically, integers less than <code>-2^31</code> should be clamped to <code>-2^31</code>, and integers greater than <code>2^31 - 1</code> should be clamped to <code>2^31 - 1</code>.<br>Return the integer as the final result.<br>Note:</p><p>Only the space character <code>&#39; &#39;</code> is considered a whitespace character.<br>Do not ignore any characters other than the leading whitespace or the rest of the string after the digits.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;42&quot;Output: 42<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;   -42a&quot;Output: -42<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>先找到第一个字符的位置，判断正负号，再读取每个数字字符整合在一起</p><p>判断溢出逻辑：整数范围是<code>-21,4748,3648</code>到<code>21,4748,3647</code>，如果一个数已经大于<code>21,4748,364</code>，那再来一位什么数都会溢出。<br>或者一个数等于<code>21,4748,364</code>，再来一位大于7的数就会溢出，虽然负数的话，来个8也行，但这里就算来8，输出的也是<code>-21,4748,3648</code>，所以一起当成溢出处理</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int myAtoi(string s) &#123;    int sign &#x3D; 1, base &#x3D; 0;    int i &#x3D; 0;    while (i &lt; s.size() &amp;&amp; s[i] &#x3D;&#x3D; &#39; &#39;) i++;    if (i &#x3D;&#x3D; s.size()) return 0;    if (s[i] &#x3D;&#x3D; &#39;-&#39; || s[i] &#x3D;&#x3D; &#39;+&#39;) &#123;        if (s[i] &#x3D;&#x3D; &#39;-&#39;) &#123;            sign &#x3D; -1;        &#125;        i++;    &#125;    while (i &lt; s.size() &amp;&amp; s[i] &gt;&#x3D; &#39;0&#39; &amp;&amp; s[i] &lt;&#x3D; &#39;9&#39;) &#123;        int num &#x3D; s[i] - &#39;0&#39;;        if (base &gt; INT_MAX &#x2F; 10 || (base &#x3D;&#x3D; INT_MAX &#x2F; 10 &amp;&amp; num &gt; 7)) &#123;            if (sign &#x3D;&#x3D; 1) return INT_MAX;            else return INT_MIN;        &#125;        base &#x3D; base * 10 + num;        i++;    &#125;    return sign * base;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波</title>
      <link href="2021/09/17/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
      <url>2021/09/17/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
      
        <content type="html"><![CDATA[<p>用处：在有噪声的情况下结合不同的传感器来找到数据的最佳估计值</p><p>在飞控上的应用：</p><ul><li>姿态角估计</li></ul><p>通过建立含有姿态角，角速度，加速度等状态量的模型，通过IMU的数据进行卡尔曼滤波，重新估计出状态量，间接得到姿态角数据</p><ul><li>位置估计</li></ul><p>加速度一次、二次积分得到速度、位置，GPS观测得到速度和位置，通过卡尔曼滤波进行互补，在不同噪声情况下选择最优估计值</p>]]></content>
      
      
      <categories>
          
          <category> 多旋翼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>66-加一</title>
      <link href="2021/09/17/LeetCode-66-%E5%8A%A0%E4%B8%80/"/>
      <url>2021/09/17/LeetCode-66-%E5%8A%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-66-Plus-One"><a href="#LeetCode-66-Plus-One" class="headerlink" title="LeetCode 66. Plus One"></a>LeetCode 66. Plus One</h2><p>You are given a large integer represented as an integer array digits, where each <code>digits[i]</code> is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0’s.</p><p>Increment the large integer by <strong>one</strong> and return the resulting array of digits.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: digits &#x3D; [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.Incrementing by one gives 123 + 1 &#x3D; 124.Thus, the result should be [1,2,4].<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123;    int carry &#x3D; 1;    for (int i &#x3D; digits.size() - 1; i &gt;&#x3D; 0; i--) &#123;        if (carry &#x3D;&#x3D; 0) return digits;        int sum &#x3D; digits[i] + carry;        digits[i] &#x3D; sum % 10;        carry &#x3D; sum &#x2F; 10;    &#125;    if (carry) &#123;        vector&lt;int&gt; res(digits.size() + 1);        res[0] &#x3D; 1;        return res;    &#125;    return digits;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-两个正序数组的中位数</title>
      <link href="2021/09/16/LeetCode-4-%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>2021/09/16/LeetCode-4-%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-4-Median-of-Two-Sorted-Arrays"><a href="#LeetCode-4-Median-of-Two-Sorted-Arrays" class="headerlink" title="LeetCode 4. Median of Two Sorted Arrays"></a>LeetCode 4. Median of Two Sorted Arrays</h2><p>Given two <strong>sorted</strong> arrays <code>nums1</code> and <code>nums2</code> of size m and n respectively, return the <strong>median</strong> of the two sorted arrays.</p><p>The overall run time complexity should be $O(log (m+n))$.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums1 &#x3D; [1,3], nums2 &#x3D; [2]Output: 2.00000Explanation: merged array &#x3D; [1,2,3] and median is 2.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]Output: 2.50000Explanation: merged array &#x3D; [1,2,3,4] and median is (2 + 3) &#x2F; 2 &#x3D; 2.5.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-二分法"><a href="#method-二分法" class="headerlink" title="method: 二分法"></a>method: 二分法</h2><p>二分法只要出现<code>l = mid</code>，不管是在<code>if</code>分支还是在<code>else</code>分支，<code>mid</code>的计算都要用<code>(l+r+1)/2</code></p><p>让<code>nums1</code>是短的那条，以防计算<code>nums[j]</code>的时候越界</p><p>知道了两个数组的大小，也就知道了合并后数组的中位数的位置，这里将偶数情况和奇数情况统一起来，都用<code>(m + n + 1) / 2</code>，让奇数情况的前半部分比后半部分多一个元素</p><p>问题转化为在<code>nums1</code>中寻找合适的分割点，使得两个数组分割点左侧的元素都小于分割点右侧的元素</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;    if (nums1.size() &gt; nums2.size()) swap(nums1, nums2);    int m &#x3D; nums1.size(), n &#x3D; nums2.size();    int totalLeft &#x3D; (m + n + 1) &#x2F; 2;    int l &#x3D; 0, r &#x3D; m;    while (l &lt; r) &#123;        int i &#x3D; l + r + 1 &gt;&gt; 1; &#x2F;&#x2F; nums1分割点        int j &#x3D; totalLeft - i;  &#x2F;&#x2F; nums2分割点        if (nums1[i - 1] &lt;&#x3D; nums2[j]) l &#x3D; i;    &#x2F;&#x2F; 满足条件l右移        else r &#x3D; i - 1;     &#x2F;&#x2F; 不满足条件r左移    &#125;    int i &#x3D; l;    int j &#x3D; totalLeft - i;    &#x2F;&#x2F; 四种极端情况    int nums1Left &#x3D; (i &#x3D;&#x3D; 0) ? INT_MIN : nums1[i - 1];    int nums1Right &#x3D; (i &#x3D;&#x3D; m) ? INT_MAX : nums1[i];    int nums2Left &#x3D; (j &#x3D;&#x3D; 0) ? INT_MIN : nums2[j - 1];    int nums2Right &#x3D; (j &#x3D;&#x3D; n) ? INT_MAX : nums2[j];    if ((m + n) % 2) &#123;  &#x2F;&#x2F; 合并后是奇数        return max(nums1Left, nums2Left);    &#125;    else &#123;  &#x2F;&#x2F; 合并后是偶数        return (max(nums1Left, nums2Left) + min(nums1Right, nums2Right)) &#x2F; 2.0;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100-相同的树</title>
      <link href="2021/09/16/LeetCode-100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/"/>
      <url>2021/09/16/LeetCode-100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-100-Same-Tree"><a href="#LeetCode-100-Same-Tree" class="headerlink" title="LeetCode 100. Same Tree"></a>LeetCode 100. Same Tree</h2><p>Share<br>Given the roots of two binary trees p and q, write a function to check if they are the same or not.</p><p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p><p>Example 1:<br><img src="/2021/09/16/LeetCode-100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/100.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: p &#x3D; [1,2,3], q &#x3D; [1,2,3]Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><p>都空返回<code>true</code><br>否则，一个空一个非空，返回<code>false</code><br>最后处理都非空的情况</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool isSameTree(TreeNode* p, TreeNode* q) &#123;    if (!p &amp;&amp; !q) return true;  &#x2F;&#x2F; 都空    else if (!q || !p) return false;    &#x2F;&#x2F; 一个空，一个非空    bool cur &#x3D; p-&gt;val &#x3D;&#x3D; q-&gt;val;    &#x2F;&#x2F; 都非空    bool left &#x3D; isSameTree(p-&gt;left, q-&gt;left);    bool right &#x3D;  isSameTree(p-&gt;right, q-&gt;right);    return cur &amp;&amp; left &amp;&amp; right;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>239-滑动窗口的最大值</title>
      <link href="2021/09/16/LeetCode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>2021/09/16/LeetCode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-239-Sliding-Window-Maximum"><a href="#LeetCode-239-Sliding-Window-Maximum" class="headerlink" title="LeetCode 239. Sliding Window Maximum"></a>LeetCode 239. Sliding Window Maximum</h2><p>You are given an array of integers nums, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p><p>Return the <strong>max</strong> sliding window.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3Output: [3,3,5,5,6,7]Explanation: Window position                Max---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-单调队列"><a href="#method-单调队列" class="headerlink" title="method: 单调队列"></a>method: 单调队列</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;    deque&lt;int&gt; q;    for (int i &#x3D; 0; i &lt; k; i++) &#123;        while (!q.empty() &amp;&amp; nums[q.back()] &lt; nums[i])            q.pop_back();        q.push_back(i);    &#125;    vector&lt;int&gt; res;    res.push_back(nums[q.front()]);    for (int i &#x3D; k; i &lt; nums.size(); i++) &#123;        while (!q.empty() &amp;&amp; nums[q.back()] &lt; nums[i])            q.pop_back();        if (!q.empty() &amp;&amp; i - q.front() &gt;&#x3D; k)            q.pop_front();        q.push_back(i);        res.push_back(nums[q.front()]);    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36-有效数独</title>
      <link href="2021/09/15/LeetCode-36-%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC/"/>
      <url>2021/09/15/LeetCode-36-%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-36-Valid-Sudoku"><a href="#LeetCode-36-Valid-Sudoku" class="headerlink" title="LeetCode 36. Valid Sudoku"></a>LeetCode 36. Valid Sudoku</h2><p>Determine if a <code>9 x 9</code> Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p><ul><li>Each row must contain the digits 1-9 without repetition.</li><li>Each column must contain the digits 1-9 without repetition.</li><li>Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li></ul><p>Note:</p><p>A Sudoku board (partially filled) could be valid but is not necessarily solvable.<br>Only the filled cells need to be validated according to the mentioned rules.</p><p>Example 1:<br><img src="/2021/09/15/LeetCode-36-%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC/36.png" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: board &#x3D; [[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-模拟"><a href="#method-模拟" class="headerlink" title="method: 模拟"></a>method: 模拟</h2><p>每个数字对应一个27位的数组，前9位代表是否在某行出现，中间9位代表是否在某列出现，后9位代表是否在某个方框中出现</p><p>通过整体的<code>(i,j)</code>获取方框的下标：<code>i / 3 * 3 + j / 3</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool used[9][27];bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;    for (int i &#x3D; 0; i &lt; 9; i++) &#123;        for (int j &#x3D; 0; j &lt; 9; j++) &#123;            if (board[i][j] &#x3D;&#x3D; &#39;.&#39;) continue;            int k &#x3D; i &#x2F; 3 * 3 + j &#x2F; 3;  &#x2F;&#x2F; 属于哪个方框            int num &#x3D; board[i][j] - &#39;1&#39;;            if (used[num][i] || used[num][j + 9] || used[num][k + 18])                return false;            used[num][i] &#x3D; true;            used[num][j + 9] &#x3D; true;            used[num][k + 18] &#x3D; true;        &#125;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以只用长度为9的数组记录，用时间换空间，每次用之前都要先清空<br>同样也是注意方框的遍历的写法</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int used[9];bool check(char ch) &#123;    if (ch &#x3D;&#x3D; &#39;.&#39;) return true;    int num &#x3D; ch - &#39;1&#39;;    if (used[num]) return false;    return used[num] &#x3D; true;&#125;bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;    for (int i &#x3D; 0; i &lt; 9; i++) &#123;        fill(used, used + 9, false);    &#x2F;&#x2F; 清空        for (int j &#x3D; 0; j &lt; 9; j++) &#123;   &#x2F;&#x2F; 判断行            if (!check(board[i][j])) return false;        &#125;        fill(used, used + 9, false);        for (int j &#x3D; 0; j &lt; 9; j++) &#123;   &#x2F;&#x2F; 判断列            if (!check(board[j][i])) return false;        &#125;    &#125;    &#x2F;&#x2F; 判断每个方框    for (int r &#x3D; 0; r &lt; 3; r++) &#123;        for (int c &#x3D; 0; c &lt; 3; c++) &#123;            fill(used, used + 9, false);            for (int i &#x3D; r * 3; i &lt; r * 3 + 3; i++) &#123;                for (int j &#x3D; c * 3; j &lt; c * 3 + 3; j++) &#123;                    if (!check(board[i][j])) return false;                &#125;            &#125;        &#125;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206-反转链表</title>
      <link href="2021/09/15/LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>2021/09/15/LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-206-Reverse-Linked-List"><a href="#LeetCode-206-Reverse-Linked-List" class="headerlink" title="LeetCode 206. Reverse Linked List"></a>LeetCode 206. Reverse Linked List</h2><p>同<a href="https://kavinwkp.github.io/2021/05/25/%E5%89%91%E6%8C%87Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">剑指Offer</a></p><p>Given the head of a singly linked list, <strong>reverse</strong> the list, and return the reversed list.</p><p>Example 1:<br><img src="/2021/09/15/LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/206.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [1,2,3,4,5]Output: [5,4,3,2,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* reverseList(ListNode* head) &#123;    if (!head || !head-&gt;next) return head;    ListNode *newHead &#x3D; reverseList(head-&gt;next);    head-&gt;next-&gt;next &#x3D; head;    head-&gt;next &#x3D; nullptr;    return newHead;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-92-Reverse-Linked-List-II"><a href="#LeetCode-92-Reverse-Linked-List-II" class="headerlink" title="LeetCode 92. Reverse Linked List II"></a>LeetCode 92. Reverse Linked List II</h2><p>Given the head of a singly linked list and two integers <code>left</code> and <code>right</code> where <code>left &lt;= right</code>, reverse the nodes of the list from position left to position right, and return the reversed list.</p><p>Example 1:<br><img src="/2021/09/15/LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/92.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [1,2,3,4,5], left &#x3D; 2, right &#x3D; 4Output: [1,4,3,2,5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-1-递归"><a href="#method-1-递归" class="headerlink" title="method 1: 递归"></a>method 1: 递归</h2><p>跟反转链表一样，只是加一个计数器，记录递归的深度</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode *rightNode &#x3D; nullptr;ListNode* traversal(ListNode *head, int cnt) &#123;    if (cnt &#x3D;&#x3D; 0) &#123;        rightNode &#x3D; head-&gt;next;        return head;    &#125;    ListNode *newHead &#x3D; traversal(head-&gt;next, cnt-1);    head-&gt;next-&gt;next &#x3D; head;    head-&gt;next &#x3D; nullptr;    return newHead;&#125;ListNode* reverseBetween(ListNode* head, int left, int right) &#123;    int offset &#x3D; right - left;    ListNode *dummy &#x3D; new ListNode(0, head);    head &#x3D; dummy;    while (--left) head &#x3D; head-&gt;next;    ListNode *leftNode &#x3D; head-&gt;next;    head-&gt;next &#x3D; traversal(head-&gt;next, offset);    leftNode-&gt;next &#x3D; rightNode;    return dummy-&gt;next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-模拟"><a href="#method-2-模拟" class="headerlink" title="method 2: 模拟"></a>method 2: 模拟</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* reverseBetween(ListNode* head, int left, int right) &#123;    int len &#x3D; right - left;    ListNode *dummy &#x3D; new ListNode(0, head);    head &#x3D; dummy;    while (--left) head &#x3D; head-&gt;next;     ListNode *pre &#x3D; head-&gt;next;    ListNode *cur &#x3D; head-&gt;next-&gt;next;    for (int i &#x3D; 0; i &lt; len; i++) &#123;        ListNode *tmp &#x3D; cur-&gt;next;        cur-&gt;next &#x3D; pre;        pre &#x3D; cur;        cur &#x3D; tmp;    &#125;    head-&gt;next-&gt;next &#x3D; cur;    head-&gt;next &#x3D; pre;    return dummy-&gt;next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab字符变量</title>
      <link href="2021/09/14/%E6%95%B0%E5%AD%A6-MATLAB-%E5%AD%97%E7%AC%A6%E5%8F%98%E9%87%8F/"/>
      <url>2021/09/14/%E6%95%B0%E5%AD%A6-MATLAB-%E5%AD%97%E7%AC%A6%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="字符变量"><a href="#字符变量" class="headerlink" title="字符变量"></a>字符变量</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">syms a b real;x &#x3D; (a + b) ^ 2;expand(x);  &#x2F;&#x2F; 展开 a^2 + 2*a*b + b^2y &#x3D; (a &#x2F; 2) ^ 2 &#x2F; a;    &#x2F;&#x2F; 自动化简 a&#x2F;4z &#x3D; sin(a) ^ 2 + cos(a) ^ 2;simplify(z)     &#x2F;&#x2F; 简化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="字符矩阵"><a href="#字符矩阵" class="headerlink" title="字符矩阵"></a>字符矩阵</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">A &#x3D; [0 -z y; z 0 -x; -y x 0];[V, D] &#x3D; eig(A);    &#x2F;&#x2F; 特征值和特征向量det(A);     &#x2F;&#x2F; 行列式A&#39;;     &#x2F;&#x2F; 转置inv(A)  &#x2F;&#x2F; 求逆<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求旋转矩阵<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">syms phi theta psi realRz &#x3D; [cos(psi) -sin(psi) 0; sin(psi) cos(psi) 0; 0 0 1];Ry &#x3D; [cos(theta) 0 sin(theta); 0 1 0; -sin(theta) 0 cos(theta)];Rx &#x3D; [1 0 0; 0 cos(phi) -sin(phi); 0 sin(phi) cos(phi)];R &#x3D; Rz * Ry * Rx[ cos(psi)*cos(theta), cos(psi)*sin(phi)*sin(theta) - cos(phi)*sin(psi), sin(phi)*sin(psi) + cos(phi)*cos(psi)*sin(theta)][ cos(theta)*sin(psi), cos(phi)*cos(psi) + sin(phi)*sin(psi)*sin(theta), cos(phi)*sin(psi)*sin(theta) - cos(psi)*sin(phi)][         -sin(theta),                              cos(theta)*sin(phi),                              cos(phi)*cos(theta)] <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48-翻转图像</title>
      <link href="2021/09/14/LeetCode-48-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/"/>
      <url>2021/09/14/LeetCode-48-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-48-Rotate-Image"><a href="#LeetCode-48-Rotate-Image" class="headerlink" title="LeetCode 48. Rotate Image"></a>LeetCode 48. Rotate Image</h2><p>You are given an <code>n x n</code> 2D matrix representing an image, rotate the image by <code>90 degrees</code> (clockwise).</p><p>You have to rotate the image in-place, which means you have to modify the input 2D matrix <strong>directly</strong>. DO NOT allocate another 2D matrix and do the rotation.</p><p>Example 1:<br><img src="/2021/09/14/LeetCode-48-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/48.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]Output: [[7,4,1],[8,5,2],[9,6,3]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p><code>i</code>表示要处理的行数，<code>j</code>表示要处理的列数，<code>i</code>可以就<code>n/2</code>，但<code>j</code>要<code>(n+1)/2</code>，囊括要处理的区域</p><p>难点：下标的推导</p><p><img src="/2021/09/14/LeetCode-48-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/48_1.png" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;    int n &#x3D; matrix.size();    for (int i &#x3D; 0; i &lt; n &#x2F; 2; i++) &#123;        for (int j &#x3D; 0; j &lt; (n + 1) &#x2F; 2; j++) &#123;            int tmp &#x3D; matrix[i][j];            matrix[i][j] &#x3D; matrix[n-1-j][i];            matrix[n-1-j][i] &#x3D; matrix[n-1-i][n-1-j];            matrix[n-1-i][n-1-j] &#x3D; matrix[j][n-1-i];            matrix[j][n-1-i] &#x3D; tmp;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>848-字母移位</title>
      <link href="2021/09/13/LeetCode-848-%E5%AD%97%E6%AF%8D%E7%A7%BB%E4%BD%8D/"/>
      <url>2021/09/13/LeetCode-848-%E5%AD%97%E6%AF%8D%E7%A7%BB%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-848-Shifting-Letters"><a href="#LeetCode-848-Shifting-Letters" class="headerlink" title="LeetCode 848. Shifting Letters"></a>LeetCode 848. Shifting Letters</h2><p>You are given a string s of <strong>lowercase</strong> English letters and an integer array shifts of the same length.</p><p>Call the <code>shift()</code> of a letter, the next letter in the alphabet, (wrapping around so that ‘z’ becomes ‘a’).</p><p>For example, <code>shift(&#39;a&#39;) = &#39;b&#39;</code>, <code>shift(&#39;t&#39;) = &#39;u&#39;</code>, and <code>shift(&#39;z&#39;) = &#39;a&#39;</code>.<br>Now for each <code>shifts[i] = x</code>, we want to shift the first i + 1 letters of s, x times.</p><p>Return the final string after all such shifts to s are applied.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;abc&quot;, shifts &#x3D; [3,5,9]Output: &quot;rpl&quot;Explanation: We start with &quot;abc&quot;.After shifting the first 1 letters of s by 3, we have &quot;dbc&quot;.After shifting the first 2 letters of s by 5, we have &quot;igc&quot;.After shifting the first 3 letters of s by 9, we have &quot;rpl&quot;, the answer.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-前缀和"><a href="#method-前缀和" class="headerlink" title="method: 前缀和"></a>method: 前缀和</h2><p>从后往前进行前缀和，注意要模以26</p><p>字母移位逻辑：先减去<code>&#39;a&#39;</code>，映射到<code>[0,25]</code>，再加上要移动的位数，注意也要模以26</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string shiftingLetters(string s, vector&lt;int&gt;&amp; nums) &#123;    for (int i &#x3D; nums.size() - 2; i &gt;&#x3D; 0; i--)        nums[i] &#x3D; (nums[i] + nums[i + 1]) % 26;    nums.back() %&#x3D; 26;    for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;        s[i] &#x3D; (s[i] - &#39;a&#39; + nums[i]) % 26 + &#39;a&#39;;    &#125;    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以合起来一起写，用一个数记录前缀和</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string shiftingLetters(string s, vector&lt;int&gt;&amp; nums) &#123;    int num &#x3D; 0;    for (int i &#x3D; s.size() - 1; i &gt;&#x3D; 0; i--) &#123;        s[i] &#x3D; (s[i] - &#39;a&#39; + (num + nums[i]) % 26) % 26 + &#39;a&#39;;        num &#x3D; (num + nums[i]) % 26;    &#125;    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>669-修剪二叉搜索树</title>
      <link href="2021/09/13/LeetCode-669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>2021/09/13/LeetCode-669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-669-Trim-a-Binary-Search-Tree"><a href="#LeetCode-669-Trim-a-Binary-Search-Tree" class="headerlink" title="LeetCode 669. Trim a Binary Search Tree"></a>LeetCode 669. Trim a Binary Search Tree</h2><p>Given the root of a binary search tree and the <strong>lowest</strong> and <strong>highest</strong> boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node’s descendant should remain a descendant). It can be proven that there is a unique answer.</p><p>Return the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.</p><p>Example 1:</p><p><img src="/2021/09/13/LeetCode-669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/669_1.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [1,0,2], low &#x3D; 1, high &#x3D; 2Output: [1,null,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Example 2:<br><img src="/2021/09/13/LeetCode-669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/669_2.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [3,0,4,null,2,null,null,1], low &#x3D; 1, high &#x3D; 3Output: [3,2,null,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>如果节点值小于左区间，返回递归处理的右子树，因为左子树肯定也都小于，直接扔掉<br>如果节点值大于右区间，返回递归处理的左子树，扔掉右子树<br>否则，分别递归处理左子树和右子树</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode* trimBST(TreeNode* root, int low, int high) &#123;    if (!root) return root;    if (root-&gt;val &lt; low) return trimBST(root-&gt;right, low, high);    if (root-&gt;val &gt; high) return trimBST(root-&gt;left, low, high);    root-&gt;left &#x3D; trimBST(root-&gt;left, low, high);    root-&gt;right &#x3D; trimBST(root-&gt;right, low, high);    return root;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>450-删除二叉搜索树中的节点</title>
      <link href="2021/09/13/LeetCode-450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>2021/09/13/LeetCode-450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-450-Delete-Node-in-a-BST"><a href="#LeetCode-450-Delete-Node-in-a-BST" class="headerlink" title="LeetCode 450. Delete Node in a BST"></a>LeetCode 450. Delete Node in a BST</h2><p>Given a <strong>root</strong> node reference of a BST and a key, delete the node with the given key in the BST. Return the <strong>root</strong> node reference (possibly updated) of the BST.</p><p>Basically, the deletion can be divided into two stages:</p><p>Search for a node to remove.<br>If the node is found, delete the node.<br>Follow up: Can you solve it with time complexity O(height of tree)?</p><p>Example 1:<br><img src="/2021/09/13/LeetCode-450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/450.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3Output: [5,4,6,2,null,null,7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><ul><li>空节点是没找到，直接返回</li><li>比当前节点值小，往左子树找</li><li>比当前节点值大，往右子树找</li></ul><p>正好等于当前节点值，删除的逻辑</p><ul><li>左子树空，返回右子树</li><li>右子树空，返回左子树</li><li>都不空，把左子树放到右子树的最左边的叶子节点，删掉当前节点，返回右子树节点</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode* deleteNode(TreeNode* root, int key) &#123;    if (!root) return root;    if (key &#x3D;&#x3D; root-&gt;val)&#123;        if (!root-&gt;left) return root-&gt;right;        else if (!root-&gt;right) return root-&gt;left;        else &#123;            TreeNode *cur &#x3D; root-&gt;right;            while (cur-&gt;left) cur &#x3D; cur-&gt;left;            cur-&gt;left &#x3D; root-&gt;left;            TreeNode *tmp &#x3D; root;            root &#x3D; root-&gt;right;            delete tmp;            return root;        &#125;    &#125;    if (key &lt; root-&gt;val) root-&gt;left &#x3D; deleteNode(root-&gt;left, key);    if (key &gt; root-&gt;val) root-&gt;right &#x3D; deleteNode(root-&gt;right, key);    return root;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无人机运动学</title>
      <link href="2021/09/13/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC%E8%BF%90%E5%8A%A8%E5%AD%A6/"/>
      <url>2021/09/13/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC%E8%BF%90%E5%8A%A8%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>运动学与质量和受力无关，只研究位置，速度，姿态，角速度等参量</p><h2 id="坐标系变换与旋转矩阵"><a href="#坐标系变换与旋转矩阵" class="headerlink" title="坐标系变换与旋转矩阵"></a>坐标系变换与旋转矩阵</h2><p><img src="/2021/09/13/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC%E8%BF%90%E5%8A%A8%E5%AD%A6/dcm.png" alt></p><p>$p$在$\mathcal{A}$中的坐标为$\begin{bmatrix}p_1&amp;p_2&amp;p_3\end{bmatrix}^\mathrm{T}$，$p^{\prime}$在$\mathcal{B}$中的坐标也是$\begin{bmatrix}p_1&amp;p_2&amp;p_3\end{bmatrix}^\mathrm{T}$，旋转矩阵$R$的每一列是$\mathcal{B}$的三个基向量在$\mathcal{A}$中的投影。</p><script type="math/tex; mode=display">\begin{bmatrix}\mathbf{x_B} & \mathbf{y_B} & \mathbf{z_B}\end{bmatrix} = \begin{bmatrix}\mathbf{x_A} & \mathbf{y_A} & \mathbf{z_A}\end{bmatrix} \cdot R</script><p>两边同乘以$\begin{bmatrix}p_1&amp;p_2&amp;p_3\end{bmatrix}^\mathrm{T}$，得到</p><script type="math/tex; mode=display">\begin{bmatrix}\mathbf{x_B} & \mathbf{y_B} & \mathbf{z_B}\end{bmatrix}\begin{bmatrix}p_1\\p_2\\p_3\end{bmatrix} = \begin{bmatrix}\mathbf{x_A} & \mathbf{y_A} & \mathbf{z_A}\end{bmatrix} \cdot R\begin{bmatrix}p_1\\p_2\\p_3\end{bmatrix}</script><p>也就是$p^{\prime}$在$\mathcal{A}$中的坐标是$R\begin{bmatrix}p_1&amp;p_2&amp;p_3\end{bmatrix}^\mathrm{T}$<br>即把$p^{\prime}$移动到$\mathcal{A}$中，记为$q$，要得到$q$在$\mathcal{A}$中的坐标，需要左乘旋转矩阵$R$</p><script type="math/tex; mode=display">\begin{bmatrix}q_1\\q_2\\q_3\end{bmatrix}=R\begin{bmatrix}p_1\\p_2\\p_3\end{bmatrix}</script><p>即</p><script type="math/tex; mode=display">\mathbf{q}=R\mathbf{p}</script><p>这也可以看成在$\mathcal{A}$坐标系中，向量$p$通过旋转得到向量$q$。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/2021/09/13/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC%E8%BF%90%E5%8A%A8%E5%AD%A6/example.png" alt><br>$\mathcal{A}$绕$z$轴旋转$60^{\circ}$得到$\mathcal{B}$，则$\mathcal{B}$中向量$\begin{bmatrix}1&amp;0&amp;0\end{bmatrix}^\mathrm{T}$在$\mathcal{A}$中的坐标为</p><script type="math/tex; mode=display">\begin{bmatrix}\frac{1}{2} & -\frac{\sqrt{3}}{2} & 0 \\\frac{\sqrt{3}}{2} & \frac{1}{2} & 0 \\ 0 & 0 & 1\end{bmatrix} \cdot \begin{bmatrix}1\\0\\0\end{bmatrix} = \begin{bmatrix}\frac{1}{2} \\\frac{\sqrt{3}}{2}\\ 0\end{bmatrix}</script><p>也可以看成是$\mathcal{A}$中的向量$\mathbf{p}=\begin{bmatrix}1&amp;0&amp;0\end{bmatrix}^\mathrm{T}$绕$z$轴旋转$60^{\circ}$得到向量$\mathbf{q}=\begin{bmatrix}\frac{1}{2} &amp;\frac{\sqrt{3}}{2}&amp; 0\end{bmatrix}^\mathrm{T}$</p><h3 id="旋转矩阵姿态运动学方程"><a href="#旋转矩阵姿态运动学方程" class="headerlink" title="旋转矩阵姿态运动学方程"></a>旋转矩阵姿态运动学方程</h3><p>对$\mathbf{q}=R\mathbf{p}$微分可得</p><script type="math/tex; mode=display">\dot{\mathbf{q}}=\dot{R}\mathbf{p}</script><p>$\dot{\mathbf{q}}$是惯性系下的速度<br>两边同乘以$R^\mathrm{T}$，可得</p><script type="math/tex; mode=display">R^\mathrm{T}\dot{\mathbf{q}}=R^\mathrm{T}\dot{R}\mathbf{p}</script><p>将方程转换到体轴系下，$R^\mathrm{T}\dot{\mathbf{q}}$是体轴系下的速度，根据</p><script type="math/tex; mode=display">\dot{r}=\omega \times r</script><p>或者写成反对称阵形式</p><script type="math/tex; mode=display">\dot{r}=\hat{\omega} \cdot r</script><p>$p$是体轴系下的向量，所以$R^\mathrm{T}\dot{R}$就是体轴系下的角速度的反对称形式，记为</p><script type="math/tex; mode=display">\hat{\omega}_{b} = R^\mathrm{T}\dot{R}</script><p>也可以写成</p><script type="math/tex; mode=display">\dot{R} = R\hat{\omega}_{b}</script><p>同理，由$\mathbf{q}=R\mathbf{p}$可得$\mathbf{p} = R^\mathrm{T}\mathbf{q}$，代入微分方程可得</p><script type="math/tex; mode=display">\dot{\mathbf{q}}=\dot{R} R^\mathrm{T} \mathbf{p}</script><p>则$\dot{R} R^\mathrm{T}$就是惯性系下的角速度，记为</p><script type="math/tex; mode=display">\hat{\omega}_{s} = \dot{R} R^\mathrm{T}</script><p>也可以写成</p><script type="math/tex; mode=display">\dot{R} = \hat{\omega}_{s}R</script><p>参考<a href="https://www.coursera.org/learn/robotics-flight/lecture/eOweb/angular-velocity">Aerial Robotics</a></p><h2 id="Rodrigues公式"><a href="#Rodrigues公式" class="headerlink" title="Rodrigues公式"></a>Rodrigues公式</h2><p>任意旋转都可以用一个旋转轴$u$和一个旋转角$\phi$刻画</p><script type="math/tex; mode=display">R(u, \phi) = Icos\phi + uu^\mathrm{T}(1-cos\phi) + \hat{u}sin\phi</script><p>$\hat{u}$是反对称阵(skew-symmetric matrix)，即$u=\begin{bmatrix}x&amp;y&amp;z\end{bmatrix}$</p><script type="math/tex; mode=display">\hat{u}=\begin{bmatrix} 0 & -z &  y \\ z &  0 & -x \\-y &  x &  0\end{bmatrix}</script><p>即当已知旋转轴和旋转角度后，就可以通过Rodrigues公式求出旋转矩阵</p><h2 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h2><p><img src="/2021/09/13/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC%E8%BF%90%E5%8A%A8%E5%AD%A6/euler00.png" alt></p><p>根据Rodrigues公式，可以写出绕$z$轴、$y$轴、$x$轴的旋转矩阵</p><p>绕$z$轴旋转$\psi$</p><script type="math/tex; mode=display">R_Z(\psi) = \begin{bmatrix} cos\psi & -sin\psi &  0 \\ sin\psi &  cos\psi & 0 \\0 &  0 &  1\end{bmatrix}</script><p>绕$y$轴旋转$\theta$</p><script type="math/tex; mode=display">R_Y(\theta) = \begin{bmatrix} cos\theta & 0 &  sin\theta \\ 0 &  1 & 0 \\ -sin\theta &  0 &  cos\theta\end{bmatrix}</script><p>绕$x$轴旋转$\phi$</p><script type="math/tex; mode=display">R_X(\phi) = \begin{bmatrix} 1 & 0 &  0 \\ 0 & cos\phi & -sin\phi \\ 0 &  sin\phi &  cos\phi\end{bmatrix}</script><p>按Z-Y-X的顺序组成三次旋转的复合旋转矩阵</p><script type="math/tex; mode=display">R_Z(\psi)R_Y(\theta)R_X(\phi) = \begin{bmatrix}cos\psi cos\theta&cos\psi sin\theta \sin\phi-sin\psi cos\phi&cos\psi sin\theta cos\phi+sin\psi sin\phi\\sin\psi cos\theta&sin\psi sin\theta sin\phi+cos\psi cos\phi&sin\psi sin\theta cos\phi-cos\psi sin\phi\\-sin\theta&cos\theta sin\phi&cos\theta cos\phi\end{bmatrix}</script><p>这里每个旋转矩阵都是在新的坐标系中描述的，所以是右乘<br>如果是相对于原始坐标系，就要左乘。所以也可以看成是相对于原始坐标系的描述的X-Y-Z旋转复合</p><h3 id="欧拉角姿态运动方程"><a href="#欧拉角姿态运动方程" class="headerlink" title="欧拉角姿态运动方程"></a>欧拉角姿态运动方程</h3><p><img src="/2021/09/13/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC%E8%BF%90%E5%8A%A8%E5%AD%A6/euler.png" alt></p><p>机体角速度可以表示为</p><script type="math/tex; mode=display">\mathbf{\omega}= \begin{bmatrix}\mathbf{i}_3 & \mathbf{j}_3 & \mathbf{k}_3\end{bmatrix}\begin{bmatrix}p \\ q \\ r\end{bmatrix}</script><p>可以分解为三次变换的欧拉角速度组合</p><script type="math/tex; mode=display">\mathbf{\omega} = \dot{\psi}\mathbf{k}_1 + \dot{\theta}\mathbf{j}_2 + \dot{\phi}\mathbf{i}_3</script><p>因为</p><script type="math/tex; mode=display">\begin{bmatrix}\mathbf{i}_3 & \mathbf{j}_3 & \mathbf{k}_3\end{bmatrix} = \begin{bmatrix}\mathbf{i}_2 & \mathbf{j}_2 & \mathbf{k}_2\end{bmatrix} R_{32}</script><p>所以</p><script type="math/tex; mode=display">\begin{bmatrix}\mathbf{i}_2 & \mathbf{j}_2 & \mathbf{k}_2\end{bmatrix} = \begin{bmatrix}\mathbf{i}_3 & \mathbf{j}_3 & \mathbf{k}_3\end{bmatrix} R_{32}^\mathrm{T}</script><p>所以</p><script type="math/tex; mode=display">\mathbf{j}_2 = \begin{bmatrix}\mathbf{i}_3 & \mathbf{j}_3 & \mathbf{k}_3\end{bmatrix}\begin{bmatrix}0 \\ cos\phi \\ -sin\phi \end{bmatrix}</script><p>同理</p><script type="math/tex; mode=display">\begin{bmatrix}\mathbf{i}_3 & \mathbf{j}_3 & \mathbf{k}_3\end{bmatrix} = \begin{bmatrix}\mathbf{i}_1 & \mathbf{j}_1 & \mathbf{k}_1\end{bmatrix} R_{21}R_{32}</script><p>所以</p><script type="math/tex; mode=display">\begin{bmatrix}\mathbf{i}_1 & \mathbf{j}_1 & \mathbf{k}_1\end{bmatrix} = \begin{bmatrix}\mathbf{i}_3 & \mathbf{j}_3 & \mathbf{k}_3\end{bmatrix} R_{32}^{\mathrm{T}} R_{21}^{\mathrm{T}}</script><p>所以</p><script type="math/tex; mode=display">\mathbf{k}_1 = \begin{bmatrix}\mathbf{i}_3 & \mathbf{j}_3 & \mathbf{k}_3\end{bmatrix}\begin{bmatrix}-sin\theta \\ sin\phi cos\theta \\ cos\phi cos\theta \end{bmatrix}</script><p>组合起来就是</p><script type="math/tex; mode=display">\dot{\psi}\begin{bmatrix}-sin\theta \\ sin\phi cos\theta \\ cos\phi cos\theta \end{bmatrix} + \dot{\theta}\begin{bmatrix}0 \\ cos\phi \\ -sin\phi \end{bmatrix} +\dot{\phi}\begin{bmatrix}1 \\ 0 \\ 0 \end{bmatrix} = \begin{bmatrix}1 & 0 & -sin\theta \\0 & cos\phi & sin\phi cos\theta \\0 & -sin\phi & cos\phi cos\theta\end{bmatrix}\begin{bmatrix}\dot{\phi} \\ \dot{\theta} \\ \dot{\psi}\end{bmatrix}</script><p>所以</p><script type="math/tex; mode=display">\begin{bmatrix}p \\ q \\ r\end{bmatrix} = \begin{bmatrix}1 & 0 & -sin\theta \\0 & cos\phi & sin\phi cos\theta \\0 & -sin\phi & cos\phi cos\theta\end{bmatrix}\begin{bmatrix}\dot{\phi} \\ \dot{\theta} \\ \dot{\psi}\end{bmatrix}</script><p>也可以写成</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{\phi} \\ \dot{\theta} \\ \dot{\psi}\end{bmatrix} = \begin{bmatrix}1 & sin\phi tan\theta & cos\phi tan\theta \\0 & cos\phi & -sin\phi \\0 & sin\phi/cos\theta & cos\phi/cos\theta\end{bmatrix}\begin{bmatrix}p \\ q \\ r\end{bmatrix}</script><h2 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h2><script type="math/tex; mode=display">q = (q_0, q_1, q_2, q_3)</script><p>或写成</p><script type="math/tex; mode=display">q = (q_0, \mathbf{q})</script><p>加减法</p><script type="math/tex; mode=display">p \pm q = (q_0 \pm q_0, \mathbf{p} \pm \mathbf{q})</script><p>乘法</p><script type="math/tex; mode=display">p \otimes q = (p_0q_0-\mathbf{p}^\mathrm{T}\mathbf{q}, p_0\mathbf{q}+q_0\mathbf{p}+\mathbf{p} \times \mathbf{q})</script><p>共轭</p><script type="math/tex; mode=display">q^{*} = (q_0, -\mathbf{q})</script><p>逆</p><script type="math/tex; mode=display">q^{-1} = \frac{q^{*}}{||q||}</script><p>已知旋转轴$u=\begin{bmatrix}u_1&amp;u_2&amp;u_3\end{bmatrix}^\mathrm{T}$和旋转角度$\phi$，可以写出四元数</p><script type="math/tex; mode=display">q = (cos(\frac{\phi}{2}), u_1sin(\frac{\phi}{2}), u_2sin(\frac{\phi}{2}), u_3sin(\frac{\phi}{2}))</script><p>要对一个向量$p$进行旋转，先将向量写成四元数形式$p=(0, \mathbf{p})$，再左乘四元数$q$，右乘四元数的共轭$q^{-1}$</p><script type="math/tex; mode=display">p^{\prime} = qpq^{*} = (0, \mathbf{p^{\prime}})</script><p>如果$q_1$是坐标系$\mathcal{A}$的四元数，$q_2$也是坐标系$\mathcal{A}$的四元数，则两次四元数的复合旋转是</p><script type="math/tex; mode=display">q = q_2q_1</script><p>如果$q_1$是坐标系$\mathcal{A}$的四元数，旋转之后得到坐标系$\mathcal{B}$，$q_2$是坐标系$\mathcal{B}$的四元数，则两次旋转的复合是</p><script type="math/tex; mode=display">q = q_1q_2</script><h3 id="四元数姿态运动方程"><a href="#四元数姿态运动方程" class="headerlink" title="四元数姿态运动方程"></a>四元数姿态运动方程</h3><script type="math/tex; mode=display">\dot{q} = \frac{\mathbf{\omega}}{2} q</script><p>写成矩阵形式</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{q_0} \\\dot{q_1} \\\dot{q_2} \\\dot{q_3} \\\end{bmatrix} = \frac{1}{2}\begin{bmatrix}0 & -\omega_x & -\omega_y & -\omega_z \\\omega_x & 0 & \omega_z & -\omega_y \\\omega_y & -\omega_z & 0 & \omega_x \\\omega_z & \omega_y & -\omega_x & 0\end{bmatrix}\begin{bmatrix}q_0 \\q_1 \\q_2 \\q_3 \\\end{bmatrix}</script><h4 id="一阶龙格库塔求解"><a href="#一阶龙格库塔求解" class="headerlink" title="一阶龙格库塔求解"></a>一阶龙格库塔求解</h4><script type="math/tex; mode=display">\begin{bmatrix}q_0 \\q_1 \\q_2 \\q_3 \\\end{bmatrix}_{t+\Delta t} = \begin{bmatrix}q_0 \\q_1 \\q_2 \\q_3 \\\end{bmatrix}_t + \frac{\Delta t}{2} \begin{bmatrix}0 & -\omega_x & -\omega_y & -\omega_z \\\omega_x & 0 & \omega_z & -\omega_y \\\omega_y & -\omega_z & 0 & \omega_x \\\omega_z & \omega_y & -\omega_x & 0\end{bmatrix}\begin{bmatrix}q_0 \\q_1 \\q_2 \\q_3 \\\end{bmatrix}_t</script><p>代码实现<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">q0 &#x3D; q0 + (-q1*wx - q2*wy - q3*wz)*halfT;q1 &#x3D; q1 + (q0*wx + q2*wz - q3*wy)*halfT;q2 &#x3D; q2 + (q0*wy - q1*wz + q3*wx)*halfT;q3 &#x3D; q3 + (q0*wz + q1*wy - q2*wx)*halfT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="四元数转欧拉角"><a href="#四元数转欧拉角" class="headerlink" title="四元数转欧拉角"></a>四元数转欧拉角</h3><script type="math/tex; mode=display">\begin{bmatrix}\phi \\ \theta \\\psi\end{bmatrix} = \begin{bmatrix}arctan(\frac{2(q_0q_1+q_2q_3)}{1-2(q_1^2+q_2^2)}) \\arcsin(2(q_0q_2-q_1q_3)) \\arctan(\frac{2(q_0q_3+q_1q_2)}{1-2(q_2^2+q_3^2)})\end{bmatrix}</script><h3 id="四元数表示旋转矩阵"><a href="#四元数表示旋转矩阵" class="headerlink" title="四元数表示旋转矩阵"></a>四元数表示旋转矩阵</h3><p>坐标系$\mathcal{A}$到坐标系$\mathcal{B}$的旋转用四元数描述是$q$<br>则旋转矩阵可以表示为</p><script type="math/tex; mode=display">R^A_B = \begin{bmatrix}q_0^2+q_1^2-q_2^2-q_3^2 & 2(q_1q_2-q_0q_3) & 2(q_1q_3+q_0q_2) \\2(q_1q_2 + q_0q_3) & q_0^2-q_1^2+q_2^2-q_3^2 & 2(q_2q_3-q_0q_1) \\2(q_1q_3-q_0q_2) & 2(q_2q_3+q_0q_1) & q_0^2-q_1^2-q_2^2+q_3^2\end{bmatrix}</script><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><p><img src="/2021/09/13/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC%E8%BF%90%E5%8A%A8%E5%AD%A6/example.png" alt></p><p>旋转轴$u=\begin{bmatrix}0&amp;0&amp;1\end{bmatrix}^\mathrm{T}$，旋转角度$60^{\circ}$</p><script type="math/tex; mode=display">\mathbf{q} = \begin{bmatrix}\frac{\sqrt{3}}{2} \\ 0 \\ 0 \\ \frac{1}{2}\end{bmatrix}</script><p>$q$在坐标系$\mathcal{A}$中的表示为</p><script type="math/tex; mode=display">\begin{bmatrix}\frac{\sqrt{3}}{2} \\ 0 \\ 0 \\ \frac{1}{2}\end{bmatrix} \otimes\begin{bmatrix}0 \\ 1 \\ 0 \\ 0\end{bmatrix} \otimes\begin{bmatrix}\frac{\sqrt{3}}{2} \\ 0 \\ 0 \\ -\frac{1}{2}\end{bmatrix} = \begin{bmatrix}0 \\ \frac{1}{2} \\ \frac{\sqrt{3}}{2} \\ 0 \end{bmatrix}</script><p>所以在坐标系$\mathcal{A}$中向量$\mathbf{q}=\begin{bmatrix}\frac{1}{2} &amp;\frac{\sqrt{3}}{2}&amp; 0\end{bmatrix}^\mathrm{T}$</p><h4 id="旋转复合"><a href="#旋转复合" class="headerlink" title="旋转复合"></a>旋转复合</h4><p><img src="/2021/09/13/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC%E8%BF%90%E5%8A%A8%E5%AD%A6/quaternion_2.png" alt></p><p>坐标系$\mathcal{A}$通过$q_1$旋转到坐标系$\mathcal{B}$，再通过$q_2$旋转到坐标系$\mathcal{C}$，其中$q_2$是在坐标系$\mathcal{B}$中的描述，$q_2^{\prime}$是在$\mathcal{A}$中的描述</p><script type="math/tex; mode=display">q_1 = \begin{bmatrix}\frac{\sqrt{3}}{2} & 0 & 0 & \frac{1}{2}\end{bmatrix}^\mathrm{T}</script><script type="math/tex; mode=display">q_2 = \begin{bmatrix}\frac{\sqrt{2}}{2} & \frac{\sqrt{2}}{2} & 0 & 0\end{bmatrix}^\mathrm{T}</script><p>$q_2^{\prime}$的旋转轴是$\begin{bmatrix}\frac{1}{2} &amp;\frac{\sqrt{3}}{2}&amp; 0\end{bmatrix}^\mathrm{T}$</p><script type="math/tex; mode=display">q_2^{\prime} = \begin{bmatrix}\frac{\sqrt{2}}{2} & \frac{\sqrt{2}}{4} & \frac{\sqrt{6}}{4} & 0\end{bmatrix}^\mathrm{T}</script><p>两种表达的复合结果应该是一样的，只是乘的顺序不一样</p><script type="math/tex; mode=display">q = q_1 \otimes q_2 = \begin{bmatrix}\frac{\sqrt{3}}{2} \\ 0 \\ 0 \\ \frac{1}{2}\end{bmatrix} \otimes \begin{bmatrix}\frac{\sqrt{2}}{2} \\ \frac{\sqrt{2}}{2} \\ 0 \\ 0\end{bmatrix} = \begin{bmatrix}\frac{\sqrt{6}}{4} \\ \frac{\sqrt{6}}{4} \\ \frac{\sqrt{2}}{4} \\ \frac{\sqrt{2}}{4} \end{bmatrix}</script><script type="math/tex; mode=display">q = q_2^{\prime} \otimes q_1 = \begin{bmatrix}\frac{\sqrt{2}}{2} \\ \frac{\sqrt{2}}{4} \\ \frac{\sqrt{6}}{4} \\ 0\end{bmatrix} \otimes \begin{bmatrix}\frac{\sqrt{3}}{2} \\ 0 \\ 0 \\ \frac{1}{2}\end{bmatrix}  = \begin{bmatrix}\frac{\sqrt{6}}{4} \\ \frac{\sqrt{6}}{4} \\ \frac{\sqrt{2}}{4} \\ \frac{\sqrt{2}}{4} \end{bmatrix}</script><p>坐标系$\mathcal{C}$中的向量$r=\begin{bmatrix}0 &amp; 1 &amp; 0 \end{bmatrix}^\mathrm{T}$在$\mathcal{A}$中的表示为</p><script type="math/tex; mode=display">r^{\prime} = \begin{bmatrix}\frac{\sqrt{6}}{4} \\ \frac{\sqrt{6}}{4} \\ \frac{\sqrt{2}}{4} \\ \frac{\sqrt{2}}{4} \end{bmatrix} \otimes \begin{bmatrix}0 \\ 0 \\ 1 \\ 0 \end{bmatrix} \otimes\begin{bmatrix}\frac{\sqrt{6}}{4} \\ -\frac{\sqrt{6}}{4} \\ -\frac{\sqrt{2}}{4} \\ -\frac{\sqrt{2}}{4} \end{bmatrix} = \begin{bmatrix}0 \\ 0 \\ 0 \\ 1 \end{bmatrix}</script><p>由图可知是正确的</p><p><strong>tips</strong>：四元数乘法的<code>matlab</code>编程实现<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">function result &#x3D; quaternionMultiplication(q1,q2)    result(1) &#x3D; q1(1)*q2(1) - q1(2)*q2(2) - q1(3)*q2(3) - q1(4)*q2(4);    result(2) &#x3D; q1(1)*q2(2) + q1(2)*q2(1) + q1(3)*q2(4) - q1(4)*q2(3);    result(3) &#x3D; q1(1)*q2(3) - q1(2)*q2(4) + q1(3)*q2(1) + q1(4)*q2(2);    result(4) &#x3D; q1(1)*q2(4) + q1(2)*q2(3) - q1(3)*q2(2) + q1(4)*q2(1);end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 多旋翼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>701-二叉搜索树中的插入操作</title>
      <link href="2021/09/12/LeetCode-701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
      <url>2021/09/12/LeetCode-701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-701-Insert-into-a-Binary-Search-Tree"><a href="#LeetCode-701-Insert-into-a-Binary-Search-Tree" class="headerlink" title="LeetCode 701. Insert into a Binary Search Tree"></a>LeetCode 701. Insert into a Binary Search Tree</h2><p>You are given the <strong>root</strong> node of a binary search tree (BST) and a <strong>value</strong> to insert into the tree. Return the <strong>root</strong> node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.</p><p>Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</p><p>Example 1:</p><p><img src="/2021/09/12/LeetCode-701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/701.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [4,2,7,1,3], val &#x3D; 5Output: [4,2,7,1,3,5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>按照二叉搜索树的规则进行遍历， 遇到空节点就是需要插入的位置，新建并返回该节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode* insertIntoBST(TreeNode* root, int val) &#123;    if (!root) &#123;        TreeNode *node &#x3D; new TreeNode(val);        return node;    &#125;    if (val &lt; root-&gt;val) root-&gt;left &#x3D; insertIntoBST(root-&gt;left, val);    else root-&gt;right &#x3D; insertIntoBST(root-&gt;right, val);    return root;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>236-二叉树的最近公共祖先</title>
      <link href="2021/09/11/LeetCode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>2021/09/11/LeetCode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#LeetCode-236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="LeetCode 236. Lowest Common Ancestor of a Binary Tree"></a>LeetCode 236. Lowest Common Ancestor of a Binary Tree</h2><p>Given a binary tree, find the <strong>lowest common ancestor (LCA)</strong> of two given nodes in the tree.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p><p><img src="/2021/09/11/LeetCode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/236.png" alt></p><p>Example 1:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1Output: 3Explanation: The LCA of nodes 5 and 1 is 3.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="method-后序遍历"><a href="#method-后序遍历" class="headerlink" title="method: 后序遍历"></a>method: 后序遍历</h2><p>采用后序遍历，查找两个节点的位置，如果一个节点的左子树和右子树分别包含了p和q，那这个节点就是两个节点的最近公共祖先</p><p>属于有返回值的递归，但需要处理整棵树，因为我们要对返回值进行处理</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;    if (root &#x3D;&#x3D; p || root &#x3D;&#x3D; q || !root) return root;    TreeNode *left &#x3D; lowestCommonAncestor(root-&gt;left, p, q);    TreeNode *right &#x3D; lowestCommonAncestor(root-&gt;right, p, q);    if (left &amp;&amp; right) return root;    else if (!left &amp;&amp; right) return right;    else if (left &amp;&amp; !right) return left;    else return nullptr;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>530-二叉搜索树的最小绝对差</title>
      <link href="2021/09/11/LeetCode-530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/"/>
      <url>2021/09/11/LeetCode-530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-530-Minimum-Absolute-Difference-in-BST"><a href="#LeetCode-530-Minimum-Absolute-Difference-in-BST" class="headerlink" title="LeetCode 530. Minimum Absolute Difference in BST"></a>LeetCode 530. Minimum Absolute Difference in BST</h2><p>Given the root of a Binary Search Tree (BST), return the <strong>minimum absolute difference</strong> between the values of any two different nodes in the tree.</p><p>Example 1:<br><img src="/2021/09/11/LeetCode-530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/530.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [4,2,6,1,3]Output: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><p>相当于遍历一个有序数组，求出两两之前的差值，更新其最小值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode *pre &#x3D; nullptr;int result &#x3D; INT_MAX;void traversal(TreeNode* root) &#123;    if (!root) return;    traversal(root-&gt;left);    if (pre) &#123;        result &#x3D; min(result, root-&gt;val - pre-&gt;val); &#x2F;&#x2F; 更新最小值    &#125;    pre &#x3D; root;    traversal(root-&gt;right);&#125;int getMinimumDifference(TreeNode* root) &#123;    traversal(root);    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>501-二叉搜索树的众数</title>
      <link href="2021/09/10/LeetCode-501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%BC%97%E6%95%B0/"/>
      <url>2021/09/10/LeetCode-501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%BC%97%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-501-Find-Mode-in-Binary-Search-Tree"><a href="#LeetCode-501-Find-Mode-in-Binary-Search-Tree" class="headerlink" title="LeetCode 501. Find Mode in Binary Search Tree"></a>LeetCode 501. Find Mode in Binary Search Tree</h2><p>Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the <strong>most frequently occurred element</strong>) in it.</p><p>If the tree has more than one mode, return them in any order.</p><p><img src="/2021/09/10/LeetCode-501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%BC%97%E6%95%B0/501.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [1,null,2,2]Output: [2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><p>像查找有序数组的众数一样，记录每个数字出现的频率</p><p>记录频率的逻辑：</p><ul><li>前面没有节点，频率置1</li><li>前面节点的值与当前节点的值相同，频率加1</li><li>前面节点的值与当前节点的值不同，频率置1</li></ul><p>数组更新的逻辑：</p><ul><li>如果当前频率与最大频率相等，就插入当前元素</li><li>如果当前频率大于最大频率，就把数组清空，放入当前元素</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; result;TreeNode *pre &#x3D; nullptr;int count, maxCount;void traversal(TreeNode *cur) &#123;    if (!cur) return;    traversal(cur-&gt;left);        if (!pre) count &#x3D; 1;    else if (pre-&gt;val &#x3D;&#x3D; cur-&gt;val) count++;    else count &#x3D; 1;    pre &#x3D; cur;  &#x2F;&#x2F; 注意当前节点处理完就变成了前节点        if (count &#x3D;&#x3D; maxCount) result.push_back(cur-&gt;val);    else if (count &gt; maxCount) &#123;        maxCount &#x3D; count;        result.clear();     &#x2F;&#x2F; 清空数组        result.push_back(cur-&gt;val);    &#125;        traversal(cur-&gt;right);&#125;vector&lt;int&gt; findMode(TreeNode* root) &#123;    traversal(root);    return result;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>108-数组转为二叉搜索树</title>
      <link href="2021/09/07/LeetCode-108-%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>2021/09/07/LeetCode-108-%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree"><a href="#LeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree" class="headerlink" title="LeetCode 108. Convert Sorted Array to Binary Search Tree"></a>LeetCode 108. Convert Sorted Array to Binary Search Tree</h2><p>Given an integer array nums where the elements are sorted in <strong>ascending order</strong>, convert it to a <strong>height-balanced</strong> binary search tree.</p><p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p><p>Example:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [-10,-3,0,5,9]Output: [0,-3,9,-10,null,5] or [0,-10,5,null,-3,null,9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Explanation:</p><figure class="half">    <img src="/2021/09/07/LeetCode-108-%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/108_1.jpg">    <img src="/2021/09/07/LeetCode-108-%E6%95%B0%E7%BB%84%E8%BD%AC%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/108_2.jpg"></figure><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>数组中间节点为根节点，递归处理左边数组和右边数组<br>注意还是左闭右开<code>[begin, end)</code><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode* traversal(vector&lt;int&gt;&amp; nums, int begin, int end) &#123;    if (begin &gt;&#x3D; end) return nullptr;    int mid &#x3D; begin + end &gt;&gt; 1;    TreeNode *root &#x3D; new TreeNode(nums[mid]);    root-&gt;left &#x3D; traversal(nums, begin, mid);    root-&gt;right &#x3D; traversal(nums, mid + 1, end);    return root;&#125;TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123;    return traversal(nums, 0, nums.size());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>98-验证二叉搜索树</title>
      <link href="2021/09/07/LeetCode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>2021/09/07/LeetCode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-98-Validate-Binary-Search-Tree"><a href="#LeetCode-98-Validate-Binary-Search-Tree" class="headerlink" title="LeetCode 98. Validate Binary Search Tree"></a>LeetCode 98. Validate Binary Search Tree</h2><p>Given the root of a binary tree, determine if it is a valid binary search tree (BST).</p><p>A valid BST is defined as follows:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p><p>Example 1:</p><p><img src="/2021/09/07/LeetCode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/98.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [2,1,3]Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>按照中序遍历，就相当于在遍历一个有序数组，如果前面一个元素不小于当前元素，就说明不是有序的<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode *pre &#x3D; nullptr;bool isValidBST(TreeNode* root) &#123;    if (!root) return true;    bool left &#x3D; isValidBST(root-&gt;left);    if (pre &amp;&amp; pre-&gt;val &gt;&#x3D; root-&gt;val) return false;    pre &#x3D; root;    bool right &#x3D; isValidBST(root-&gt;right);    return left &amp;&amp; right;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>700-二叉搜索树中的搜索</title>
      <link href="2021/09/06/LeetCode-700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/"/>
      <url>2021/09/06/LeetCode-700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-700-Search-in-a-Binary-Search-Tree"><a href="#LeetCode-700-Search-in-a-Binary-Search-Tree" class="headerlink" title="LeetCode 700. Search in a Binary Search Tree"></a>LeetCode 700. Search in a Binary Search Tree</h2><p>You are given the root of a <strong>binary search tree</strong> (BST) and an integer val.</p><p>Find the node in the BST that the node’s value <strong>equals val</strong> and return the <strong>subtree rooted with that node</strong>. If such a node does not exist, return null.</p><p><img src="/2021/09/06/LeetCode-700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/700.jpg" alt><br><pre class="line-numbers language-cp" data-language="cp"><code class="language-cp">Input: root &#x3D; [4,2,7,1,3], val &#x3D; 2Output: [2,1,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><p>递归结束条件：如果节点为空，说明没找到，返回空节点；如果等于<code>val</code>，说明找到，也返回当前节点<br>单层逻辑：当前节点值比<code>val</code>大，往左子树找，比<code>val</code>小，往右子树找</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode* searchBST(TreeNode* root, int val) &#123;    if (!root || root-&gt;val &#x3D;&#x3D; val) return root;    if (root-&gt;val &gt; val) return searchBST(root-&gt;left, val);    else return searchBST(root-&gt;right, val);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>617-合并二叉树</title>
      <link href="2021/09/05/LeetCode-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/09/05/LeetCode-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-617-Merge-Two-Binary-Trees"><a href="#LeetCode-617-Merge-Two-Binary-Trees" class="headerlink" title="LeetCode 617. Merge Two Binary Trees"></a>LeetCode 617. Merge Two Binary Trees</h2><p>You are given two binary trees <strong>root1</strong> and <strong>root2</strong>.</p><p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then <strong>sum node values up</strong> as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p><p>Return the merged tree.</p><p>Note: The merging process must start from the root nodes of both trees.</p><p><img src="/2021/09/05/LeetCode-617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/617.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root1 &#x3D; [1,3,2,5], root2 &#x3D; [2,1,3,null,4,null,7]Output: [3,4,5,5,4,null,7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><p>递归结束条件：如果一个节点为空，返回另一棵树的节点，如果他也是空，那这个位置就是空节点<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123;    if (root1 &#x3D;&#x3D; nullptr) return root2;    if (root2 &#x3D;&#x3D; nullptr) return root1;    root1-&gt;val +&#x3D; root2-&gt;val;    root1-&gt;left &#x3D; mergeTrees(root1-&gt;left, root2-&gt;left);    root1-&gt;right &#x3D; mergeTrees(root1-&gt;right, root2-&gt;right);    return root1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>654-最大二叉树</title>
      <link href="2021/09/05/LeetCode-654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/09/05/LeetCode-654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-654-Maximum-Binary-Tree"><a href="#LeetCode-654-Maximum-Binary-Tree" class="headerlink" title="LeetCode 654. Maximum Binary Tree"></a>LeetCode 654. Maximum Binary Tree</h2><p>You are given an integer array <strong>nums</strong> with no duplicates. A <strong>maximum binary tree</strong> can be built recursively from nums using the following algorithm:</p><p>Create a root node whose value is the maximum value in nums.<br>Recursively build the left subtree on the subarray prefix to the left of the maximum value.<br>Recursively build the right subtree on the subarray suffix to the right of the maximum value.<br>Return the maximum binary tree built from nums.</p><p><img src="/2021/09/05/LeetCode-654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/654.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [3,2,1,6,0,5]Output: [6,3,5,null,2,0,null,null,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><p>递归参数：一个数组<br>返回值：二叉树节点指针<br>递归结束条件：如果数组大小为1，返回以该元素构成的节点<br>单层递归逻辑：找到数组最大值，最大值左边的数组构造左子树，最大值右边的数组构造右子树</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;    TreeNode* root &#x3D; new TreeNode(0);    if (nums.size() &#x3D;&#x3D; 1) &#123;        root-&gt;val &#x3D; nums[0];        return root;    &#125;    int maxIndex &#x3D; 0;    int maxValue &#x3D; 0;   &#x2F;&#x2F; 找到最大元素和下标    for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;        if (nums[i] &gt;&#x3D; maxValue) &#123;            maxValue &#x3D; nums[i];            maxIndex &#x3D; i;        &#125;    &#125;    root-&gt;val &#x3D; maxValue;    if (maxIndex &gt; 0) &#123;     &#x2F;&#x2F; 这里确定了数组肯定大于等于1，左闭右开        vector&lt;int&gt; leftNums(nums.begin(), nums.begin() + maxIndex);        root-&gt;left &#x3D; constructMaximumBinaryTree(leftNums);    &#125;    if (maxIndex &lt; nums.size() - 1) &#123;        vector&lt;int&gt; rightNums(nums.begin() + maxIndex + 1, nums.end());        root-&gt;right &#x3D; constructMaximumBinaryTree(rightNums);    &#125;    return root;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>可以直接传下标，不用再构造数组</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode* traversal(vector&lt;int&gt;&amp; nums, int begin, int end) &#123;    if (begin &gt;&#x3D; end) return nullptr;   &#x2F;&#x2F; 最大值在最右边或最左边    int maxIndex &#x3D; begin;    for (int i &#x3D; begin + 1; i &lt; end; i++) &#123;        if (nums[i] &gt; nums[maxIndex]) &#123;            maxIndex &#x3D; i;        &#125;    &#125;    TreeNode* root &#x3D; new TreeNode(nums[maxIndex]);    root-&gt;left &#x3D; traversal(nums, begin, maxIndex);  &#x2F;&#x2F; 左闭右开    root-&gt;right &#x3D; traversal(nums, maxIndex + 1, end);    return root;&#125;TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) &#123;    return traversal(nums, 0, nums.size());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>106-从中序与后序遍历构造二叉树</title>
      <link href="2021/09/03/LeetCode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/09/03/LeetCode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#LeetCode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal"></a>LeetCode 106. Construct Binary Tree from Inorder and Postorder Traversal</h2><p>Given two integer arrays <strong>inorder</strong> and <strong>postorder</strong> where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the <strong>binary tree</strong>.</p><p><img src="/2021/09/03/LeetCode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/106.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: inorder &#x3D; [9,3,15,20,7], postorder &#x3D; [9,15,7,20,3]Output: [3,9,20,null,null,15,7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><p>后序遍历的最后一个元素是根节点，用根节点来切割中序遍历，用 3 把中序遍历切割为[9]和[15,20,7]，以相同的数量切割后序遍历(除去最后一个元素)，切割为[9]和[15,7,20]，以此递归，直到后序遍历数组无元素</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode* traversal(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;    if (postorder.size() &#x3D;&#x3D; 0) return nullptr;    TreeNode* root &#x3D; new TreeNode(postorder.back());    int cutIndex &#x3D; 0;    &#x2F;&#x2F; 找到中序遍历切割点    for (; cutIndex &lt; inorder.size(); cutIndex++) &#123;        if (inorder[cutIndex] &#x3D;&#x3D; postorder.back()) break;    &#125;    &#x2F;&#x2F; 以切割点切割中序遍历 [begin,cut) 和 [cut+1,end)    &#x2F;&#x2F; 不包括切割点    vector&lt;int&gt; leftInorder(inorder.begin(), inorder.begin() + cutIndex);    vector&lt;int&gt; rightInorder(inorder.begin() + cutIndex + 1, inorder.end());    &#x2F;&#x2F; 切割相同数量的后序遍历，不包括最后一个元素    postorder.resize(postorder.size() - 1);    vector&lt;int&gt; leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());    vector&lt;int&gt; rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());    root-&gt;left &#x3D; traversal(leftInorder, leftPostorder);    root-&gt;right &#x3D; traversal(rightInorder, rightPostorder);    return root;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123;    if (inorder.size() &#x3D;&#x3D; 0 || postorder.size() &#x3D;&#x3D; 0) return nullptr;    return traversal(inorder, postorder);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#LeetCode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal"></a>LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal</h2><p>Given two integer arrays <strong>preorder</strong> and <strong>inorder</strong> where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.</p><p><img src="/2021/09/03/LeetCode-106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/106.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]Output: [3,9,20,null,null,15,7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method-递归-1"><a href="#method-递归-1" class="headerlink" title="method: 递归"></a>method: 递归</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode* traversal(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt; &amp;inorder) &#123;    if (preorder.size() &#x3D;&#x3D; 0) return nullptr;    TreeNode* root &#x3D; new TreeNode(preorder[0]);    int cutIndex &#x3D; 0;    for (; cutIndex &lt; inorder.size(); cutIndex++) &#123;        if (inorder[cutIndex] &#x3D;&#x3D; preorder[0]) break;    &#125;    vector&lt;int&gt; leftInorder(inorder.begin(), inorder.begin() + cutIndex);    vector&lt;int&gt; rightInorder(inorder.begin() + cutIndex + 1, inorder.end());    auto begin &#x3D; preorder.begin() + 1;    vector&lt;int&gt; leftPreorder(begin, begin + leftInorder.size());    vector&lt;int&gt; rightPreorder(begin + leftInorder.size(), preorder.end());    root-&gt;left &#x3D; traversal(leftPreorder, leftInorder);    root-&gt;right &#x3D; traversal(rightPreorder, rightInorder);    return root;&#125;TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123;    if (preorder.size() &#x3D;&#x3D; 0 || inorder.size() &#x3D;&#x3D; 0) return nullptr;    return traversal(preorder, inorder);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装库</title>
      <link href="2021/09/01/Linux-%E5%AE%89%E8%A3%85%E5%BA%93/"/>
      <url>2021/09/01/Linux-%E5%AE%89%E8%A3%85%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Eigen"><a href="#Eigen" class="headerlink" title="Eigen"></a>Eigen</h2><p>把Eigen拷贝到外面，就可以直接 <code>#include &lt;Eigen/Dense&gt;</code><br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo cp -r &#x2F;usr&#x2F;local&#x2F;include&#x2F;eigen3&#x2F;Eigen &#x2F;usr&#x2F;local&#x2F;include<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>直接可以编译<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ eigen_text.cpp -o eigen_text<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>不需要再在CMakeLists.txt里面添加库文件</p><h3 id="查看位置"><a href="#查看位置" class="headerlink" title="查看位置"></a>查看位置</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo updatedblocate eigen3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C &quot;1817136760@qq.com&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Generating public&#x2F;private rsa key pair.Enter file in which to save the key (&#x2F;home&#x2F;kavin&#x2F;.ssh&#x2F;id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in &#x2F;home&#x2F;kavin&#x2F;.ssh&#x2F;id_rsa.Your public key has been saved in &#x2F;home&#x2F;kavin&#x2F;.ssh&#x2F;id_rsa.pub.The key fingerprint is:SHA256:P7HncHBT&#x2F;wUO3TcCtkTmGfBohby+UKhwSwomxkMzXsQ 1817136760@qq.comThe key&#39;s randomart image is:+---[RSA 2048]----+|  o.    ..+O     || + E     oO &#x3D;. . ||+ +     .o.&#x3D;..+.o||.B . o ..o   +.oo||+ o &#x3D; o S o o . o||   . o . o &#x3D; .  o||        . * o   .||         . *     ||            .    |+----[SHA256]-----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat .ssh&#x2F;id_rsa.pubssh-rsa AAAAB... 1817136760@qq.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh -T git@github.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Hi kavinwkp! You’ve successfully authenticated, but GitHub does not provide shell access.</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git config --global user.name &quot;kavinwkp&quot;git config --global user.email 1817136760@qq.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git add .git commit -m &quot;***&quot;git push -u origin masterrm -rf test.txt     # 删除本地仓库文件git rm test.txt     # 删除远程仓库文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代理网络连接错误"><a href="#代理网络连接错误" class="headerlink" title="代理网络连接错误"></a>代理网络连接错误</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Failed to receive SOCKS4 connect request ack.git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1080&#39; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu常见问题</title>
      <link href="2021/09/01/Linux-Ubuntu%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>2021/09/01/Linux-Ubuntu%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="bash-和-zsh-切换"><a href="#bash-和-zsh-切换" class="headerlink" title="bash 和 zsh 切换"></a>bash 和 zsh 切换</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chsh -s &#x2F;bin&#x2F;bashchsh -s &#x2F;bin&#x2F;zsh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="tar解压"><a href="#tar解压" class="headerlink" title="tar解压"></a>tar解压</h2><p>单个文件<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zxvf ***.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><p>多个文件<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls model.tar.g* | xargs -n1 tar xzvf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="Python位置"><a href="#Python位置" class="headerlink" title="Python位置"></a>Python位置</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># kavin @ ubuntu in &#x2F;usr&#x2F;lib$ ls -d python*python2.7  python3  python3.6  python3.7  python3.8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># kavin @ ubuntu in &#x2F;usr&#x2F;bin$ ls python*python            python2-config  python3.6-config   python3mpython2           python2-qr      python3.6m         python3m-configpython2.7         python3         python3.6m-config  python-configpython2.7-config  python3.6       python3-config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="pip-出错"><a href="#pip-出错" class="headerlink" title="pip 出错"></a>pip 出错</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">requests.exceptions.InvalidSchema: Missing dependencies for SOCKS support.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解决方法<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unset all_proxy &amp;&amp; unset ALL_PROXYprintenv | grep all_proxy没有输出即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h3 id="pip3-install-—user"><a href="#pip3-install-—user" class="headerlink" title="pip3 install —user "></a>pip3 install —user <package_name></package_name></h3><p>功能包会被安装在<code>~/.local/lib/python3.6/site-packages</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># kavin @ ubuntu in ~&#x2F;.local&#x2F;lib&#x2F;python3.6&#x2F;site-packages$ lsem.py                       numpy                     pyparsing-2.4.7.dist-infoempy-3.3.4.dist-info        numpy-1.19.5.dist-info    pyparsing.pyjinja2                      numpy.libs                tomlJinja2-3.0.1.dist-info      packaging                 toml-0.10.2.dist-infomarkupsafe                  packaging-20.9.dist-infoMarkupSafe-2.0.1.dist-info  __pycache__<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><h3 id="错误方式"><a href="#错误方式" class="headerlink" title="错误方式"></a>错误方式</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim ~&#x2F;.zshrcexport PKG_CONFIG_PATH&#x3D;~&#x2F;Library&#x2F;opencv-3.3.1&#x2F;build&#x2F;installed&#x2F;lib&#x2F;$ export | grep LD_LIBRARY_PATHLD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;kavin&#x2F;Library&#x2F;opencv-3.3.1&#x2F;build&#x2F;installed&#x2F;lib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原来的<code>LD_LIBRARY_PATH</code>会被<strong>覆盖</strong></p><h3 id="正确方式"><a href="#正确方式" class="headerlink" title="正确方式"></a>正确方式</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim ~&#x2F;.zshrcexport LD_LIBRARY_PATH&#x3D;~&#x2F;Library&#x2F;opencv-3.3.1&#x2F;build&#x2F;installed&#x2F;lib:$LD_LIBRARY_PATH$ export | grep LD_LIBRARY_PATHLD_LIBRARY_PATH&#x3D;&#x2F;home&#x2F;kavin&#x2F;Library&#x2F;opencv-3.3.1&#x2F;build&#x2F;installed&#x2F;lib:&#x2F;home&#x2F;kavin&#x2F;ROSProjects&#x2F;Prometheus&#x2F;devel&#x2F;lib:&#x2F;opt&#x2F;ros&#x2F;melodic&#x2F;lib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>513-找树左下角的值</title>
      <link href="2021/07/19/LeetCode-513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/"/>
      <url>2021/07/19/LeetCode-513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-513-Find-Bottom-Left-Tree-Value"><a href="#LeetCode-513-Find-Bottom-Left-Tree-Value" class="headerlink" title="LeetCode 513. Find Bottom Left Tree Value"></a>LeetCode 513. Find Bottom Left Tree Value</h2><p>Given the root of a binary tree, return the leftmost value in the last row of the tree.</p><p>Example 1:</p><p><img src="/2021/07/19/LeetCode-513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/513.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [2,1,3]Output: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method-1-回溯"><a href="#method-1-回溯" class="headerlink" title="method 1: 回溯"></a>method 1: 回溯</h2><p>需要找到最底层的左边节点，用先序遍历，如果当前深度比记录的深度大，就更新深度和结果值<br>因为是遍历整棵树，所以不需要返回值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int maxDepth &#x3D; INT_MIN; &#x2F;&#x2F; 记录最大深度int ret;void traversal(TreeNode *root, int depth) &#123;    if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;        if (depth &gt; maxDepth) &#123;            maxDepth &#x3D; depth;            ret &#x3D; root-&gt;val;        &#125;        return;    &#125;    if (root-&gt;left) traversal(root-&gt;left, depth + 1);    if (root-&gt;right) traversal(root-&gt;right, depth + 1);&#125;int findBottomLeftValue(TreeNode* root) &#123;    traversal(root, 0);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-层序遍历"><a href="#method-2-层序遍历" class="headerlink" title="method 2: 层序遍历"></a>method 2: 层序遍历</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int findBottomLeftValue(TreeNode* root) &#123;    queue&lt;TreeNode*&gt; q;    if (!root) return 0;    int res &#x3D; 0;    q.push(root);    while (!q.empty()) &#123;        int size &#x3D; q.size();        for (int i &#x3D; 0; i &lt; size; ++i) &#123;            TreeNode *top &#x3D; q.front();            q.pop();            if (i &#x3D;&#x3D; 0) res &#x3D; top-&gt;val; &#x2F;&#x2F; 记录每层第一个节点            if (top-&gt;left) q.push(top-&gt;left);            if (top-&gt;right) q.push(top-&gt;right);        &#125;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多旋翼文献</title>
      <link href="2021/07/18/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E6%97%A0%E4%BA%BA%E6%9C%BA%E6%96%87%E7%8C%AE/"/>
      <url>2021/07/18/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E6%97%A0%E4%BA%BA%E6%9C%BA%E6%96%87%E7%8C%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="无人机文献"><a href="#无人机文献" class="headerlink" title="无人机文献"></a>无人机文献</h2><h4 id="记录一些好的句子，提高英语表达能力。"><a href="#记录一些好的句子，提高英语表达能力。" class="headerlink" title="记录一些好的句子，提高英语表达能力。"></a>记录一些好的句子，提高英语表达能力。</h4><ol><li>However, most research fails to <strong>account</strong> adequately <strong>for</strong> limited energy on each UAV, which <strong>involves in</strong> many factors such as different operations for performing a task and various movement patterns besides the distance and turns that have been commonly considered.<br>然而，大多数研究未能充分<strong>考虑</strong>每架无人机上有限的能量，这<strong>涉及</strong>许多因素，例如执行任务的不同操作以及除了通常考虑的距离和转弯之外的各种运动模式。</li></ol><ol><li>By contrast, we conduct a series of experiments to obtain the energy model of UAVs.<br>相比之下，我们进行了一系列实验来获得无人机的能量模型。</li></ol><ol><li>Unmanned aerial vehicles (UAVs) are receiving increased attention by humanitarian organizations as they can help overcoming <strong>last-mile distribution problems</strong>.<br>无人驾驶飞行器越来越受到人道主义组织的关注，因为它们有助于克服<strong>最后一英里的分配问题</strong></li></ol><ol><li>Energy–aware drone routing problems are considered in [8,11,28] where the energy consumption of the drone is assumed to depend on one or more of the flight related parameters: payload, speed, distance and altitude.<br>在[8,11,28]中考虑了能量感知无人机航路问题，其中假设无人机的能量消耗取决于一个或多个飞行相关参数：有效载荷、速度、距离和高度。</li></ol><ol><li>We <strong>mathematically</strong> derive and <strong>experimentally</strong> validate an energy consumption model for multirotor drones, <strong>demonstrating</strong> that energy consumption varies approximately linearly with payload and battery weight.<br>我们<strong>从数学上</strong>推导并通过实验验证了多旋翼无人机的能耗模型，证明了能耗随有效载荷和电池重量近似线性变化。</li></ol><ol><li>Predicting the performance of a specific UAV, in terms of ability to complete a mission, is a challenging task, since a number of variables are to be considered such as the UAV payload, path direction, waypoint spacing in a three- dimensional space, etc. Nevertheless, having realistic models to predict the performance of the UAV is fundamental to the success of these applications.<br>从无人机完成任务的能力来看，预测特定无人机的性能是一项具有挑战性的任务，因为需要考虑许多变量，如无人机有效载荷、路径方向、在三维空间中的路径点间距等。然而，拥有真实的模型来预测无人机的性能是这些应用成功的基础。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 多旋翼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>112-路径总和</title>
      <link href="2021/07/17/LeetCode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/"/>
      <url>2021/07/17/LeetCode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-112-Path-Sum"><a href="#LeetCode-112-Path-Sum" class="headerlink" title="LeetCode 112. Path Sum"></a>LeetCode 112. Path Sum</h2><p>Given the root of a binary tree and an integer targetSum, return true if the tree has a <strong>root-to-leaf</strong> path such that adding up all the values along the path equals targetSum.</p><p>A leaf is a node with no children.</p><p>Example 1:<br><img src="/2021/07/17/LeetCode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/112.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum &#x3D; 22Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-回溯"><a href="#method-回溯" class="headerlink" title="method: 回溯"></a>method: 回溯</h2><p>这里不需要遍历整棵树，只要找到一个解就可以返回，所以需要返回值</p><p><img src="/2021/07/17/LeetCode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/00.png" alt></p><p>这里是先判断左右节点非空才递归，也可以不管空不空先递归，再判断节点是否为空<br>用减法可以少个参数<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool traversal(TreeNode* cur, int count) &#123;    if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count &#x3D;&#x3D; cur-&gt;val) return true;    if (cur-&gt;left) &#123;        if (traversal(cur-&gt;left, count - cur-&gt;val))             return true;    &#125;    if (cur-&gt;right) &#123;        if (traversal(cur-&gt;right, count - cur-&gt;val))             return true;    &#125;    return false;&#125;bool hasPathSum(TreeNode* root, int targetSum) &#123;    if (!root) return false;    return traversal(root, targetSum);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>先递归再判空</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool dfs(TreeNode* root, int sum, int targetSum) &#123;    if (!root) return false;    if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;        if (sum + root-&gt;val &#x3D;&#x3D; targetSum) return true;    &#125;    bool leftSum &#x3D; dfs(root-&gt;left, sum + root-&gt;val, targetSum);    bool rightSum &#x3D; dfs(root-&gt;right, sum + root-&gt;val, targetSum);    return (leftSum || rightSum);   &#x2F;&#x2F; 需要遍历整棵树&#125;bool hasPathSum(TreeNode* root, int targetSum) &#123;    return dfs(root, 0, targetSum);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-113-Path-Sum-II"><a href="#LeetCode-113-Path-Sum-II" class="headerlink" title="LeetCode 113. Path Sum II"></a>LeetCode 113. Path Sum II</h2><p>Given the root of a binary tree and an integer <strong>targetSum</strong>, return all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.</p><p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.</p><p><img src="/2021/07/17/LeetCode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/113.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22Output: [[5,4,11,2],[5,8,4,5]]Explanation: There are two paths whose sum equals targetSum:5 + 4 + 11 + 2 &#x3D; 225 + 8 + 4 + 5 &#x3D; 22<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-回溯-1"><a href="#method-回溯-1" class="headerlink" title="method: 回溯"></a>method: 回溯</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; res;vector&lt;int&gt; path;void traversal(TreeNode* root, int sum) &#123;    if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum &#x3D;&#x3D; root-&gt;val) &#123;        res.push_back(path);        return;    &#125;    if (root-&gt;left) &#123;        path.push_back(root-&gt;left-&gt;val);        traversal(root-&gt;left, sum - root-&gt;val);        path.pop_back();    &#125;    if (root-&gt;right) &#123;        path.push_back(root-&gt;right-&gt;val);        traversal(root-&gt;right, sum - root-&gt;val);        path.pop_back();    &#125;&#125; vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) &#123;    if (!root) return res;    path.push_back(root-&gt;val);    traversal(root, targetSum);    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多旋翼</title>
      <link href="2021/07/16/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC/"/>
      <url>2021/07/16/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="4-反扭力与偏航运动"><a href="#4-反扭力与偏航运动" class="headerlink" title="4. 反扭力与偏航运动"></a>4. 反扭力与偏航运动</h2><p>基本原理：作用力与反作用力<br>多旋翼的动力系来源于高速电机带动螺旋桨转动而产生的拉力。假设电机带动螺旋桨顺时针运动，由于桨叶螺距对空气作用的效果，会产生一个<strong>向下的推力</strong>与<strong>水平方向的推力</strong>，如下图：<br><img src="/2021/07/16/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC/4-1.png" alt></p><p>其中向下的推力是桨对空气的作用力，根据反作用力原理，空气就会对桨产生一个向上的推力。这就是空气对桨进而作用到机身垂直方向的拉力。而水平方向对空气的推力同样会产生一个空气对桨的反作用力，方向与作用力相反，其作用到多旋翼的轴臂上，就产生了我们所说的反扭力，也称<font color="red" size="4">反扭力矩</font>。</p><p>根据多旋翼结构上的对称性，假设四个电机转动方向同，它们都是顺时针转动，那么就会对四个轴臂产生逆时针的四个反扭力，而这四个力作用在轴臂上时，使得机身会以自身中心为转轴进行旋转。就是说这四个反扭力的方向都是垂直于轴臂的，也就是我们通常所说的力矩。<br><img src="/2021/07/16/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC/4-2.png" alt></p><p>为了克服无人机的自旋，我们可以让对角线上的两个电机转动方向相同，而让相邻的两个电机转动方向相反，使它们所产生的反扭矩相互抵消，无人机就不会再出现自旋了。如下图：<br><img src="/2021/07/16/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC/4-3.png" alt></p><p>但是我们并不希望永远消除反扭矩，而是希望可以通过控制使其产生偏航运动，于是我们可以根据需要适当地同时增加电机0和电机2的转速，并同时减小电机1和电机3的转速。这样飞机整体向上的拉力不变，而电机0和电机2产生的反扭矩大于电机1和电机3产生的反扭矩，所以飞机会按逆时针方向作偏航运动。如下图：<br><img src="/2021/07/16/%E5%A4%9A%E6%97%8B%E7%BF%BC-%E5%A4%9A%E6%97%8B%E7%BF%BC/4-4.png" alt></p><p>而对于偏航运动<code>(yaw)</code>的加速度，也就是偏航角加速度$\ddot{\psi}$等于力矩$M$除以转动惯量$I$，即：</p><script type="math/tex; mode=display">\ddot{\psi}=\frac{M}{I}</script>]]></content>
      
      
      <categories>
          
          <category> 多旋翼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode运行C++</title>
      <link href="2021/07/16/ROS-VSCode%E8%BF%90%E8%A1%8CC/"/>
      <url>2021/07/16/ROS-VSCode%E8%BF%90%E8%A1%8CC/</url>
      
        <content type="html"><![CDATA[<h2 id="VS-Code-调试-C"><a href="#VS-Code-调试-C" class="headerlink" title="VS Code 调试 C++"></a>VS Code 调试 C++</h2><p><code>launch</code>文件用来调试，<code>tasks</code>文件用于在调试前生成可执行文件</p><h3 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">&#123;</span>    <span class="token string">"version"</span><span class="token operator">:</span> <span class="token string">"0.2.0"</span><span class="token punctuation">,</span>    <span class="token string">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"g++ - Build and debug active file"</span><span class="token punctuation">,</span>            <span class="token string">"type"</span><span class="token operator">:</span> <span class="token string">"cppdbg"</span><span class="token punctuation">,</span>            <span class="token string">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>            <span class="token string">"program"</span><span class="token operator">:</span> <span class="token string">"$&#123;fileDirname&#125;/build/main"</span><span class="token punctuation">,</span> <span class="token comment">// 调试的文件位置</span>            <span class="token string">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token string">"stopAtEntry"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token string">"cwd"</span><span class="token operator">:</span> <span class="token string">"$&#123;fileDirname&#125;"</span><span class="token punctuation">,</span>            <span class="token string">"environment"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token string">"externalConsole"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token string">"MIMode"</span><span class="token operator">:</span> <span class="token string">"gdb"</span><span class="token punctuation">,</span>            <span class="token string">"setupCommands"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token punctuation">&#123;</span>                    <span class="token string">"description"</span><span class="token operator">:</span> <span class="token string">"Enable pretty-printing for gdb"</span><span class="token punctuation">,</span>                    <span class="token string">"text"</span><span class="token operator">:</span> <span class="token string">"-enable-pretty-printing"</span><span class="token punctuation">,</span>                    <span class="token string">"ignoreFailures"</span><span class="token operator">:</span> <span class="token boolean">true</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token string">"preLaunchTask"</span><span class="token operator">:</span> <span class="token string">"Build"</span><span class="token punctuation">,</span>   <span class="token comment">// 跟tasks.json的label一样</span>            <span class="token string">"miDebuggerPath"</span><span class="token operator">:</span> <span class="token string">"/usr/bin/gdb"</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">&#123;</span>    <span class="token string">"version"</span><span class="token operator">:</span> <span class="token string">"2.0.0"</span><span class="token punctuation">,</span>    <span class="token string">"options"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"cwd"</span><span class="token operator">:</span> <span class="token string">"$&#123;workspaceFolder&#125;/build"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token string">"tasks"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token string">"type"</span><span class="token operator">:</span> <span class="token string">"shell"</span><span class="token punctuation">,</span>            <span class="token string">"label"</span><span class="token operator">:</span> <span class="token string">"cmake"</span><span class="token punctuation">,</span>            <span class="token string">"command"</span><span class="token operator">:</span> <span class="token string">"cmake"</span><span class="token punctuation">,</span>            <span class="token string">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">".."</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>            <span class="token string">"label"</span><span class="token operator">:</span> <span class="token string">"make"</span><span class="token punctuation">,</span>            <span class="token string">"group"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token string">"kind"</span><span class="token operator">:</span> <span class="token string">"build"</span><span class="token punctuation">,</span>                <span class="token string">"isDefault"</span><span class="token operator">:</span> <span class="token boolean">true</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token string">"command"</span><span class="token operator">:</span> <span class="token string">"make"</span><span class="token punctuation">,</span>            <span class="token string">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>            <span class="token string">"label"</span><span class="token operator">:</span> <span class="token string">"Build"</span><span class="token punctuation">,</span>            <span class="token string">"dependsOrder"</span><span class="token operator">:</span> <span class="token string">"sequence"</span><span class="token punctuation">,</span>            <span class="token string">"dependsOn"</span><span class="token operator">:</span><span class="token punctuation">[</span>                <span class="token string">"cmake"</span><span class="token punctuation">,</span>                <span class="token string">"make"</span>            <span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<strong>CMakeLists.txt</strong>里面要设置为<strong>Debug</strong>模式</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">CMAKE_BUILD_TYPE</span> Debug<span class="token punctuation">)</span>     <span class="token comment">// 要启用F5调试一定要用这一条</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code运行ROS</title>
      <link href="2021/07/16/ROS-VSCode%E8%BF%90%E8%A1%8CROS/"/>
      <url>2021/07/16/ROS-VSCode%E8%BF%90%E8%A1%8CROS/</url>
      
        <content type="html"><![CDATA[<h2 id="ROS初始化"><a href="#ROS初始化" class="headerlink" title="ROS初始化"></a>ROS初始化</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo vim &#x2F;etc&#x2F;hosts185.199.108.133 raw.githubusercontent.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo vim &#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;rosdep2&#x2F;sources_list.pyurl&#x3D;&quot;https:&#x2F;&#x2F;ghproxy.com&#x2F;&quot;+url<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/07/16/ROS-VSCode%E8%BF%90%E8%A1%8CROS/1.png" alt></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo vim &#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;rosdistro&#x2F;__init__.pyDEFAULT_INDEX_URL &#x3D; &#39;https:&#x2F;&#x2F;ghproxy.com&#x2F;https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ros&#x2F;rosdistro&#x2F;master&#x2F;index-v4.yaml&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/07/16/ROS-VSCode%E8%BF%90%E8%A1%8CROS/2.png" alt></p><h2 id="VS-Code-for-ROS"><a href="#VS-Code-for-ROS" class="headerlink" title="VS Code for ROS"></a>VS Code for ROS</h2><p>新建工作空间和功能包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir -p ~&#x2F;catkin_ws&#x2F;srccd ~&#x2F;catkin_ws&#x2F;srccatkin_init_workspacecd ..catkin_makecd srccatkin_create_pkg &lt;功能包名称&gt; std_msgs rospy roscpp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加json文件"><a href="#添加json文件" class="headerlink" title="添加json文件"></a>添加json文件</h3><p>添加<code>c_cpp_properties.json</code>，找到<code>ROS</code>头文件目录</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">&#123;</span>  <span class="token string">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token string">"browse"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"databaseFilename"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>        <span class="token string">"limitSymbolsToIncludedHeaders"</span><span class="token operator">:</span> <span class="token boolean">true</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token string">"includePath"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"$&#123;catkin_ws&#125;/devel/include/**"</span><span class="token punctuation">,</span>        <span class="token string">"/opt/ros/melodic/include/**"</span><span class="token punctuation">,</span>        <span class="token string">"/usr/include/**"</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"ROS"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"version"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>添加<code>settings.json</code>文件，找到<code>python</code>库<br><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token punctuation">&#123;</span>    <span class="token string">"python.autoComplete.extraPaths"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"$&#123;catkin_ws&#125;/devel/lib/python2.7/dist-packages"</span><span class="token punctuation">,</span>        <span class="token string">"/opt/ros/melodic/lib/python2.7/dist-packages"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token string">"python.analysis.extraPaths"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"$&#123;catkin_ws&#125;/devel/lib/python2.7/dist-packages"</span><span class="token punctuation">,</span>        <span class="token string">"/opt/ros/melodic/lib/python2.7/dist-packages"</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token string">"files.associations"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string">"iostream"</span><span class="token operator">:</span> <span class="token string">"cpp"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="编译cv-bridge"><a href="#编译cv-bridge" class="headerlink" title="编译cv_bridge"></a>编译cv_bridge</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install python-catkin-tools python3-dev python3-catkin-pkg-modules python3-numpy python3-yaml ros-melodic-cv-bridgemkdir -p catkin_ws&#x2F;srccd catkin_wscatkin config -DPYTHON_EXECUTABLE&#x3D;&#x2F;usr&#x2F;bin&#x2F;python3 -DPYTHON_INCLUDE_DIR&#x3D;&#x2F;usr&#x2F;include&#x2F;python3.6m -DPYTHON_LIBRARY&#x3D;&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libpython3.6m.sogit clone https:&#x2F;&#x2F;github.com&#x2F;ros-perception&#x2F;vision_opencv.git src&#x2F;vision_opencvapt-cache show ros-melodic-cv-bridge | grep Versioncd src&#x2F;vision_opencv&#x2F;git checkout 1.13.0cd ..&#x2F;..&#x2F;catkin build 或者 catkin build cv_bridgesource ~&#x2F;catkin_ws&#x2F;devel&#x2F;setup.zsh --extend # --extend 参数的作用是让这次的路径配置不影响之前配置好的路径，否则这一次source会覆盖掉之前配置的路径。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Octomap</title>
      <link href="2021/07/16/ROS-Octomap/"/>
      <url>2021/07/16/ROS-Octomap/</url>
      
        <content type="html"><![CDATA[<h2 id="Octomap"><a href="#Octomap" class="headerlink" title="Octomap"></a>Octomap</h2><p>可以将点云数据转换为栅格数据<code>(OccupancyGrid)</code></p><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><p>加载点云数据并发布话题<code>/pointcloud/output</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;sstream&gt;#include &lt;vector&gt;#include &lt;ros&#x2F;ros.h&gt;#include &lt;pcl&#x2F;point_cloud.h&gt;#include &lt;pcl_conversions&#x2F;pcl_conversions.h&gt;#include &lt;sensor_msgs&#x2F;PointCloud2.h&gt;#include &lt;pcl&#x2F;io&#x2F;pcd_io.h&gt;using namespace std;int main(int argc, char **argv)&#123;    std::string topic, path, frame_id;    int hz &#x3D; 5;    ros::init(argc, argv, &quot;publish_pointcloud&quot;);    ros::NodeHandle nh;    nh.param&lt;std::string&gt;(&quot;path&quot;, path, &quot;&#x2F;home&#x2F;kavin&#x2F;ROSProjects&#x2F;ros_learning&#x2F;catkin_ws_cv&#x2F;src&#x2F;publish_pointcloud&#x2F;data&#x2F;test2.pcd&quot;);    nh.param&lt;std::string&gt;(&quot;frame_id&quot;, frame_id, &quot;camera&quot;);    nh.param&lt;std::string&gt;(&quot;topic&quot;, topic, &quot;&#x2F;pointcloud&#x2F;output&quot;);    nh.param&lt;int&gt;(&quot;hz&quot;, hz, 5);    ros::Publisher pcl_pub &#x3D; nh.advertise&lt;sensor_msgs::PointCloud2&gt;(topic, 10);    pcl::PointCloud&lt;pcl::PointXYZ&gt; cloud;    sensor_msgs::PointCloud2 output;    pcl::io::loadPCDFile(path, cloud);    pcl::toROSMsg(cloud, output); &#x2F;&#x2F; 转换成ROS下的数据类型, 最终通过topic发布    output.header.stamp &#x3D; ros::Time::now();    output.header.frame_id &#x3D; frame_id;    cout &lt;&lt; &quot;path &#x3D; &quot; &lt;&lt; path &lt;&lt; endl;    cout &lt;&lt; &quot;frame_id &#x3D; &quot; &lt;&lt; frame_id &lt;&lt; endl;    cout &lt;&lt; &quot;topic &#x3D; &quot; &lt;&lt; topic &lt;&lt; endl;    cout &lt;&lt; &quot;hz &#x3D; &quot; &lt;&lt; hz &lt;&lt; endl;    ros::Rate loop_rate(hz);    while (ros::ok())    &#123;        pcl_pub.publish(output);        ros::spinOnce();        loop_rate.sleep();    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="launch文件"><a href="#launch文件" class="headerlink" title="launch文件"></a>launch文件</h2><h3 id="启动octomap-server节点"><a href="#启动octomap-server节点" class="headerlink" title="启动octomap_server节点"></a>启动octomap_server节点</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&lt;launch&gt;  &lt;node pkg&#x3D;&quot;octomap_server&quot; type&#x3D;&quot;octomap_server_node&quot; name&#x3D;&quot;octomap_server&quot;&gt;    &lt;!-- resolution in meters per pixel --&gt;    &lt;param name&#x3D;&quot;resolution&quot; value&#x3D;&quot;0.05&quot; &#x2F;&gt;    &lt;!-- name of the fixed frame, needs to be &quot;&#x2F;map&quot; for SLAM --&gt;    &lt;param name&#x3D;&quot;frame_id&quot; type&#x3D;&quot;string&quot; value&#x3D;&quot;&#x2F;camera&quot; &#x2F;&gt;    &lt;!-- max range &#x2F; depth resolution of the kinect in meter --&gt;    &lt;param name&#x3D;&quot;sensor_model&#x2F;max_range&quot; value&#x3D;&quot;100.0&quot; &#x2F;&gt;    &lt;param name&#x3D;&quot;latch&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;    &lt;!-- max&#x2F;min height for occupancy map, should be in meters --&gt;    &lt;param name&#x3D;&quot;pointcloud_max_z&quot; value&#x3D;&quot;1000&quot; &#x2F;&gt;    &lt;param name&#x3D;&quot;pointcloud_min_z&quot; value&#x3D;&quot;0&quot; &#x2F;&gt;    &lt;!-- topic from where pointcloud2 messages are subscribed --&gt;    &lt;remap from&#x3D;&quot;&#x2F;cloud_in&quot; to&#x3D;&quot;&#x2F;pointcloud&#x2F;output&quot; &#x2F;&gt;   &lt;&#x2F;node&gt;&lt;&#x2F;launch&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="启动点云发布节点"><a href="#启动点云发布节点" class="headerlink" title="启动点云发布节点"></a>启动点云发布节点</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;launch&gt;   &lt;node name&#x3D;&quot;publish_pointcloud&quot; pkg&#x3D;&quot;publish_pointcloud&quot; type&#x3D;&quot;publish_pointcloud&quot;&gt;    &lt;param name&#x3D;&quot;path&quot; value&#x3D;&quot;$(find publish_pointcloud)&#x2F;data&#x2F;test.pcd&quot; type&#x3D;&quot;str&quot; &#x2F;&gt;    &lt;param name&#x3D;&quot;frame_id&quot; value&#x3D;&quot;camera&quot; type&#x3D;&quot;str&quot; &#x2F;&gt;    &lt;param name&#x3D;&quot;topic&quot; value&#x3D;&quot;&#x2F;pointcloud&#x2F;output&quot; type&#x3D;&quot;str&quot; &#x2F;&gt;    &lt;param name&#x3D;&quot;hz&quot; value&#x3D;&quot;2&quot; type&#x3D;&quot;int&quot; &#x2F;&gt;  &lt;&#x2F;node&gt;  &lt;!-- Load ocotmap launch --&gt;  &lt;include file&#x3D;&quot;$(find publish_pointcloud)&#x2F;launch&#x2F;octomaptransform.launch&quot; &#x2F;&gt;  &lt;!-- RViz --&gt;  &lt;node pkg&#x3D;&quot;rviz&quot; type&#x3D;&quot;rviz&quot; name&#x3D;&quot;$(anon rviz)&quot; respawn&#x3D;&quot;false&quot; output&#x3D;&quot;screen&quot; args&#x3D;&quot;-d $(find publish_pointcloud)&#x2F;rviz&#x2F;OctomapShow.rviz&quot;&#x2F;&gt;&lt;&#x2F;launch&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cmake_minimum_required(VERSION 2.8.3)project(publish_pointcloud)find_package(catkin REQUIRED COMPONENTS    roscpp    rospy    std_msgs    rostime     sensor_msgs     message_filters )set(OpenCV_DIR &quot;~&#x2F;Library&#x2F;opencv-3.3.1&#x2F;build&quot;)find_package(OpenCV REQUIRED)find_package(OpenMP)find_package(PCL REQUIRED)catkin_package()include_directories(    $&#123;catkin_INCLUDE_DIRS&#125;    $&#123;OpenCV_INCLUDE_DIRS&#125;    $&#123;PCL_INCLUDE_DIRS&#125;)&#x2F;&#x2F; 生成可执行文件add_executable(publish_pointcloud src&#x2F;publish_pointcloud.cpp)&#x2F;&#x2F; 链接库文件target_link_libraries(publish_pointcloud    $&#123;catkin_LIBRARIES&#125;    $&#123;OpenCV_LIBRARIES&#125;    $&#123;PCL_LIBRARIES&#125;)install(TARGETS publish_pointcloudRUNTIME DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>404-左叶子之和</title>
      <link href="2021/07/15/LeetCode-404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/"/>
      <url>2021/07/15/LeetCode-404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-404-Sum-of-Left-Leaves"><a href="#LeetCode-404-Sum-of-Left-Leaves" class="headerlink" title="LeetCode 404. Sum of Left Leaves"></a>LeetCode 404. Sum of Left Leaves</h2><p>Given the root of a binary tree, return the sum of all <strong>left leaves</strong>.</p><p>Example 1:<br><img src="/2021/07/15/LeetCode-404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/404.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [3,9,20,null,null,15,7]Output: 24Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><p>左叶子的判断：当前节点的左节点不为空，左节点的左节点和右节点为空</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int sumOfLeftLeaves(TreeNode* root) &#123;    if (root &#x3D;&#x3D; nullptr) return 0;    int leftSum &#x3D; sumOfLeftLeaves(root-&gt;left);    int rightSum &#x3D; sumOfLeftLeaves(root-&gt;right);    int midSum &#x3D; 0;    if (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right)         midSum &#x3D; root-&gt;left-&gt;val;    return midSum + leftSum + rightSum;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>257-二叉树的所有路径</title>
      <link href="2021/07/14/LeetCode-257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
      <url>2021/07/14/LeetCode-257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-257-Binary-Tree-Paths"><a href="#LeetCode-257-Binary-Tree-Paths" class="headerlink" title="LeetCode 257. Binary Tree Paths"></a>LeetCode 257. Binary Tree Paths</h2><p>Given the root of a binary tree, return all <strong>root-to-leaf</strong> paths in any order.</p><p>A leaf is a node with no children.</p><p>Example 1:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [1,2,3,null,5]   1 &#x2F;   \2     3 \  5Output: [&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-回溯"><a href="#method-回溯" class="headerlink" title="method: 回溯"></a>method: 回溯</h2><p>用<code>vector</code>存储路径和回溯比较方便，后面再转成<code>string</code></p><ul><li>函数参数和返回值：前序遍历的当前节点，存储路径的path和存储最终结果的ret，都要是引用，无返回值</li><li>递归结束条件：节点为叶子节点</li><li>左右子树非空才进行递归，回溯时要把左右子树的节点<code>pop</code>出来</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void traversal(TreeNode* root, vector&lt;int&gt;&amp; path, vector&lt;string&gt;&amp; ret) &#123;    path.push_back(root-&gt;val);  &#x2F;&#x2F; 已经保证节点非空    if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;        string s;        for (int i &#x3D; 0; i &lt; path.size() - 1; ++i) &#123;            s +&#x3D; to_string(path[i]);            s +&#x3D; &quot;-&gt;&quot;;        &#125;        s +&#x3D; to_string(path.back());        ret.push_back(s);        return;    &#125;    if (root-&gt;left) &#123;        traversal(root-&gt;left, path, ret);        path.pop_back();    &#125;    if (root-&gt;right) &#123;        traversal(root-&gt;right, path, ret);        path.pop_back();    &#125;&#125;vector&lt;string&gt; binaryTreePaths(TreeNode* root) &#123;    vector&lt;int&gt; path;    vector&lt;string&gt; ret;    traversal(root, path, ret);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.4-函数重载</title>
      <link href="2021/07/13/C-Primer-6-4-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
      <url>2021/07/13/C-Primer-6-4-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同，称之为<strong>重载(overload)函数</strong>。</p><p><strong>tips</strong>：</p><ul><li>不允许两个函数除了返回类型外其他所有的要素都相同。</li><li>一个拥有顶层<code>const</code>的形参无法和另一个没有顶层<code>const</code>的形参区分开来。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Record lookup(Phone);Record lookup(const Phone);  &#x2F;&#x2F; 一样的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Record lookup(Account&amp;);Record lookup(const Account&amp;);  &#x2F;&#x2F; 新函数，作用于常量引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意</strong>：当传递一个<strong>非常量对象</strong>或者<strong>非常量对象的指针</strong>时，编译器会优先选用<strong>非常量</strong>版本的函数</p><h3 id="const-cast和重载"><a href="#const-cast和重载" class="headerlink" title="const_cast和重载"></a>const_cast和重载</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const string&amp; shorterString(const string&amp; s1, const string&amp; s2) &#123;    return s1.size() &lt; s2.size() ? s1 : s2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这里返回常量引用，当传入非常量对象时，需要一个非常量的版本，返回非常量引用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string&amp; shorterString(string&amp; s1, string&amp; s2) &#123;    auto&amp; r &#x3D; shorterString(const_cast&lt;const string&amp;&gt; s1, const_cast&lt;const string&amp;&gt; s2);    return const_cast&lt;string&amp;&gt; (r);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>先把非常量引用转为常量引用，调用常量引用版本的函数，再把返回的常量结果转为非常量</p><h2 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h2><h3 id="6-5-1-默认实参"><a href="#6-5-1-默认实参" class="headerlink" title="6.5.1 默认实参"></a>6.5.1 默认实参</h3><p><strong>注意</strong>：一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值</p><p>在给定的作用域中一个形参只能被赋予一次默认实参，不能重复声明</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string screen(int, int, char &#x3D; &#39; &#39;);string screen(int, int, char &#x3D; &#39;*&#39;);    &#x2F;&#x2F; 错误：重复声明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>局部变量不能作为默认实参，只要表达式的类型能转换为形参所需要的类型，该表达式就能作为默认实参<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int ht();int wd &#x3D; 80;char def &#x3D; &#39; &#39;;     &#x2F;&#x2F; 全局变量string screen(int &#x3D; ht(), int &#x3D; wd, char &#x3D; def);string window &#x3D; screen();   &#x2F;&#x2F; 调用screen(ht(), 80, &#39; &#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>如果是在函数作用域里面</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void fun2() &#123;    def &#x3D; &#39;*&#39;;  &#x2F;&#x2F; 修改了全局变量def    int wd &#x3D; 100;   &#x2F;&#x2F; 局部变量不影响全局变量    window &#x3D; screen();  &#x2F;&#x2F; 调用screen(ht(), 80, &#39;*&#39;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-5-2-内联函数和constexpr函数"><a href="#6-5-2-内联函数和constexpr函数" class="headerlink" title="6.5.2 内联函数和constexpr函数"></a>6.5.2 内联函数和constexpr函数</h3><p>内联函数可避免函数调用的开销，将函数指定为<strong>内联函数(inline)</strong>，通常就是将它在每个调用点上“内联地”展开。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>110-平衡二叉树</title>
      <link href="2021/07/13/LeetCode-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/07/13/LeetCode-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-110-Balanced-Binary-Tree"><a href="#LeetCode-110-Balanced-Binary-Tree" class="headerlink" title="LeetCode 110. Balanced Binary Tree"></a>LeetCode 110. Balanced Binary Tree</h2><p>Given a <strong>binary tree</strong>, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><p>a binary tree in which the left and right subtrees of every node differ in height by no more than 1.</p><p>Example 1:<br><img src="/2021/07/13/LeetCode-110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/110.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [3,9,20,null,null,15,7]Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>平衡二叉树：左子树和右子树的高度差的绝对值小于1</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int getDepth(TreeNode* root) &#123;    if (root &#x3D;&#x3D; nullptr) return 0;    int leftDepth &#x3D; getDepth(root-&gt;left);    if (leftDepth &#x3D;&#x3D; -1) return -1;    int rightDepth &#x3D; getDepth(root-&gt;right);    if (rightDepth &#x3D;&#x3D; - 1) return -1;    return abs(leftDepth - rightDepth) &gt; 1 ? -1 : 1 + max(leftDepth, rightDepth);&#125;bool isBalanced(TreeNode* root) &#123;    return getDepth(root) &#x3D;&#x3D; -1 ? false : true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>222-完全二叉树的节点</title>
      <link href="2021/07/12/LeetCode-222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>2021/07/12/LeetCode-222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a>222. Count Complete Tree Nodes</h2><p>Given the root of a <strong>complete binary tree</strong>, return the number of the nodes in the tree.</p><p>According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and $2^h$ nodes inclusive at the last level h.</p><p>Design an algorithm that runs in less than $O(n)$ time complexity.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [1,2,3,4,5,6]Output: 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-1-递归"><a href="#method-1-递归" class="headerlink" title="method 1: 递归"></a>method 1: 递归</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int countNodes(TreeNode* root) &#123;    if (root &#x3D;&#x3D; nullptr) return 0;    int leftNum &#x3D; countNodes(root-&gt;left);    int rightNum &#x3D; countNodes(root-&gt;right);    return leftNum + rightNum + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(n)$<br>空间复杂度：$O(logn)$，算上了递归系统栈占用的空间</p><h2 id="method-2-层序遍历"><a href="#method-2-层序遍历" class="headerlink" title="method 2: 层序遍历"></a>method 2: 层序遍历</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int countNodes(TreeNode* root) &#123;    queue&lt;TreeNode*&gt; q;    if (root &#x3D;&#x3D; nullptr) return 0;    q.push(root);    int count &#x3D; 0;    while (!q.empty()) &#123;        int size &#x3D; q.size();        for (int i &#x3D; 0; i &lt; size; ++i) &#123;            count++;            TreeNode* cur &#x3D; q.front();            q.pop();            if (cur-&gt;left) q.push(cur-&gt;left);            if (cur-&gt;right) q.push(cur-&gt;right);        &#125;    &#125;    return count;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p><h2 id="method-3-利用完全二叉树性质"><a href="#method-3-利用完全二叉树性质" class="headerlink" title="method 3: 利用完全二叉树性质"></a>method 3: 利用完全二叉树性质</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int countNodes(TreeNode* root) &#123;    if (root &#x3D;&#x3D; nullptr) return 0;    TreeNode* leftNode &#x3D; root-&gt;left;    TreeNode* rightNode &#x3D; root-&gt;right;    int leftDepth &#x3D; 0, rightDepth &#x3D; 0;    while (leftNode) &#123;        leftNode &#x3D; leftNode-&gt;left;        leftDepth++;    &#125;    while (rightNode) &#123;        rightNode &#x3D; rightNode-&gt;right;        rightDepth++;    &#125;    if (leftDepth &#x3D;&#x3D; rightDepth) &#123;        return (2 &lt;&lt; leftDepth) - 1;    &#125;    return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(logn * logn)$<br>空间复杂度：$O(logn)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>111-二叉树的最小深度</title>
      <link href="2021/07/11/LeetCode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
      <url>2021/07/11/LeetCode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-111-Minimum-Depth-of-Binary-Tree"><a href="#LeetCode-111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="LeetCode 111. Minimum Depth of Binary Tree"></a>LeetCode 111. Minimum Depth of Binary Tree</h2><p>Given a binary tree, find its <strong>minimum depth</strong>.</p><p>The <strong>minimum depth</strong> is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p>Note: A leaf is a node with <strong>no children</strong>.</p><p>Example 1:<br><img src="/2021/07/11/LeetCode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/111.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [3,9,20,null,null,15,7]Output: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-1-递归"><a href="#method-1-递归" class="headerlink" title="method 1: 递归"></a>method 1: 递归</h2><p>如果子树为空的话不能算深度为0，因为只有叶子节点才算深度</p><ul><li>左子树为空，右子树非空，返回右子树高度+1</li><li>右子树为空，左子树非空，返回左子树高度+1</li><li>左右子树都非空，返回较小者+1</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int minDepth(TreeNode* root) &#123;    if (root &#x3D;&#x3D; nullptr) return 0;    int leftDepth &#x3D; minDepth(root-&gt;left);    int rightDepth &#x3D; minDepth(root-&gt;right);    if (root-&gt;left &#x3D;&#x3D; nullptr &amp;&amp; root-&gt;right) return 1 + rightDepth;    if (root-&gt;left &amp;&amp; root-&gt;right &#x3D;&#x3D; nullptr) return 1 + leftDepth;    return min(leftDepth, rightDepth) + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-层序遍历"><a href="#method-2-层序遍历" class="headerlink" title="method 2: 层序遍历"></a>method 2: 层序遍历</h2><h2 id="错误写法"><a href="#错误写法" class="headerlink" title="错误写法"></a>错误写法</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int minDepth(TreeNode* root) &#123;    queue&lt;TreeNode*&gt; q;    if (root &#x3D;&#x3D; nullptr) return 0;    q.push(root);    int depth &#x3D; 0;    while (!q.empty()) &#123;        int size &#x3D; q.size();        depth++;        for (int i &#x3D; 0; i &lt; size; ++i) &#123;            TreeNode* cur &#x3D; q.front();            q.pop();            if (cur-&gt;left) q.push(cur-&gt;left);            else if (cur-&gt;right) q.push(cur-&gt;right);    &#x2F;&#x2F; 不能用else            else break;     &#x2F;&#x2F; 不能用break        &#125;    &#125;    return depth;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>else</code> 是分支语句，执行了if就不会执行 <code>else</code>，这样右节点就不会被放进来</li><li><code>break</code> 退出当前 <code>for</code> 循环，但外面还有一个 <code>while</code> 循环，破坏了层序遍历的结构</li></ul><h3 id="正确写法"><a href="#正确写法" class="headerlink" title="正确写法"></a>正确写法</h3><p>三种情况分别用三个<code>if</code>判断<br>没有左子树和右子树，说明是叶子节点，可以返回了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int minDepth(TreeNode* root) &#123;    queue&lt;TreeNode*&gt; q;    if (root &#x3D;&#x3D; nullptr) return 0;    q.push(root);    int depth &#x3D; 0;    while (!q.empty()) &#123;        int size &#x3D; q.size();        depth++;        for (int i &#x3D; 0; i &lt; size; ++i) &#123;            TreeNode* cur &#x3D; q.front();            q.pop();            if (cur-&gt;left) q.push(cur-&gt;left);            if (cur-&gt;right) q.push(cur-&gt;right);            if (!cur-&gt;left &amp;&amp; !cur-&gt;right) return depth;        &#125;    &#125;    return depth;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104-二叉树的最大深度</title>
      <link href="2021/07/11/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>2021/07/11/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-104-Maximum-Depth-of-Binary-Tree"><a href="#LeetCode-104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="LeetCode 104. Maximum Depth of Binary Tree"></a>LeetCode 104. Maximum Depth of Binary Tree</h2><p>Given the root of a binary tree, return its <strong>maximum depth</strong>.</p><p>A binary tree’s <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p>Example 1:<br><img src="/2021/07/11/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/104.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [3,9,20,null,null,15,7]Output: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method-2-递归"><a href="#method-2-递归" class="headerlink" title="method 2: 递归"></a>method 2: 递归</h2><ul><li>递归参数：节点</li><li>递归结束条件：节点为空，返回0</li><li>单层递归逻辑：当前节点的左子树高度和右子树高度的较大值+1，就是该节点子树的高度</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int getDepth(TreeNode* root) &#123;    if (root &#x3D;&#x3D; nullptr) return 0;    int leftDepth &#x3D; getDepth(root-&gt;left);    int rightDepth &#x3D; getDepth(root-&gt;right);    return max(leftDepth, rightDepth) + 1;&#125;int maxDepth(TreeNode* root) &#123;    return getDepth(root);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-层序遍历"><a href="#method-2-层序遍历" class="headerlink" title="method 2: 层序遍历"></a>method 2: 层序遍历</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int maxDepth(TreeNode* root) &#123;    queue&lt;TreeNode*&gt; q;    if (root &#x3D;&#x3D; nullptr) return 0;    q.push(root);    int depth &#x3D; 0;  &#x2F;&#x2F; 记录有多少层    while (!q.empty()) &#123;        int size &#x3D; q.size();        depth++;        for (int i &#x3D; 0; i &lt; size; ++i) &#123;            TreeNode* top &#x3D; q.front();            q.pop();            if (top-&gt;left) q.push(top-&gt;left);            if (top-&gt;right) q.push(top-&gt;right);        &#125;    &#125;    return depth;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-559-Maximum-Depth-of-N-ary-Tree"><a href="#LeetCode-559-Maximum-Depth-of-N-ary-Tree" class="headerlink" title="LeetCode 559. Maximum Depth of N-ary Tree"></a>LeetCode 559. Maximum Depth of N-ary Tree</h2><p>Given a n-ary tree, find its <strong>maximum depth</strong>.</p><p>The <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value.</p><p>Example 1:<br><img src="/2021/07/11/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/2.png" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [1,null,3,2,4,null,5,6]Output: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><p>注意：二叉树只有两个结果所以直接<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">return max(res1, res2);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>这里有N个结果，显然不能一个一个列出来，所以换一种写法，记录每一次的结果<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">for (int i &#x3D; 0; i &lt; N; ++i) &#123;    depth &#x3D; max(depth, res);&#125;return depth;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int maxDepth(Node* root) &#123;    if (root &#x3D;&#x3D; nullptr) return 0;    int depth &#x3D; 0;    for (int i &#x3D; 0; i &lt; root-&gt;children.size(); ++i) &#123;        depth &#x3D; max(depth, maxDepth(root-&gt;children[i]));    &#125;    return depth + 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>101-对称二叉树</title>
      <link href="2021/07/04/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/07/04/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-101-Symmetric-Tree"><a href="#LeetCode-101-Symmetric-Tree" class="headerlink" title="LeetCode 101. Symmetric Tree"></a>LeetCode 101. Symmetric Tree</h2><p>Given the root of a binary tree, check whether it is a <strong>mirror</strong> of itself.</p><p>Example:<br><img src="/2021/07/04/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/101.jpg" alt></p><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method:递归"></a>method:递归</h2><p>分别比较外侧节点和内侧节点</p><ul><li>外侧：左子树的左节点，右子树的右节点</li><li>内侧：左子树的右节点，右子树的左节点</li></ul><p>递归参数：在不引起争议的情况下，统称为左节点和右节点</p><p>结束条件：</p><ul><li>左节点空，右节点也空，返回<code>true</code></li><li>左节点非空，右节点空，返回<code>false</code></li><li>左节点空，右节点非空，返回<code>false</code></li><li>左右节点都不空，但是不相等，返回<code>false</code></li></ul><p>单层遍历逻辑：分别遍历内侧节点和外侧节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool compare(TreeNode* left, TreeNode* right) &#123;    if (left &#x3D;&#x3D; nullptr &amp;&amp; right &#x3D;&#x3D; nullptr) return true;    else if (left !&#x3D; nullptr &amp;&amp; right &#x3D;&#x3D; nullptr) return false;    else if (left &#x3D;&#x3D; nullptr &amp;&amp; right !&#x3D; nullptr) return false;    else if (left-&gt;val !&#x3D; right-&gt;val) return false;    &#x2F;&#x2F; 剩下的就是节点非空且值相同的情况    bool outSide &#x3D; compare(left-&gt;left, right-&gt;right);    bool inSide &#x3D; compare(left-&gt;right, right-&gt;left);    return outSide &amp;&amp; inSide;&#125;bool isSymmetric(TreeNode* root) &#123;    if (root &#x3D;&#x3D; nullptr) return true;    return compare(root-&gt;left, root-&gt;right);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-100-Same-Tree"><a href="#LeetCode-100-Same-Tree" class="headerlink" title="LeetCode 100. Same Tree"></a>LeetCode 100. Same Tree</h2><p>Given the roots of two binary trees p and q, write a function to check if they are the same or not.</p><p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p><p>Example 1:<br><img src="/2021/07/04/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/100.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: p &#x3D; [1,2,3], q &#x3D; [1,2,3]Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>把对称二叉树的左右换一下就可以了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool isSameTree(TreeNode* p, TreeNode* q) &#123;    if (!p &amp;&amp; !q) return true;    else if (!p &amp;&amp; q) return false;    else if (p &amp;&amp; !q) return false;    else if (p-&gt;val !&#x3D; q-&gt;val) return false;    bool leftSide &#x3D; isSameTree(p-&gt;left, q-&gt;left);    bool rightSide &#x3D; isSameTree(p-&gt;right, q-&gt;right);    return leftSide &amp;&amp; rightSide;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>226-翻转二叉树</title>
      <link href="2021/07/03/LeetCode-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2021/07/03/LeetCode-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-226-Invert-Binary-Tree"><a href="#LeetCode-226-Invert-Binary-Tree" class="headerlink" title="LeetCode 226. Invert Binary Tree"></a>LeetCode 226. Invert Binary Tree</h2><p>Given the root of a binary tree, <strong>invert</strong> the tree, and return its <strong>root</strong>.</p><p>Example:</p><p><img src="/2021/07/03/LeetCode-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/226.jpg" alt></p><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><p>翻转每个节点的左右节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">TreeNode* invertTree(TreeNode* root) &#123;    if (root &#x3D;&#x3D; nullptr) return root;    swap(root-&gt;left, root-&gt;right);    invertTree(root-&gt;left);    invertTree(root-&gt;right);    return root;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>429-N叉树的层序遍历</title>
      <link href="2021/06/28/LeetCode-429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>2021/06/28/LeetCode-429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-429-N-ary-Tree-Level-Order-Traversal"><a href="#LeetCode-429-N-ary-Tree-Level-Order-Traversal" class="headerlink" title="LeetCode 429. N-ary Tree Level Order Traversal"></a>LeetCode 429. N-ary Tree Level Order Traversal</h2><p>Given an n-ary tree, return the level order traversal of its nodes’ values.</p><p>Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).</p><p>Example 1:<br><img src="/2021/06/28/LeetCode-429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/429.png" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [1,null,3,2,4,null,5,6]Output: [[1],[3,2,4],[5,6]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>遍历每个节点的子节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123;    queue&lt;Node*&gt; q;    vector&lt;vector&lt;int&gt;&gt; ret;    if (root &#x3D;&#x3D; nullptr) return ret;    q.push(root);    while (!q.empty()) &#123;        int size &#x3D; q.size();        vector&lt;int&gt; vec;        for (int i &#x3D; 0; i &lt; size; ++i) &#123;            Node* cur &#x3D; q.front();            q.pop();            vec.push_back(cur-&gt;val);            for (int j &#x3D; 0; j &lt; cur-&gt;children.size(); ++j) &#123;                q.push(cur-&gt;children[j]);            &#125;        &#125;        ret.push_back(vec);    &#125;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>332-重新安排行程</title>
      <link href="2021/06/27/LeetCode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/"/>
      <url>2021/06/27/LeetCode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-332-Reconstruct-Itinerary"><a href="#LeetCode-332-Reconstruct-Itinerary" class="headerlink" title="LeetCode 332. Reconstruct Itinerary"></a>LeetCode 332. Reconstruct Itinerary</h2><p>You are given a list of airline <code>tickets</code> where <code>tickets[i] = [from, to]</code> represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.</p><p>All of the tickets belong to a man who departs from <code>&quot;JFK&quot;</code>, thus, the itinerary must begin with <code>&quot;JFK&quot;</code>. If there are multiple valid itineraries, you should return the itinerary that has the <strong>smallest lexical order</strong> when read as a single string.</p><ul><li>For example, the itinerary <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> has a smaller lexical order than <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code>.</li></ul><p>You may assume all tickets form at least one valid itinerary. You must <strong>use all the tickets once and only once</strong>.</p><p>Example 1:<br><img src="/2021/06/27/LeetCode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/00.png" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: tickets &#x3D; [[&quot;MUC&quot;,&quot;LHR&quot;],[&quot;JFK&quot;,&quot;MUC&quot;],[&quot;SFO&quot;,&quot;SJC&quot;],[&quot;LHR&quot;,&quot;SFO&quot;]]Output: [&quot;JFK&quot;,&quot;MUC&quot;,&quot;LHR&quot;,&quot;SFO&quot;,&quot;SJC&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><img src="/2021/06/27/LeetCode-332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/11.png" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: tickets &#x3D; [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;] but it is larger in lexical order.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-回溯"><a href="#method-回溯" class="headerlink" title="method: 回溯"></a>method: 回溯</h2><p>难点一：回溯三部曲</p><ul><li><p>递归函数参数<br>机票总数，作为结束条件判断，也可以作为全局变量<br>结果数组存储最终行程</p></li><li><p>递归结束调价<br>最终行程数组比机票数大1，说明找到了一组可行的解，返回<code>true</code>，因为只需要一组解</p></li><li><p>单层循环<br>因为每个起始点可能有多个终点，所以要遍历这些终点</p></li></ul><p>难点二：选择<strong>合适的数据结构</strong></p><p>首先一个起点对应多个终点，可以想到用<code>unordered_map</code><br>其次，机票是可以重复的，所以还需要记录每个起止点出现的次数，也需要一个映射关系，而且用了一次之后次数要减少，也就是还要可以<strong>删改</strong><br>所以选择用<code>unordered_map&lt;string, map&lt;string, int&gt;&gt;</code>，后面用<code>map</code>是因为需要对终点进行排序，字典序小的放在前面</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unordered_map&lt;string, map&lt;string, int&gt;&gt; targets;bool dfs(int ticketNum, vector&lt;string&gt;&amp; ret) &#123;    if (ret.size() &#x3D;&#x3D; ticketNum + 1) &#123;        return true;    &#125;   &#x2F;&#x2F; 返回true说明找到了一条可行路程    &#x2F;&#x2F; 遍历每个起点对应的终点，已经是有序的了    for (pair&lt;const string, int&gt;&amp; target: targets[ret[ret.size() - 1]]) &#123;           if (target.second &gt; 0) &#123;    &#x2F;&#x2F; 有票就用            ret.push_back(target.first);            target.second--;            if (dfs(ticketNum, ret)) return true;            ret.pop_back();            target.second++;        &#125;    &#125;    return false;&#125;vector&lt;string&gt; findItinerary(vector&lt;vector&lt;string&gt;&gt;&amp; tickets) &#123;    for (auto vec : tickets) &#123;        targets[vec[0]][vec[1]]++;    &#125;    vector&lt;string&gt; ret;    ret.push_back(&quot;JFK&quot;);   &#x2F;&#x2F; 起点放进来    dfs(tickets.size(), ret);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>169-多数元素</title>
      <link href="2021/06/27/LeetCode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
      <url>2021/06/27/LeetCode-169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-169-Majority-Element"><a href="#LeetCode-169-Majority-Element" class="headerlink" title="LeetCode 169. Majority Element"></a>LeetCode 169. Majority Element</h2><p>Given an array <code>nums</code> of size n, return the majority element.</p><p>The majority element is the element that appears more than $\lfloor n / 2 \rfloor$ times. You may assume that the majority element always exists in the array.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [3,2,3]Output: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [2,2,1,1,1,2,2]Output: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-1-哈希表"><a href="#method-1-哈希表" class="headerlink" title="method 1: 哈希表"></a>method 1: 哈希表</h2><p><code>hash</code>记录每个数字出现的次数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;    int n &#x3D; nums.size();    n &#x2F;&#x3D; 2;    unordered_map&lt;int, int&gt; hash;    for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;        hash[nums[i]]++;        if (hash[nums[i]] &gt; n) return nums[i];    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p><h2 id="method-2-双指针"><a href="#method-2-双指针" class="headerlink" title="method 2: 双指针"></a>method 2: 双指针</h2><p>先排序，把相同元素放在一起，再用双指针找相同元素出现次数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;    int size &#x3D; nums.size();    size &#x2F;&#x3D; 2;    sort(nums.begin(), nums.end());    int l &#x3D; 0, r &#x3D; 0;    while (r &lt; nums.size()) &#123;        int cnt &#x3D; 0;        while (r &lt; nums.size() &amp;&amp; nums[r] &#x3D;&#x3D; nums[l]) r++;        cnt &#x3D; r - l;        if (cnt &gt; size) return nums[l];        else l &#x3D; r;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(nlogn+n)$<br>空间复杂度：如果使用语言自带的排序算法，需要使用$O(logn)$的栈空间</p><p>由于众数出现的频率大于<code>n/2</code>，所以在排序之后众数必存在于下标<code>[n/2]</code>处，直接返回</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;    sort(nums.begin(), nums.end());    return nums[nums.size() &#x2F; 2];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(nlogn)$<br>空间复杂度：$O(nlogn)$</p><h2 id="method-3-摩尔投票法"><a href="#method-3-摩尔投票法" class="headerlink" title="method 3: 摩尔投票法"></a>method 3: 摩尔投票法</h2><p>众数：出现次数大于<code>n/2</code>的数<br>遇到相同的数，就投一票，遇到不同的数，就减一票，最后还存在票的数就是众数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;    int ret &#x3D; -1;    int count &#x3D; 0;    for (auto num : nums) &#123;        if (count &#x3D;&#x3D; 0) ret &#x3D; num;         if (num &#x3D;&#x3D; ret) count++;        else count--;    &#125;        return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>637-二叉树的层平均值</title>
      <link href="2021/06/26/LeetCode-637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/"/>
      <url>2021/06/26/LeetCode-637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-637-Average-of-Levels-in-Binary-Tree"><a href="#LeetCode-637-Average-of-Levels-in-Binary-Tree" class="headerlink" title="LeetCode 637. Average of Levels in Binary Tree"></a>LeetCode 637. Average of Levels in Binary Tree</h2><p>Given the root of a binary tree, return the <strong>average value</strong> of the nodes on <strong>each level</strong> in the form of an array. Answers within $10^{-5}$ of the actual answer will be accepted.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input:     3   &#x2F; \  9  20    &#x2F;  \   15   7Output: [3.00000,14.50000,11.00000]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>记录每层的节点总和，遍历完一层后记录平均值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;double&gt; averageOfLevels(TreeNode* root) &#123;    vector&lt;double&gt; ret;    if (root &#x3D;&#x3D; nullptr) return ret;    queue&lt;TreeNode*&gt; q;    q.push(root);    while (!q.empty()) &#123;        int size &#x3D; q.size();        double sum &#x3D; 0;        for (int i &#x3D; 0; i &lt; size; ++i) &#123;            TreeNode* cur &#x3D; q.front();            q.pop();            sum +&#x3D; cur-&gt;val;            if (cur-&gt;left) q.push(cur-&gt;left);            if (cur-&gt;right) q.push(cur-&gt;right);        &#125;        ret.push_back(sum &#x2F; size);    &#125;    return ret;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>199-二叉树的右视图</title>
      <link href="2021/06/26/LeetCode-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/"/>
      <url>2021/06/26/LeetCode-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-199-Binary-Tree-Right-Side-View"><a href="#LeetCode-199-Binary-Tree-Right-Side-View" class="headerlink" title="LeetCode 199. Binary Tree Right Side View"></a>LeetCode 199. Binary Tree Right Side View</h2><p>Given the root of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return the values of the nodes you can see ordered from top to bottom.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input:    1        &lt;--- &#x2F;   \2     3     &lt;--- \     \  5     4   &lt;---Output: [1, 3, 4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>每层遍历到最右边的时候记录节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; rightSideView(TreeNode* root) &#123;    vector&lt;int&gt; ret;    if (root &#x3D;&#x3D; nullptr) return ret;    queue&lt;TreeNode*&gt; q;    q.push(root);    while (!q.empty()) &#123;        int size &#x3D; q.size();        for (int i &#x3D; 0; i &lt; size; ++i) &#123;            TreeNode* cur &#x3D; q.front();            q.pop();            if (i &#x3D;&#x3D; size - 1) ret.push_back(cur-&gt;val); &#x2F;&#x2F; 最右边的位置            if (cur-&gt;left) q.push(cur-&gt;left);            if (cur-&gt;right) q.push(cur-&gt;right);        &#125;    &#125;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102-二叉树的层序遍历</title>
      <link href="2021/06/26/LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>2021/06/26/LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-102-Binary-Tree-Level-Order-Traversal"><a href="#LeetCode-102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="LeetCode 102. Binary Tree Level Order Traversal"></a>LeetCode 102. Binary Tree Level Order Traversal</h2><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">LeetCode-102</a></p><p>Given the root of a binary tree, return the level order traversal of its nodes’ values.</p><p>Example 1:</p><p><img src="/2021/06/26/LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/22.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [3,9,20,null,null,15,7]Output: [[3],[9,20],[15,7]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="method-1-队列"><a href="#method-1-队列" class="headerlink" title="method 1: 队列"></a>method 1: 队列</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;    vector&lt;vector&lt;int&gt;&gt; ret;    if (root &#x3D;&#x3D; nullptr) return ret;    queue&lt;TreeNode*&gt; q;    q.push(root);    while (!q.empty()) &#123;        int size &#x3D; q.size();    &#x2F;&#x2F; 先记录size，后面会变        vector&lt;int&gt; path;        for (int i &#x3D; 0; i &lt; size; ++i) &#123;            TreeNode* cur &#x3D; q.front();            q.pop();            path.push_back(cur-&gt;val);            if (cur-&gt;left) q.push(cur-&gt;left);            if (cur-&gt;right) q.push(cur-&gt;right);        &#125;        ret.push_back(vec);    &#125;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="method-2-递归"><a href="#method-2-递归" class="headerlink" title="method 2: 递归"></a>method 2: 递归</h3><p>先序遍历，把节点插入到相同深度的<code>vector</code>中</p><p>后面要索引，所以先插入一个空的<code>vector</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; res;void traversal(TreeNode* cur, int depth) &#123;    if (!cur) return;    if (res.size() &#x3D;&#x3D; depth) &#123;        res.push_back(vector&lt;int&gt;());   &#x2F;&#x2F; 先插入一个空的vector    &#125;    res[depth].push_back(cur-&gt;val);    if (cur-&gt;left) traversal(cur-&gt;left, depth + 1);    if (cur-&gt;right) traversal(cur-&gt;right, depth + 1);&#125;vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;    traversal(root, 0);    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="LeetCode-103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#LeetCode-103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="LeetCode 103. Binary Tree Zigzag Level Order Traversal"></a>LeetCode 103. Binary Tree Zigzag Level Order Traversal</h2><p>Given the <code>root</code> of a binary tree, return the <code>zigzag</code> level order traversal of its nodes’ values.</p><p>Example 1:</p><p><img src="/2021/06/26/LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/22.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [3,9,20,null,null,15,7]Output: [[3],[20,9],[15,7]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>奇数层的<code>vector</code>要反转</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;    vector&lt;vector&lt;int&gt;&gt; res;    if (!root) return res;    queue&lt;TreeNode*&gt; q;    q.push(root);    int depth &#x3D; 0;  &#x2F;&#x2F; 记录深度    while (!q.empty()) &#123;        int size &#x3D; q.size();        vector&lt;int&gt; path;        for (int i &#x3D; 0; i &lt; size; i++) &#123;            TreeNode *cur &#x3D; q.front();            q.pop();            path.push_back(cur-&gt;val);            if (cur-&gt;left) q.push(cur-&gt;left);            if (cur-&gt;right) q.push(cur-&gt;right);        &#125;        if (depth % 2) reverse(path.begin(), path.end());   &#x2F;&#x2F; 反转        res.push_back(path);        depth++;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="LeetCode-107-Binary-Tree-Level-Order-Traversal-II"><a href="#LeetCode-107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="LeetCode 107. Binary Tree Level Order Traversal II"></a>LeetCode 107. Binary Tree Level Order Traversal II</h2><p>Given the root of a binary tree, return the <strong>bottom-up</strong> level order traversal of its nodes’ values. (i.e., from left to right, level by level from leaf to root).</p><p>Example 1:</p><p><img src="/2021/06/26/LeetCode-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/22.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [3,9,20,null,null,15,7]Output: [[15,7],[9,20],[3]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="method-1"><a href="#method-1" class="headerlink" title="method"></a>method</h3><p>层序遍历最后反转即可</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;    vector&lt;vector&lt;int&gt;&gt; ret;    if (root &#x3D;&#x3D; nullptr) return ret;    queue&lt;TreeNode*&gt; q;    q.push(root);    while (!q.empty()) &#123;        int size &#x3D; q.size();        vector&lt;int&gt; path;        for (int i &#x3D; 0; i &lt; size; ++i) &#123;            TreeNode* cur &#x3D; q.front();            q.pop();            path.push_back(cur-&gt;val);            if (cur-&gt;left) q.push(cur-&gt;left);            if (cur-&gt;right) q.push(cur-&gt;right);        &#125;        ret.push_back(vec);    &#125;    reverse(ret.begin(), ret.end());    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46/47-全排列</title>
      <link href="2021/06/26/LeetCode-46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
      <url>2021/06/26/LeetCode-46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-46-Permutations"><a href="#LeetCode-46-Permutations" class="headerlink" title="LeetCode 46. Permutations"></a>LeetCode 46. Permutations</h2><p>Given an array nums of distinct integers, return all the possible permutations. You can return the answer in <strong>any order</strong>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [1,2,3]Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-回溯"><a href="#method-回溯" class="headerlink" title="method: 回溯"></a>method: 回溯</h2><p>因为下一个<code>for</code>循环还是要从头开始，所以不需要<code>index</code>，跟组合问题不一样<br>因为用过的元素不能再用，所以在每一棵子树上维护一个<code>used</code>数组，保证用过的数不能再用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; ret;vector&lt;int&gt; path;void dfs(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) &#123;    if (path.size() &#x3D;&#x3D; nums.size()) &#123;        ret.push_back(path);        return;    &#125;    for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;        if (used[i]) continue;  &#x2F;&#x2F; 用过了就不能再用了        used[i] &#x3D; true;        path.push_back(nums[i]);        dfs(nums, used);        path.pop_back();        used[i] &#x3D; false;    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;bool&gt; used(nums.size(), false);    dfs(nums, used);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-47-Permutations-II"><a href="#LeetCode-47-Permutations-II" class="headerlink" title="LeetCode 47. Permutations II"></a>LeetCode 47. Permutations II</h2><p>Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [1,1,2]Output:[[1,1,2], [1,2,1], [2,1,1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>两步去重</p><ul><li><code>used</code>数组负责同一颗子树上的去重</li><li><code>hash</code>哈希表负责同一树层上的去重，因为数组元素在<code>[-10,10]</code>之间，就直接用数组当哈希表</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; ret;vector&lt;int&gt; path;void dfs(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) &#123;    if (path.size() &#x3D;&#x3D; nums.size()) &#123;        ret.push_back(path);        return;    &#125;    int hash[21] &#x3D; &#123;0&#125;;    for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;        if (hash[nums[i] + 10] || used[i]) continue;        hash[nums[i] + 10] &#x3D; 1;        path.push_back(nums[i]);        used[i] &#x3D; true;        dfs(nums, used);        used[i] &#x3D; false;        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;bool&gt; used(nums.size(), false);    dfs(nums, used);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="可以只用一个used"><a href="#可以只用一个used" class="headerlink" title="可以只用一个used"></a>可以只用一个used</h2><p>不过要先排序，让相同的元素在一起<br>在上面的全排列问题中，<code>used</code>数组用于同一子树的去重，但是在同一树层，如果两个元素相同，并且前一个元素的<code>used[i-1]=false</code>，说明前一个元素肯定会被用，当前元素就不能再用了，所以也起到了同一树层去重的功能:yum:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; ret;vector&lt;int&gt; path;void dfs(vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) &#123;    if (path.size() &#x3D;&#x3D; nums.size()) &#123;        ret.push_back(path);        return;    &#125;    for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1] &amp;&amp; !used[i - 1]) continue;        if (used[i]) continue;  &#x2F;&#x2F; 避免重复取同一个元素        path.push_back(nums[i]);        used[i] &#x3D; true;        dfs(nums, used);        used[i] &#x3D; false;        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123;    sort(nums.begin(), nums.end());    vector&lt;bool&gt; used(nums.size(), false);    dfs(nums, used);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>491-递增子序列</title>
      <link href="2021/06/26/LeetCode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>2021/06/26/LeetCode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-491-Increasing-Subsequences"><a href="#LeetCode-491-Increasing-Subsequences" class="headerlink" title="LeetCode 491. Increasing Subsequences"></a>LeetCode 491. Increasing Subsequences</h2><p><a href="https://leetcode.com/problems/increasing-subsequences/">LeetCode-491</a></p><p>Given an integer array nums, return all the different possible increasing subsequences of the given array with <strong>at least two elements</strong>. You may return the answer in <strong>any order</strong>.</p><p>The given array may contain <strong>duplicates</strong>, and two equal integers should also be considered a special case of increasing sequence.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [4,6,7,7]Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h3 id="method-回溯"><a href="#method-回溯" class="headerlink" title="method: 回溯"></a>method: 回溯</h3><p>元素不能重复使用，所以<code>i+1</code><br>类似子集问题，收集所有含有两个元素以上的子节点<br>数组有重复，但是子集不能重复，所以要同一树层的去重<br>但是又不能排序，不能使用<a href="https://kavinwkp.github.io/2021/06/23/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/">数组总和II</a>的去重方法</p><p><strong>解决办法</strong>：使用一个集合记录元素是否被使用过</p><p>两个判断条件：</p><ul><li>如果<code>nums[i]</code>比子集最后一个元素小，就不能放进来了</li><li>同一分支下，相同元素已经被记录使用过了就不能再用了</li></ul><p><img src="/2021/06/26/LeetCode-491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/491.png" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; ret;vector&lt;int&gt; path;void dfs(vector&lt;int&gt;&amp; nums, int index) &#123;    if (path.size() &gt; 1) &#123;        ret.push_back(path);    &#x2F;&#x2F; 不用return    &#125;    unordered_set&lt;int&gt; st;    for (int i &#x3D; index; i &lt; nums.size(); ++i) &#123;        if ((!path.empty() &amp;&amp; nums[i] &lt; path.back()) || st.count(nums[i]))                 continue;        path.push_back(nums[i]);        st.insert(nums[i]); &#x2F;&#x2F; 记录已使用过        dfs(nums, i + 1);   &#x2F;&#x2F; 不能重复使用        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;    dfs(nums, 0);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>题目限制数组元素大小为<code>[-100,100]</code>，所以可以用数组替换<code>unordered_set</code>，速度更快一点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; ret;vector&lt;int&gt; path;void dfs(vector&lt;int&gt;&amp; nums, int index) &#123;    if (path.size() &gt; 1) &#123;        ret.push_back(path);    &#125;    int used[201] &#x3D; &#123;0&#125;;    for (int i &#x3D; index; i &lt; nums.size(); ++i) &#123;        if ((!path.empty() &amp;&amp; nums[i] &lt; path.back())                 || used[nums[i] + 100]) continue;        path.push_back(nums[i]);        used[nums[i] + 100] &#x3D; 1;        dfs(nums, i + 1);        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;    dfs(nums, 0);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>78/90-子集</title>
      <link href="2021/06/26/LeetCode-78-%E5%AD%90%E9%9B%86/"/>
      <url>2021/06/26/LeetCode-78-%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-78-Subsets"><a href="#LeetCode-78-Subsets" class="headerlink" title="LeetCode 78. Subsets"></a>LeetCode 78. Subsets</h2><p><a href="https://leetcode.com/problems/subsets/">LeetCode-78</a></p><p>Given an integer array nums of <strong>unique</strong> elements, return all possible subsets (the power set).</p><p>The solution set must not contain <strong>duplicate subsets</strong>. Return the solution in <strong>any order</strong>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [1,2,3]Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h3 id="method-回溯"><a href="#method-回溯" class="headerlink" title="method: 回溯"></a>method: 回溯</h3><p>组合问题是收集树的叶子节点，子集问题是收集树的所有节点<br>不能包含重复元素，所以从<code>i+1</code>开始</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; ret;vector&lt;int&gt; path;void dfs(vector&lt;int&gt; nums, int index) &#123;    ret.push_back(path);    &#x2F;&#x2F; 收集所有节点    for (int i &#x3D; index; i &lt; nums.size(); ++i) &#123;        path.push_back(nums[i]);        dfs(nums, i + 1);        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123;    dfs(nums, 0);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-90-Subsets-II"><a href="#LeetCode-90-Subsets-II" class="headerlink" title="LeetCode 90. Subsets II"></a>LeetCode 90. Subsets II</h2><p><a href="https://leetcode.com/problems/subsets-ii/">LeetCode-90</a></p><p>Given an integer array nums that <strong>may contain duplicates</strong>, return all possible subsets (the power set).</p><p>The solution set must not contain duplicate subsets. Return the solution in any order.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [1,2,2]Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h3 id="method-回溯-1"><a href="#method-回溯-1" class="headerlink" title="method: 回溯"></a>method: 回溯</h3><p>数组里有重复元素，但是要求子集不能重复<br>和<a href="https://kavinwkp.github.io/2021/06/23/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/">组合总和II</a>一样的去重方式</p><ol><li>排序</li><li>如果当前元素和上一个元素相同就跳过</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; ret;vector&lt;int&gt; path;void dfs(vector&lt;int&gt;&amp; nums, int index) &#123;    ret.push_back(path);    for (int i &#x3D; index; i &lt; nums.size(); ++i) &#123;        if (i &gt; index &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;  &#x2F;&#x2F; 2        path.push_back(nums[i]);        dfs(nums, i + 1);        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;    sort(nums.begin(), nums.end()); &#x2F;&#x2F; 1    dfs(nums, 0);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>93-复原IP地址</title>
      <link href="2021/06/25/LeetCode-93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/"/>
      <url>2021/06/25/LeetCode-93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-93-Restore-IP-Addresses"><a href="#LeetCode-93-Restore-IP-Addresses" class="headerlink" title="LeetCode 93. Restore IP Addresses"></a>LeetCode 93. Restore IP Addresses</h2><p><a href="https://leetcode.com/problems/restore-ip-addresses/">LeetCode-93</a></p><p>Given a string <code>s</code> containing only digits, return all possible valid IP addresses that can be obtained from s. You can return them in <strong>any order</strong>.</p><p>A <code>valid IP address</code> consists of exactly four integers, each integer is between <code>0 and 255</code>, separated by single dots and cannot have leading zeros. For example, “0.1.2.201” and “192.168.1.1” are <code>valid</code> IP addresses and “0.011.255.245”, “192.168.1.312” and “192.168@1.1” are <code>invalid</code> IP addresses. </p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;25525511135&quot;Output: [&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;1111&quot;Output: [&quot;1.1.1.1&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h3 id="method-回溯"><a href="#method-回溯" class="headerlink" title="method: 回溯"></a>method: 回溯</h3><ul><li>substr(pos, len)</li></ul><p>返回从<code>pos</code>开始的<code>len</code>个字符组成的字符串</p><hr><p>类似于分割回文串，有些不同点：IP有效性，固定分割4块，直接在字符串上操作</p><p>IP地址有效性的判断：</p><ul><li>不能有前导0</li><li>不能有特殊符号</li><li>不能超过255</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;string&gt; ret;bool isValid(const string&amp; s, int start, int end) &#123;    if (s[start] &#x3D;&#x3D; &#39;0&#39; &amp;&amp; start !&#x3D; end) return false;  &#x2F;&#x2F; 不是单独的0    int num &#x3D; 0;    for (int i &#x3D; start; i &lt;&#x3D; end; ++i) &#123;        if (s[i] &lt; &#39;0&#39; || s[i] &gt; &#39;9&#39;) return false; &#x2F;&#x2F; 不能是其他字符        num &#x3D; num * 10 + (s[i] - &#39;0&#39;);        if (num &gt; 255) return false;    &#x2F;&#x2F; 不能超过255    &#125;    return true;&#125;void dfs(string&amp; s, int index, int num) &#123;    if (num &#x3D;&#x3D; 3) &#123; &#x2F;&#x2F; 插入3个点就可以结束了        if (isValid(s, index, s.size() - 1)) &#123;            ret.push_back(s);        &#125;        return;    &#125;    for (int i &#x3D; index; i &lt; index + 3 &amp;&amp; i &lt; s.size() - 1; ++i) &#123;        if (isValid(s, index, i)) &#123;            s.insert(s.begin() + i + 1, &#39;.&#39;);   &#x2F;&#x2F; 在i+1的位置插入点            dfs(s, i + 2, num + 1);     &#x2F;&#x2F; 从i+2的位置继续遍历            s.erase(s.begin() + i + 1); &#x2F;&#x2F; 回溯删掉点        &#125;        else break; &#x2F;&#x2F; 如果这个点不行，后面也肯定不行    &#125;&#125;vector&lt;string&gt; restoreIpAddresses(string s) &#123;    if (s.size() &gt; 12) return ret;    dfs(s, 0, 0);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为只考虑3个分割点，所以不能在最末尾，不然会出现<code>1.1.11.</code>，<br>所以判断条件是<code>i &lt; s.size() - 1</code><br>或者在有效性判断里边加上<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">if (start &gt; end) return false;此时 start &#x3D; s.size()，end &#x3D; s.size() - 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p><a href="https://kavinwkp.github.io/2021/06/24/LeetCode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/">分割回文串</a>里面是这个分割点不行，换到下一个分割点，所以用<code>continue</code><br>这里是如果这个分割点不行，再往后面肯定也不行，如<code>256</code>不行，再往后<code>2561</code>，<code>25610</code>肯定也不行，所以直接<code>break</code></p><p>因为在第<code>i</code>个位置分割，所以在<code>i+1</code>的位置插入分割点，后面的遍历就要从<code>i+2</code>的位置开始</p><p>如果已经插入三个分割点了，后面的子串自动成为第4个地址，如果有效，直接可以保存了</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>94-二叉树的遍历</title>
      <link href="2021/06/24/LeetCode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>2021/06/24/LeetCode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-94-Binary-Tree-Inorder-Traversal"><a href="#LeetCode-94-Binary-Tree-Inorder-Traversal" class="headerlink" title="LeetCode 94. Binary Tree Inorder Traversal"></a>LeetCode 94. Binary Tree Inorder Traversal</h2><p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">LeetCode-94</a></p><p>Given the <code>root</code> of a binary tree, return the <code>inorder traversal</code> of its nodes’ values.</p><h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>中序遍历：<strong>左-根-右</strong></p><ul><li>递归</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void inorder(TreeNode* cur, vector&lt;int&gt;&amp; ret) &#123;    if (cur &#x3D;&#x3D; nullptr) return;    inorder(cur-&gt;left, ret);    ret.push_back(cur-&gt;val);    inorder(cur-&gt;right, ret);&#125;vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; ret;    inorder(root, ret);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>迭代</li></ul><ol><li>一直往左子树深度遍历，期间把元素插入栈中，直到空<br>空的话说明到了无左子树的节点，开始弹出元素，同时查看是否有右节点</li><li>有右节点，返回1</li><li>无右节点，继续弹出元素</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; ret;    if (root &#x3D;&#x3D; nullptr) return ret;    stack&lt;TreeNode*&gt; st;    TreeNode* cur &#x3D; root;    while (cur || !st.empty()) &#123;        if (cur) &#123;            st.push(cur);            cur &#x3D; cur-&gt;left;        &#125;        else &#123;  &#x2F;&#x2F; cur空，但栈里有元素，就要弹出            cur &#x3D; st.top();            st.pop();            ret.push_back(cur-&gt;val);            cur &#x3D; cur-&gt;right;        &#125;    &#125;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-144-Binary-Tree-Preorder-Traversal"><a href="#LeetCode-144-Binary-Tree-Preorder-Traversal" class="headerlink" title="LeetCode 144. Binary Tree Preorder Traversal"></a>LeetCode 144. Binary Tree Preorder Traversal</h2><p><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/">LeetCode-144</a></p><p>Given the <code>root</code> of a binary tree, return the <code>preorder traversal</code> of its nodes’ values.</p><h3 id="method-1"><a href="#method-1" class="headerlink" title="method"></a>method</h3><p>前序遍历：<strong>根-左-右</strong></p><ul><li>递归法</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void preorder(TreeNode* cur, vector&lt;int&gt;&amp; ret) &#123;    if (cur &#x3D;&#x3D; nullptr) return;    ret.push_back(cur-&gt;val);    preorder(cur-&gt;left, ret);    preorder(cur-&gt;right, ret);&#125;vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; ret;    preorder(root, ret);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>迭代法</li></ul><p>先放右节点，再放左节点，待会取的时候就是先左再右</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; ret;    stack&lt;TreeNode*&gt; st;    if (root &#x3D;&#x3D; nullptr) return ret;    st.push(root);    while (!st.empty()) &#123;        TreeNode* cur &#x3D; st.top();        st.pop();        ret.push_back(cur-&gt;val);        if (cur-&gt;right) st.push(cur-&gt;right);        if (cur-&gt;left) st.push(cur-&gt;left);    &#125;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-145-Binary-Tree-Postorder-Traversal"><a href="#LeetCode-145-Binary-Tree-Postorder-Traversal" class="headerlink" title="LeetCode 145. Binary Tree Postorder Traversal"></a>LeetCode 145. Binary Tree Postorder Traversal</h2><p><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/">LeetCode-145</a></p><p>Given the <code>root</code> of a binary tree, return the <code>postorder traversal</code> of its nodes’ values.</p><h3 id="method-2"><a href="#method-2" class="headerlink" title="method"></a>method</h3><p>后序遍历：<strong>左-右-根</strong></p><ul><li>递归法</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void postorder(TreeNode* cur, vector&lt;int&gt;&amp; ret) &#123;    if (cur &#x3D;&#x3D; nullptr) return;    postorder(cur-&gt;left, ret);    postorder(cur-&gt;right, ret);    ret.push_back(cur-&gt;val);&#125;vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; ret;    postOrder(root, ret);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>迭代法</li></ul><p>后序<strong>左右根</strong>，反过来就是<strong>根右左</strong>，与先序遍历差不多，最后反转就可以了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;    vector&lt;int&gt; ret;    if (root &#x3D;&#x3D; nullptr) return ret;    stack&lt;TreeNode*&gt; st;    st.push(root);    while (!st.empty()) &#123;        TreeNode* cur &#x3D; st.top();        st.pop();        ret.push_back(cur-&gt;val);        if (cur-&gt;left) st.push(cur-&gt;left);        if (cur-&gt;right) st.push(cur-&gt;right);    &#125;    reverse(ret.begin(), ret.end());    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>131-分割回文串</title>
      <link href="2021/06/24/LeetCode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>2021/06/24/LeetCode-131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-131-Palindrome-Partitioning"><a href="#LeetCode-131-Palindrome-Partitioning" class="headerlink" title="LeetCode 131. Palindrome Partitioning"></a>LeetCode 131. Palindrome Partitioning</h2><p><a href="https://leetcode.com/problems/palindrome-partitioning/">LeetCode-131</a></p><p>Given a string s, partition s such that every substring of the partition is a <code>palindrome</code>. Return all possible palindrome partitioning of s.</p><p>A <code>palindrome</code> string is a string that reads the same backward as forward.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;aab&quot;Output: [[&quot;a&quot;,&quot;a&quot;,&quot;b&quot;],[&quot;aa&quot;,&quot;b&quot;]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h3 id="method-回溯"><a href="#method-回溯" class="headerlink" title="method: 回溯"></a>method: 回溯</h3><p>枚举每一个分割点，如果分割出来的子串是回文，就继续递归，否则这个分割点不行，跳到下一个分割点</p><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;string&gt;&gt; ret;vector&lt;string&gt; path;bool isPalindrome(string&amp; s, int i, int j) &#123;    while (i &lt; j) &#123;        if (s[i] !&#x3D; s[j]) return false;        i++;        j--;    &#125;    return true;&#125;void dfs(string&amp; s, int index) &#123;    if (index &#x3D;&#x3D; s.size()) &#123;        ret.push_back(path);        return;    &#125;    for (int i &#x3D; index; i &lt; s.size(); ++i) &#123;        if (isPalindrome(s, index, i)) &#123;            path.push_back(s.substr(index, i - index + 1));        &#125;        else continue;  &#x2F;&#x2F; 如果不是回文，就跳到下一个分割点        dfs(s, i + 1);        path.pop_back();    &#125;&#125;vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123;    dfs(s, 0);     return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>字符串可以直接截取，判断回文可以直接反转</p><p><code>s[:i]</code>意思是截取<code>s[0]</code>到<code>s[i-1]</code><br><code>s[i-1::-1]</code>意思是截取<code>s[0]</code>到<code>s[i-1]</code>并反转</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">def partition(self, s: str) -&gt; List[List[str]]:    def dfs(s, path, res):        if not s:            res.append(path[:]) # 浅拷贝就够了            return        for i in range(1, len(s) + 1):            if s[:i] &#x3D;&#x3D; s[i-1::-1]: # 是否回文                path.append(s[:i])                dfs(s[i:], path, res)                path.pop()    res &#x3D; []    dfs(s, [], res)    return res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39/40/216-组合总和</title>
      <link href="2021/06/23/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
      <url>2021/06/23/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-39-Combination-Sum"><a href="#LeetCode-39-Combination-Sum" class="headerlink" title="LeetCode 39. Combination Sum"></a>LeetCode 39. Combination Sum</h2><p><a href="https://leetcode.com/problems/combination-sum/">LeetCode</a></p><p>Given an array of distinct integers candidates and a target integer target, return a list of all <strong>unique combinations</strong> of candidates where the chosen numbers <strong>sum to target</strong>. You may return the combinations in any order.</p><p>The same number may be chosen from candidates an <strong>unlimited number of times</strong>. Two combinations are <strong>unique</strong> if the frequency of at least one of the chosen numbers is different.</p><p>It is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: candidates &#x3D; [2,3,6,7], target &#x3D; 7Output: [[2,2,3],[7]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>因为不限次数，所以下次还是可以从<code>i</code>开始取<br><strong>剪枝</strong>：取<code>nums[i]</code>之后必须保证不大于<code>target</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; ret;vector&lt;int&gt; path;void dfs(vector&lt;int&gt;&amp; nums, int target, int index, int sum) &#123;    if (sum &#x3D;&#x3D; target) &#123;        ret.push_back(path);        return;    &#125;    for (int i &#x3D; index; i &lt; nums.size() &amp;&amp; sum &lt; target; ++i) &#123;        path.push_back(nums[i]);        dfs(nums, target, i, sum + nums[i]);    &#x2F;&#x2F; 可以从i再继续取        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; nums, int target) &#123;    dfs(nums, target, 0, 0);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-40-Combination-Sum-II"><a href="#LeetCode-40-Combination-Sum-II" class="headerlink" title="LeetCode 40. Combination Sum II"></a>LeetCode 40. Combination Sum II</h2><p>Given a collection of candidate numbers and a target number, find all unique combinations in candidates where the candidate numbers sum to target.</p><p>Each number in candidates may only be used <strong>once</strong> in the combination.</p><p>Note: The solution set must not contain <strong>duplicate combinations</strong>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8Output: [[1,1,6],[1,2,5],[1,7],[2,6]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-1"><a href="#method-1" class="headerlink" title="method"></a>method</h2><p>与39题不同之处：</p><ul><li>只能使用一次，所以从<code>i + 1</code>开始取</li><li>数组有重复，但是组合不能重复，</li></ul><p><code>[1, 1, 2]</code>不能出现<code>[1, 2], [1, 2]</code>，尽管是不同的<code>1</code></p><ul><li>先排序让相同的元素排在一起</li><li><code>index=0</code>的时候，如果<code>i=1 &amp;&amp; nums[i]==nums[i - 1]</code>，说明出现了重复</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; ret;vector&lt;int&gt; path;void dfs(vector&lt;int&gt;&amp; nums, int target, int index, int sum) &#123;    if (sum &#x3D;&#x3D; target) &#123;        ret.push_back(path);        return;    &#125;    for (int i &#x3D; index; i &lt; nums.size() &amp;&amp; sum + nums[i] &lt;&#x3D; target; ++i) &#123;        if (i &gt; index &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;        path.push_back(nums[i]);        dfs(nums, target, i + 1, sum + nums[i]);        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; nums, int target) &#123;    sort(nums.begin(), nums.end());    dfs(nums, target, 0, 0);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-216-Combination-Sum-III"><a href="#LeetCode-216-Combination-Sum-III" class="headerlink" title="LeetCode 216. Combination Sum III"></a>LeetCode 216. Combination Sum III</h2><p>Find all valid combinations of k numbers that sum up to n such that the following conditions are true:</p><ul><li>Only numbers 1 through 9 are used.</li><li>Each number is used <strong>at most once</strong>.</li></ul><p>Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: k &#x3D; 3, n &#x3D; 7Output: [[1,2,4]]Explanation:1 + 2 + 4 &#x3D; 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-回溯-剪枝"><a href="#method-回溯-剪枝" class="headerlink" title="method: 回溯+剪枝"></a>method: 回溯+剪枝</h2><p><code>1-9</code>数组大小固定，选择大小<code>k</code>固定，且只能用一次</p><p><code>path</code>大小固定为<code>k</code></p><ul><li>终止条件<code>path.size() == k</code></li><li>剪枝<code>i &lt;= nums.size() - (k - path.size()) + 1</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; ret;vector&lt;int&gt; path;void dfs(int k, int n, int index, int sum) &#123;    if (path.size() &#x3D;&#x3D; k) &#123;        if (sum &#x3D;&#x3D; n) ret.push_back(path);        return;    &#125;    for (int i &#x3D; index; i &lt;&#x3D; 9 - (k - path.size()) + 1; ++i) &#123;        path.push_back(i);        dfs(k, n, i + 1, sum + i);        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) &#123;    dfs(k, n, 1, 0);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>77-组合</title>
      <link href="2021/06/23/LeetCode-77-%E7%BB%84%E5%90%88/"/>
      <url>2021/06/23/LeetCode-77-%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-77-Combinations"><a href="#LeetCode-77-Combinations" class="headerlink" title="LeetCode 77. Combinations"></a>LeetCode 77. Combinations</h2><p><a href="https://leetcode.com/problems/combinations/">LeetCode</a></p><p>Given two integers <code>n</code> and <code>k</code>, return <strong>all possible</strong> combinations of <code>k</code> numbers out of the range <code>[1, n]</code>.</p><p>You may return the answer in <strong>any order</strong>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: n &#x3D; 4, k &#x3D; 2Output:[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-回溯"><a href="#method-回溯" class="headerlink" title="method: 回溯"></a>method: 回溯</h2><center><img src="/2021/06/23/LeetCode-77-%E7%BB%84%E5%90%88/77.png#pic_center" width="100%" height="100%"></center><ul><li>不能重复取，所以下一个要<code>i+1</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; ret;vector&lt;int&gt; path;void dfs(int n, int k, int index) &#123;    if (path.size() &#x3D;&#x3D; k) &#123;     &#x2F;&#x2F; 取了k个，记录结果返回        ret.push_back(path);        return;    &#125;    for (int i &#x3D; index; i &lt;&#x3D; n - (k - path.size()) + 1; ++i) &#123;        path.push_back(i);        dfs(n, k, i + 1);        path.pop_back();    &#125;&#125;vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123;    dfs(n, k, 1);    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>剪枝</strong>：现在已经取了<code>path.size()</code>个，还需要<code>k-path.size()</code>个，但是总共只有<code>n</code>个，所以必须从小于等于<code>n-(k-path.size())+1</code>开始取，超过这个范围就取不了<code>k</code>个了<br>比如<code>n=4,k=3</code>，现在取了<code>0</code>个，接下来的取数不能大于<code>4-(3-0)+1=2</code>，也就是只可以从<code>1,2</code>开始取，超过<code>2</code>就取不到<code>3</code>个数了</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50-Pow</title>
      <link href="2021/06/23/LeetCode-50-Pow/"/>
      <url>2021/06/23/LeetCode-50-Pow/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-50-Pow"><a href="#LeetCode-50-Pow" class="headerlink" title="LeetCode 50. Pow"></a>LeetCode 50. Pow</h2><p><a href="https://leetcode.com/problems/powx-n/">LeetCode</a></p><p>Implement <code>pow(x, n)</code>, which calculates <code>x</code> raised to the power <code>n</code>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: x &#x3D; 2.00000, n &#x3D; 10Output: 1024.00000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: x &#x3D; 2.10000, n &#x3D; 3Output: 9.26100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 3:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: x &#x3D; 2.00000, n &#x3D; -2Output: 0.25000Explanation: 2^-2 &#x3D; 1&#x2F;2^2 &#x3D; 1&#x2F;4 &#x3D; 0.25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><p>在算<code>myPow(x, n/2)</code>的时候可以把结果记录下来，后面就不用再算了，因为两颗子树是完全一样的，只算一边就可以了<br>注意<code>n &lt; 0</code>的情况，要变成倒数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">double myPow(double x, int n) &#123;    if (n &#x3D;&#x3D; 0) return 1.0;    double tmp &#x3D; myPow(x, n &#x2F; 2);    if (n % 2 &#x3D;&#x3D; 0) return tmp * tmp;    else if (n &gt; 0) return tmp * tmp * x;    else return tmp &#x2F; x * tmp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(logn)$<br><code>n &lt; 0</code>应该是<code>tmp * tmp * (1/x)</code>，为了防止<code>tmp * tmp</code>溢出，把除法提到前面</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18/454-四数之和</title>
      <link href="2021/06/22/LeetCode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2021/06/22/LeetCode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-18-4Sum"><a href="#LeetCode-18-4Sum" class="headerlink" title="LeetCode 18. 4Sum"></a>LeetCode 18. 4Sum</h2><p><a href="https://leetcode.com/problems/4sum/">LeetCode</a></p><p>Given an array nums of n integers, return an array of all the unique quadruplets <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p><ul><li><code>0 &lt;= a, b, c, d &lt; n</code></li><li><code>a, b, c, and d are distinct.</code></li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>You may return the answer in any order.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [1,0,-1,0,-2,2], target &#x3D; 0Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-双指针"><a href="#method-双指针" class="headerlink" title="method: 双指针"></a>method: 双指针</h2><p>在三数之和的基础上再套一层循环，变成四个指针<code>i j l r</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123;    vector&lt;vector&lt;int&gt;&gt; ret;    sort(nums.begin(), nums.end());    for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;        for (int j &#x3D; i + 1; j &lt; nums.size(); ++j) &#123;            if (j &gt; i + 1 &amp;&amp; nums[j] &#x3D;&#x3D; nums[j - 1]) continue;            int l &#x3D; j + 1;            int r &#x3D; nums.size() - 1;            while (l &lt; r) &#123;                if (nums[i] + nums[j] + nums[l] + nums[r] &lt; target) l++;                else if (nums[i] + nums[j] + nums[l] + nums[r] &gt; target) r--;                else &#123;                    ret.push_back(vector&lt;int&gt;&#123;nums[i],nums[j],nums[l],nums[r]&#125;);                    while (l &lt; r &amp;&amp; nums[l] &#x3D;&#x3D; nums[l + 1]) l++;                    while (l &lt; r &amp;&amp; nums[r] &#x3D;&#x3D; nums[r - 1]) r--;                    l++;                    r--;                &#125;            &#125;        &#125;    &#125;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-454-4Sum-II"><a href="#LeetCode-454-4Sum-II" class="headerlink" title="LeetCode 454. 4Sum II"></a>LeetCode 454. 4Sum II</h2><p><a href="https://leetcode.com/problems/4sum-ii/">LeetCode</a></p><p>Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples <code>(i, j, k, l)</code> such that:</p><p><code>0 &lt;= i, j, k, l &lt; nnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]Output: 2Explanation:The two tuples are:1. 1 + (-2) + (-1) + 2 &#x3D; 02. 2 + (-1) + (-1) + 0 &#x3D; 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-哈希表"><a href="#method-哈希表" class="headerlink" title="method: 哈希表"></a>method: 哈希表</h2><p>用哈希表存<code>A</code>和<code>B</code>之和的结果及其出现次数<br>看<code>C</code>和<code>D</code>之和有没有其相反数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123;    unordered_map&lt;int, int&gt; hash;    for (auto a : A) &#123;        for (auto b : B) &#123;            hash[a + b]++;        &#125;    &#125;    int cnt &#x3D; 0;    for (auto c : C) &#123;        for (auto d : D) &#123;            if (hash[-(c + d)])                cnt +&#x3D; hash[-(c + d)];        &#125;        &#125;    return cnt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>150-逆波兰表达式</title>
      <link href="2021/06/22/LeetCode-150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2021/06/22/LeetCode-150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-150-Evaluate-Reverse-Polish-Notation"><a href="#LeetCode-150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="LeetCode 150. Evaluate Reverse Polish Notation"></a>LeetCode 150. Evaluate Reverse Polish Notation</h2><p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p><p>Valid operators are <code>+, -, *, and /</code>. Each operand may be an integer or another expression.</p><p>Note that division between two integers should truncate toward zero.</p><p>It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: tokens &#x3D; [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]Output: 9Explanation: ((2 + 1) * 3) &#x3D; 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-栈"><a href="#method-栈" class="headerlink" title="method: 栈"></a>method: 栈</h2><p>如果是运算符，就将栈顶的两个元素弹出进行运算，再将结果入栈</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int evalRPN(vector&lt;string&gt;&amp; tokens) &#123;    stack&lt;int&gt; st;    for (auto s : tokens) &#123;        if (s &#x3D;&#x3D; &quot;+&quot; || s &#x3D;&#x3D; &quot;-&quot; || s &#x3D;&#x3D; &quot;*&quot; || s &#x3D;&#x3D; &quot;&#x2F;&quot;) &#123;            int num1 &#x3D; st.top();            st.pop();            int num2 &#x3D; st.top();            st.pop();            if (s &#x3D;&#x3D; &quot;+&quot;) st.push(num2 + num1);            if (s &#x3D;&#x3D; &quot;-&quot;) st.push(num2 - num1);            if (s &#x3D;&#x3D; &quot;*&quot;) st.push(num2 * num1);            if (s &#x3D;&#x3D; &quot;&#x2F;&quot;) st.push(num2 &#x2F; num1);        &#125;        else st.push(stoi(s));  &#x2F;&#x2F; stoi()将string转为int    &#125;    return st.top();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1047-删除字符串中的相邻重复项</title>
      <link href="2021/06/22/LeetCode-1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>2021/06/22/LeetCode-1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-1047-Remove-All-Adjacent-Duplicates-In-String"><a href="#LeetCode-1047-Remove-All-Adjacent-Duplicates-In-String" class="headerlink" title="LeetCode 1047. Remove All Adjacent Duplicates In String"></a>LeetCode 1047. Remove All Adjacent Duplicates In String</h2><p><a href="https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/">LeetCode</a></p><p>You are given a string s consisting of lowercase English letters. A <strong>duplicate removal</strong> consists of choosing two <strong>adjacent</strong> and <strong>equal</strong> letters and removing them.</p><p>We repeatedly make duplicate removals on s until we no longer can.</p><p>Return the final string after all such duplicate removals have been made. It can be proven that the answer is <strong>unique</strong>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;abbaca&quot;Output: &quot;ca&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-栈"><a href="#method-栈" class="headerlink" title="method: 栈"></a>method: 栈</h2><p>直接用字符串当栈</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string removeDuplicates(string str) &#123;    string ret;    for (auto s : str) &#123;        if (ret.empty() || ret.back() !&#x3D; s) ret.push_back(s);        else ret.pop_back();    &#125;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17-电话号码的字母组合</title>
      <link href="2021/06/22/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"/>
      <url>2021/06/22/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-17-Letter-Combinations-of-a-Phone-Number"><a href="#LeetCode-17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="LeetCode 17. Letter Combinations of a Phone Number"></a>LeetCode 17. Letter Combinations of a Phone Number</h2><p><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/">LeetCode</a></p><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in <code>any order</code>.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><img src="/2021/06/22/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/11.png" width="50%" height="50%"></p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: digits &#x3D; &quot;23&quot;Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-回溯"><a href="#method-回溯" class="headerlink" title="method: 回溯"></a>method: 回溯</h2><p>回溯三部曲：</p><ul><li>确定回溯函数参数<br>对于给定的数字进行遍历，抓出每个数字对应的字符串，所以参数是给定的数字<code>digits</code>和遍历的下标<code>index</code></li><li>确定终止条件<br>当下标遍历完整个<code>digits</code>时返回，即<code>index == digits.size()</code></li><li>确定单层循环逻辑<br>对于每个数字对应的字符串，如<code>&quot;abc&quot;</code>，要再进行遍历表示<strong>取或者不取</strong>，如可以取<code>&#39;a&#39;</code>，或者取<code>&#39;b&#39;</code>，或者取<code>&#39;c&#39;</code></li></ul><center><img src="/2021/06/22/LeetCode-17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/111.png#pic_center" width="100%" height="100%"></center><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;private:    const string letterMap[10] &#x3D; &#123;        &quot;&quot;,        &quot;&quot;,        &quot;abc&quot;,        &quot;def&quot;,        &quot;ghi&quot;,        &quot;jkl&quot;,        &quot;mno&quot;,        &quot;pqrs&quot;,        &quot;tuv&quot;,        &quot;wxyz&quot;    &#125;;  &#x2F;&#x2F; 数字与字母对应关系public:    vector&lt;string&gt; ret;    string s;    void dfs(const string&amp; digits, int index) &#123;        if (index &#x3D;&#x3D; digits.size()) &#123;            ret.push_back(s);            return;        &#125;        int number &#x3D; digits[index] - &#39;0&#39;;        string letters &#x3D; letterMap[number];     &#x2F;&#x2F; 拿到字母        for (int i &#x3D; 0; i &lt; letters.size(); ++i) &#123;            s.push_back(letters[i]);            dfs(digits, index + 1);            s.pop_back();        &#125;    &#125;    vector&lt;string&gt; letterCombinations(string digits) &#123;        if (digits.size() &#x3D;&#x3D; 0) return ret;        dfs(digits, 0);        return ret;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15-三数之和</title>
      <link href="2021/06/21/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2021/06/21/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-15-3Sum"><a href="#LeetCode-15-3Sum" class="headerlink" title="LeetCode 15. 3Sum"></a>LeetCode 15. 3Sum</h2><p><a href="https://leetcode.com/problems/3sum/">LeetCode</a></p><p>Given an integer array nums, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j, i != k, and j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p><p>Notice that the solution set must not contain duplicate triplets.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [-1,0,1,2,-1,-4]Output: [[-1,-1,2],[-1,0,1]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>找到三个数和为0，不能重复使用同一个元素，也不能有相同的结果</p><h2 id="method-双指针"><a href="#method-双指针" class="headerlink" title="method: 双指针"></a>method: 双指针</h2><p>其实有三个指针，<code>i l r</code>，<code>i</code>负责遍历数组，<code>l</code>到<code>r</code>维护区间<code>[i+1, end)</code><br><strong>注意去重</strong></p><center><img src="/2021/06/21/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/15.png#pic_center" width="100%" height="100%"></center><p>时间复杂度：$O(n^2)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;vector&lt;int&gt;&gt; ret;    sort(nums.begin(), nums.end()); &#x2F;&#x2F; 排序    for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;        if (nums[i] &gt; 0) return ret;        if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) continue;  &#x2F;&#x2F; i的去重        int l &#x3D; i + 1;        int r &#x3D; nums.size() - 1;        while (l &lt; r) &#123;            if (nums[i] + nums[l] + nums[r] &gt; 0) r--;            else if (nums[i] + nums[l] + nums[r] &lt; 0) l++;            else &#123;                ret.push_back(vector&lt;int&gt;&#123;nums[i], nums[l], nums[r]&#125;);                while (l &lt; r &amp;&amp; nums[l] &#x3D;&#x3D; nums[l + 1]) l++;                while (l &lt; r &amp;&amp; nums[r] &#x3D;&#x3D; nums[r - 1]) r--;                l++;                r--;            &#125;        &#125;    &#125;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二阶常系数齐次线性微分方程</title>
      <link href="2021/06/20/%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B-%E4%BA%8C%E9%98%B6%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
      <url>2021/06/20/%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B-%E4%BA%8C%E9%98%B6%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>二阶常系数齐次线性微分方程</strong>的形式为：</p><script type="math/tex; mode=display">a{y}^{\prime \prime}+b{y}^{\prime}+cy=0</script><p>由于是二阶线性微分方程，所以它有两个解，记为$y_1, y_2$<br>它的特征方程为：</p><script type="math/tex; mode=display">ar^2+br+c=0</script><p>写出微分方程的特征方程后即可以用<strong>求根公式</strong>求出特征方程的解：</p><script type="math/tex; mode=display">r_{1,2} = {-b \pm \sqrt{b^2-4ac}\over 2a}</script><p>以下分情况讨论：</p><ol><li><p>当$\Delta &gt; 0$时，$r_1,r_2$是两个不相等的实根</p><script type="math/tex; mode=display">r_{1} = {-b + \sqrt{\Delta}\over 2a}, r_{2} = {-b - \sqrt{\Delta}\over 2a}</script><p>微分方程的通解为：</p><script type="math/tex; mode=display">y = C_1e^{r_1x} + C_2e^{r_2x}</script></li><li><p>当$\Delta = 0$时，$r_1,r_2$是两个相等的实根</p><script type="math/tex; mode=display">r_{1} = r_{2} = {-b \over 2a}</script><p>微分方程的通解为：</p><script type="math/tex; mode=display">y = C_1e^{r_1x} + C_2xe^{r_2x}</script></li><li><p>当$\Delta &lt; 0$时，$r_1,r_2$是一对共轭复根</p><script type="math/tex; mode=display">r_{1} = \alpha + \beta i, r_{2} = \alpha - \beta i</script><p>其中</p><script type="math/tex; mode=display">\alpha = {-b \over 2a}, \beta = {\sqrt{-\Delta}\over 2a}</script><p>微分方程的通解为：</p><script type="math/tex; mode=display">y = e^{\alpha x}(C_1 cos\beta x + C_2 sin\beta x)</script></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202-快乐数</title>
      <link href="2021/06/20/LeetCode-202-%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
      <url>2021/06/20/LeetCode-202-%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-202-Happy-Number"><a href="#LeetCode-202-Happy-Number" class="headerlink" title="LeetCode 202. Happy Number"></a>LeetCode 202. Happy Number</h2><p><a href="https://leetcode.com/problems/happy-number/">LeetCode</a></p><p>Write an algorithm to determine if a number n is happy.</p><p>A <code>happy number</code> is a number defined by the following process:</p><ul><li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li><li>Repeat the process until the number equals 1, or <code>it loops endlessly in a cycle</code> which does not include 1.</li><li>Those numbers for which this process <code>ends in 1</code> are happy.</li></ul><p>Return true if n is a happy number, and false if not.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: n &#x3D; 19Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Explanation:<br>$1^2 + 9^2 = 82$<br>$8^2 + 2^2 = 68$<br>$6^2 + 8^2 = 100$<br>$1^2 + 0^2 + 0^2 = 1$</p><p>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: n &#x3D; 2Output: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-哈希表"><a href="#method-哈希表" class="headerlink" title="method: 哈希表"></a>method: 哈希表</h2><p>记录每次平方和结果，如果出现循环返回<code>false</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int squareSum(int x) &#123;    int sum &#x3D; 0;    while (x) &#123;        sum +&#x3D; (x % 10) * (x % 10);        x &#x2F;&#x3D; 10;    &#125;    return sum;&#125;bool isHappy(int n) &#123;    unordered_set&lt;int&gt; hash;    while (1) &#123;        n &#x3D; squareSum(n);        if (n &#x3D;&#x3D; 1) return true;        if (hash.find(n) !&#x3D; hash.end()) return false;        else hash.insert(n);    &#125;    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>349-两个数组的交集</title>
      <link href="2021/06/20/LeetCode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
      <url>2021/06/20/LeetCode-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-349-Intersection-of-Two-Arrays"><a href="#LeetCode-349-Intersection-of-Two-Arrays" class="headerlink" title="LeetCode 349. Intersection of Two Arrays"></a>LeetCode 349. Intersection of Two Arrays</h2><p><a href="https://leetcode.com/problems/intersection-of-two-arrays/">LeetCode</a></p><p>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be <code>unique</code> and you may return the result in <code>any order</code>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]Output: [2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]Output: [9,4]Explanation: [4,9] is also accepted.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-哈希表"><a href="#method-哈希表" class="headerlink" title="method: 哈希表"></a>method: 哈希表</h2><p>求两个数组的交集，重复的只算一个</p><p>哈希值置1和置0可以达到去重的目的</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;    unordered_map&lt;int, int&gt; hash;    vector&lt;int&gt; ret;    for (auto n : nums1) hash[n] &#x3D; 1;    for (auto n : nums2) &#123;        if (hash[n]) &#123;            ret.push_back(n);            hash[n]--;        &#125;    &#125;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>242/383-有效的字母异位词</title>
      <link href="2021/06/20/LeetCode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
      <url>2021/06/20/LeetCode-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-242-Valid-Anagram"><a href="#LeetCode-242-Valid-Anagram" class="headerlink" title="LeetCode 242. Valid Anagram"></a>LeetCode 242. Valid Anagram</h2><p><a href="https://leetcode.com/problems/valid-anagram/">LeetCode</a></p><p>Given two strings s and t, return true if t is an anagram of s, and false otherwise.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;Output: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="题意解析"><a href="#题意解析" class="headerlink" title="题意解析"></a>题意解析</h2><p>就是看出现的字符数是不是一样的</p><h2 id="method-哈希表"><a href="#method-哈希表" class="headerlink" title="method: 哈希表"></a>method: 哈希表</h2><p>用大小为26的数组存储每个字母出现的次数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool isAnagram(string s, string t) &#123;    int num1[26] &#x3D; &#123;0&#125;;    int num2[26] &#x3D; &#123;0&#125;;    for (auto n : s) num1[n - &#39;a&#39;]++;    for (auto n : t) num2[n - &#39;a&#39;]++;    for (int i &#x3D; 0; i &lt; 26; ++i) &#123;        if (num1[i] !&#x3D; num2[i]) return false;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-383-Ransom-Note"><a href="#LeetCode-383-Ransom-Note" class="headerlink" title="LeetCode 383. Ransom Note"></a>LeetCode 383. Ransom Note</h2><p><a href="https://leetcode.com/problems/ransom-note/">LeetCode</a></p><p>Given two stings ransomNote and magazine, return true if ransomNote can be <code>constructed from magazine</code> and false otherwise.</p><p>Each letter in magazine can only be used once in ransomNote.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: ransomNote &#x3D; &quot;a&quot;, magazine &#x3D; &quot;b&quot;Output: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;ab&quot;Output: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 3:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: ransomNote &#x3D; &quot;aa&quot;, magazine &#x3D; &quot;aab&quot;Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="题意解析-1"><a href="#题意解析-1" class="headerlink" title="题意解析"></a>题意解析</h2><p>看<code>magazine</code>的字符是不是比<code>ransomNote</code>的字符多</p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>同样用哈希表存字符出现次数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool canConstruct(string ransomNote, string magazine) &#123;    int hash[26] &#x3D; &#123;0&#125;;    for (auto n : magazine) hash[n - &#39;a&#39;]++;    for (auto n : ransomNote) hash[n - &#39;a&#39;]--;    for (auto n : hash) &#123;        if (n &lt; 0) return false;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>58-翻转单词顺序</title>
      <link href="2021/06/19/%E5%89%91%E6%8C%87Offer-58-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"/>
      <url>2021/06/19/%E5%89%91%E6%8C%87Offer-58-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-58-I-翻转单词顺序"><a href="#剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="剑指 Offer 58 - I. 翻转单词顺序"></a>剑指 Offer 58 - I. 翻转单词顺序</h2><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。</p><p>示例 1：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: &quot;the sky is blue&quot;输出: &quot;blue is sky the&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>示例 2：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: &quot;  hello world!  &quot;输出: &quot;world! hello&quot;解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-1"><a href="#method-1" class="headerlink" title="method 1"></a>method 1</h2><p>用双指针把单词找出来，按逆序重新添加到新的串中<br>时间复杂度：$O(n)$<br>空间复杂度：$O(n)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string reverseWords(string s) &#123;    string res;    int l &#x3D; 0, r &#x3D; l;    while (l &lt; s.size()) &#123;        while (l &lt; s.size() &amp;&amp; isspace(s[l])) l++;        if (l &lt; s.size()) &#123;            r &#x3D; l;            while (r &lt; s.size() &amp;&amp; !isspace(s[r])) r++;            res &#x3D; &#39; &#39; + s.substr(l, r - l) + res;            l &#x3D; r;        &#125;    &#125;    if (res.size()) res.erase(res.begin()); &#x2F;&#x2F; 删掉第一个空格    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-不使用额外空间"><a href="#method-2-不使用额外空间" class="headerlink" title="method 2: 不使用额外空间"></a>method 2: 不使用额外空间</h2><ol><li>删除字符串中多余的空格</li><li>反转整个字符串</li><li>反转每个单词，跟<code>method 1</code>一样，找到单词区间<code>[l, r-1]</code></li></ol><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void reverse(string&amp; s, int start, int end) &#123;    while (start &lt; end) swap(s[start++], s[end--]);&#125;void removeExtraSpaces(string&amp; s) &#123;    int fast &#x3D; 0, slow &#x3D; 0;    while (fast &lt; s.size() &amp;&amp; s[fast] &#x3D;&#x3D; &#39; &#39;) fast++;   &#x2F;&#x2F; 前面的空格    for (; fast &lt; s.size(); ++fast) &#123;        if (fast - 1 &gt;&#x3D; 0 &amp;&amp; s[fast - 1] &#x3D;&#x3D; s[fast] &amp;&amp; s[fast] &#x3D;&#x3D; &#39; &#39;) continue;    &#x2F;&#x2F; 跳过相连的空格        else s[slow++] &#x3D; s[fast];    &#125;    if (slow - 1 &gt;&#x3D; 0 &amp;&amp; s[slow - 1] &#x3D;&#x3D; &#39; &#39;) s.resize(slow - 1);    else s.resize(slow);    &#x2F;&#x2F; 末尾如果有空格，也要删掉&#125;string reverseWords(string s) &#123;    removeExtraSpaces(s);    reverse(s, 0, s.size() - 1);    for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123;        int j &#x3D; i;        while (j &lt; s.size() &amp;&amp; s[j] !&#x3D; &#39; &#39;) j++;        reverse(s, i, j - 1);        i &#x3D; j;    &#125;    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="剑指-Offer-58-II-左旋转字符串"><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a>剑指 Offer 58 - II. 左旋转字符串</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。</p><p>示例 1：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2输出: &quot;cdefgab&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><ul><li>反转<code>[0, k)</code></li><li>反转<code>[k, end)</code></li><li>反转整个字符串</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void reverse(string&amp; s, int start, int end) &#123;    while (start &lt; end) swap(s[start++], s[end--]);&#125;string reverseLeftWords(string s, int k) &#123;    reverse(s, 0, k - 1);    reverse(s, k, s.size() - 1);    reverse(s, 0, s.size() - 1);    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>485-最大连续1的个数</title>
      <link href="2021/06/17/LeetCode-485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>2021/06/17/LeetCode-485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-485-Max-Consecutive-Ones"><a href="#LeetCode-485-Max-Consecutive-Ones" class="headerlink" title="LeetCode 485. Max Consecutive Ones"></a>LeetCode 485. Max Consecutive Ones</h2><p><a href="https://leetcode.com/problems/max-consecutive-ones/">LeetCode</a></p><p>Given a binary array nums, return the maximum number of <code>consecutive 1&#39;s</code> in the array.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [1,1,0,1,1,1]Output: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>数组元素是1，<code>cut</code>就加1，否则<code>cut</code>置零<br><code>res</code>记录<code>cnt</code>的最大值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) &#123;    int cnt &#x3D; 0, res &#x3D; 0;    for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;        cnt &#x3D; nums[i] ? cnt + 1 : 0;        res &#x3D; max(res, cnt);    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-整数反转</title>
      <link href="2021/06/17/LeetCode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
      <url>2021/06/17/LeetCode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-7-Reverse-Integer"><a href="#LeetCode-7-Reverse-Integer" class="headerlink" title="LeetCode 7. Reverse Integer"></a>LeetCode 7. Reverse Integer</h2><p><a href="https://leetcode.com/problems/reverse-integer/">LeetCode</a></p><p>Given a signed <strong>32-bit</strong> integer x, return x with its <strong>digits reversed</strong>. If reversing x causes the value to go outside the signed 32-bit integer range <code>[-2^31, 2^31 - 1]</code>, then return 0.</p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">INT_MIN &#x3D; -21,4748,3648INT_MAX &#x3D;  21,4748,3647<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>最大最小数都是十位数，如果一个9位数已经比<code>INT_MAX / 10 = 21,4748,364</code>还大了，那再加任何一位数都会溢出<br>虽然等于<code>INT_MAX / 10</code>也可能会溢出，比如<code>21,4748,3649</code>，但是注意原数是在整数范围内的，所以并不会出现这种情况</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int reverse(int x) &#123;    int num &#x3D; 0;    while (x) &#123;        if (num &lt; (INT_MIN &#x2F; 10) || num &gt; (INT_MAX &#x2F; 10)) return 0;        num &#x3D; num * 10 + x % 10;        x &#x2F;&#x3D; 10;    &#125;    return num;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>566-重塑矩阵</title>
      <link href="2021/06/17/LeetCode-566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5/"/>
      <url>2021/06/17/LeetCode-566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-566-Reshape-the-Matrix"><a href="#LeetCode-566-Reshape-the-Matrix" class="headerlink" title="LeetCode 566. Reshape the Matrix"></a>LeetCode 566. Reshape the Matrix</h2><p><a href="https://leetcode.com/problems/reshape-the-matrix/">LeetCode</a></p><p>In MATLAB, there is a handy function called <code>reshape</code> which can reshape an <code>m x n</code> matrix into a new one with a different size <code>r x c</code> keeping its original data.</p><p>You are given an <code>m x n</code> matrix mat and two integers r and c representing the row number and column number of the wanted reshaped matrix.</p><p>The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.</p><p>If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the <code>original matrix</code>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: mat &#x3D; [[1,2],[3,4]], r &#x3D; 1, c &#x3D; 4Output: [[1,2,3,4]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int r, int c) &#123;    int m &#x3D; mat.size(), n &#x3D; mat[0].size();    if (r * c !&#x3D; m * n) return mat;    vector&lt;vector&lt;int&gt;&gt; res(r, vector&lt;int&gt;(c));    int idx &#x3D; 0;    for (int i &#x3D; 0; i &lt; r; ++i) &#123;        for (int j &#x3D; 0; j &lt; c; ++j) &#123;            res[i][j] &#x3D; mat[idx &#x2F; n][idx % n];            idx++;        &#125;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>696-计数二进制子串</title>
      <link href="2021/06/16/LeetCode-696-%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/"/>
      <url>2021/06/16/LeetCode-696-%E8%AE%A1%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-696-Count-Binary-Substrings"><a href="#LeetCode-696-Count-Binary-Substrings" class="headerlink" title="LeetCode 696. Count Binary Substrings"></a>LeetCode 696. Count Binary Substrings</h2><p><a href="https://leetcode.com/problems/count-binary-substrings/">LeetCode</a></p><p>Give a binary string <code>s</code>, return the number of non-empty substrings that have the <code>same number of 0&#39;s and 1&#39;s</code>, and all the 0’s and all the 1’s in these substrings are grouped consecutively.</p><p>Substrings that occur multiple times are counted the number of times they occur.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1&#39;s and 0&#39;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p><code>preLen</code>记录之前出现的连续0或1的个数，<code>curLen</code>记录当前出现的1或0的个数</p><p>如果一直与前一个字符相同，<code>curLen</code>就一直加1<br>如果不同，就记录为<code>preLen</code>，<code>curLen</code>变为1<br>如果<code>preLen &gt;= curLen</code>，说明前面可以与后面对应，计数加1</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int countBinarySubstrings(string s) &#123;    int preLen &#x3D; 0, curLen &#x3D; 1;    int count &#x3D; 0;    for (int i &#x3D; 1; i &lt; s.size(); ++i) &#123;        if (s[i] &#x3D;&#x3D; s[i - 1]) &#123;            curLen++;        &#125;        else &#123;            preLen &#x3D; curLen;            curLen &#x3D; 1;        &#125;        if (preLen &gt;&#x3D; curLen) count++;    &#125;    return count;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>647-回文子串</title>
      <link href="2021/06/15/LeetCode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>2021/06/15/LeetCode-647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-647-Palindromic-Substrings"><a href="#LeetCode-647-Palindromic-Substrings" class="headerlink" title="LeetCode 647. Palindromic Substrings"></a>LeetCode 647. Palindromic Substrings</h2><p><a href="https://leetcode.com/problems/palindromic-substrings/">LeetCode</a></p><p>Given a string <code>s</code>, return the number of <strong>palindromic substrings</strong> in it.</p><p>A string is a palindrome when it <strong>reads the same backward as forward</strong>.</p><p>A substring is a <strong>contiguous sequence</strong> of characters within the string.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;abcb&quot;Output: 5Explanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;b&quot;, &quot;bcb&quot;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>中心是单个字符，会形成奇数回文，如<code>aba</code><br>中心是两个字符，会形成偶数回文，如<code>baab</code><br>在字符串中用两个指针从中心向两边扩展，如果相同就继续扩展，否则该中心结束</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;public:    int cnt &#x3D; 0;    void isValue(string s, int i, int j) &#123;        &#x2F;&#x2F; 这里用while，如果是回文可以一直扩展下去        while (i &gt;&#x3D; 0 &amp;&amp; j &lt; s.size() &amp;&amp; s[i] &#x3D;&#x3D; s[j]) &#123;            cnt++;            i--;    &#x2F;&#x2F; i往左扩展            j++;    &#x2F;&#x2F; j往右扩展        &#125;    &#125;    int countSubstrings(string s) &#123;        for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123;            isValue(s, i, i);       &#x2F;&#x2F; 奇数个回文            isValue(s, i, i + 1);   &#x2F;&#x2F; 偶数个回文        &#125;        return cnt;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>205-同构字符串</title>
      <link href="2021/06/14/LeetCode-205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2021/06/14/LeetCode-205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-205-Isomorphic-Strings"><a href="#LeetCode-205-Isomorphic-Strings" class="headerlink" title="LeetCode 205. Isomorphic Strings"></a>LeetCode 205. Isomorphic Strings</h2><p><a href="https://leetcode.com/problems/isomorphic-strings/">LeetCode</a></p><p>Given two strings s and t, determine if they are isomorphic.</p><p>Two strings s and t are isomorphic if <code>the characters in s can be replaced to get t</code>.</p><p>All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;egg&quot;, t &#x3D; &quot;add&quot;Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>用一个长度为<code>256</code>的数组记录每个字符上一次出现的位置<br>如果两个字符上一次出现的位置相同，就更新为这一次的位置，继续<br>否则直接返回<code>false</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool isIsomorphic(string s, string t) &#123;    int preS[256] &#x3D; &#123;0&#125;;    int preT[256] &#x3D; &#123;0&#125;;    for (int i &#x3D; 0; i &lt; s.size(); ++i) &#123;        if (preS[int(s[i])] !&#x3D; preT[int(t[i])]) return false;        preS[int(s[i])] &#x3D; i + 1;    &#x2F;&#x2F; 更新出现位置        preT[int(t[i])] &#x3D; i + 1;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>409-最长回文串</title>
      <link href="2021/06/14/LeetCode-409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>2021/06/14/LeetCode-409-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-409-Longest-Palindrome"><a href="#LeetCode-409-Longest-Palindrome" class="headerlink" title="LeetCode 409. Longest Palindrome"></a>LeetCode 409. Longest Palindrome</h2><p><a href="https://leetcode.com/problems/longest-palindrome/">LeetCode</a></p><p>Given a string str which consists of <code>lowercase or uppercase</code> letters, return the length of the <code>longest palindrome</code> that can be built with those letters.</p><p>Letters are case sensitive, for example, “Aa” is not considered a palindrome here.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;abccccdd&quot;Output: 7Explanation:One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>统计每个字母出现的次数，因为区分大小写，所以直接用<code>256</code>长度的数组</p><p>因为奇数也可以用来组成回文，比如<code>aaa</code>，长度是<code>3</code>，但我们需要的数其中的偶数，所以<code>(3 / 2) * 2 = 2</code>，就是我们要的长度<br>如果是偶数经过运算还是一样的<br>如果有奇数，经过运算就会没掉一些，所以长度会比<code>str</code>短，就加个<code>1</code>，因为奇数可以放在回文的中间</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int longestPalindrome(string str) &#123;    int nums[256] &#x3D; &#123;0&#125;;    for (auto s : str) nums[int(s)]++;    int count &#x3D; 0;    for (auto n : nums)        count +&#x3D; (n &#x2F; 2) * 2;    return count &lt; str.size() ? count + 1 : count;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20-有效括号</title>
      <link href="2021/06/11/LeetCode-20-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
      <url>2021/06/11/LeetCode-20-%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-20-Valid-Parentheses"><a href="#LeetCode-20-Valid-Parentheses" class="headerlink" title="LeetCode 20. Valid Parentheses"></a>LeetCode 20. Valid Parentheses</h2><p><a href="https://leetcode.com/problems/valid-parentheses/">LeetCode</a></p><p>Given a string s containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39; and &#39;]&#39;</code>, determine if the input string <code>is valid</code>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;()[]&#123;&#125;&quot;Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;(]&quot;Output: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-栈"><a href="#method-栈" class="headerlink" title="method: 栈"></a>method: 栈</h2><p>用栈存储左边的括号，看右边的括号能不能跟左边的对上，能对上就<code>pop()</code><br>最后返回<code>st.empty()</code>是因为</p><ul><li>如果栈是空的，说明前面都对上了，返回<code>true</code></li><li>如果栈非空，说明有左边的括号没能对上右边括号留了下来，返回<code>false</code></li></ul><p>三种情况只要有一种没对上就返回<code>false</code><br>最后看栈是不是空的，栈非空说明有没对上的，栈空才是都对上了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool isValid(string str) &#123;    stack&lt;char&gt; st;    for (auto s : str) &#123;        if (s &#x3D;&#x3D; &#39;(&#39; || s &#x3D;&#x3D;&#39;[&#39; || s &#x3D;&#x3D; &#39;&#123;&#39;) st.push(s);        else if (st.empty()) return false;        else &#123;            bool b1 &#x3D; (s &#x3D;&#x3D; &#39;)&#39; &amp;&amp; st.top() !&#x3D; &#39;(&#39;);                            bool b2 &#x3D; (s &#x3D;&#x3D; &#39;]&#39; &amp;&amp; st.top() !&#x3D; &#39;[&#39;);            bool b3 &#x3D; (s &#x3D;&#x3D; &#39;&#125;&#39; &amp;&amp; st.top() !&#x3D; &#39;&#123;&#39;);            if (b1 || b2 || b3) return false;            else st.pop();        &#125;    &#125;    return st.empty();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>61-旋转链表</title>
      <link href="2021/06/10/LeetCode-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>2021/06/10/LeetCode-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-61-Rotate-List"><a href="#LeetCode-61-Rotate-List" class="headerlink" title="LeetCode 61. Rotate List"></a>LeetCode 61. Rotate List</h2><p><a href="https://leetcode.com/problems/rotate-list/">LeetCode</a></p><p>Given the head of a linked list, rotate the list to the right by k places.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [1,2,3,4,5], k &#x3D; 2Output: [4,5,1,2,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p><code>p1</code>找到移动之后的头结点<code>p1-&gt;next</code><br><code>p2</code>指向末尾节点，可以链接成环</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* rotateRight(ListNode* head, int k) &#123;    if (!k || !head || !head-&gt;next) return head;    int len &#x3D; 0;    ListNode *dummy &#x3D; new ListNode(0, head);    while (head) &#123;        len++;        head &#x3D; head-&gt;next;    &#125;    k %&#x3D; len;    if (!k) return dummy-&gt;next;    ListNode *p1 &#x3D; dummy;    ListNode *p2 &#x3D; dummy;    while (k--) p2 &#x3D; p2-&gt;next;    while (p2-&gt;next) &#123;        p1 &#x3D; p1-&gt;next;        p2 &#x3D; p2-&gt;next;    &#125;   &#x2F;&#x2F; 找到末尾第k个节点    head &#x3D; p1-&gt;next;    &#x2F;&#x2F; p1-&gt;next是新的头结点    p1-&gt;next &#x3D; nullptr;    p2-&gt;next &#x3D; dummy-&gt;next;    return head;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p><code>p1</code>不需要根据<code>p2</code>给定的间隔<code>(k%len)</code>来移动，因为有周期，所以<code>p1</code>可以自己移动<code>len-(k%len)</code>，所以<code>p2</code>指针是没必要的，可以用已经移动到末尾的<code>head</code>来完成链接成环</p><center><img src="/2021/06/10/LeetCode-61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/111.png#pic_center" width="100%" height="100%"></center><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* rotateRight(ListNode* head, int k) &#123;    if (!k || !head || !head-&gt;next) return head;    int len &#x3D; 1;    ListNode *dummy &#x3D; new ListNode(0, head);    while (head-&gt;next) &#123;        len++;        head &#x3D; head-&gt;next;    &#125;    int add &#x3D; len - (k % len);    if (add &#x3D;&#x3D; len) return dummy-&gt;next;    head-&gt;next &#x3D; dummy-&gt;next;           &#x2F;&#x2F; 链接成环    while (add--) head &#x3D; head-&gt;next;    &#x2F;&#x2F; 找新的头结点    ListNode *newHead &#x3D; head-&gt;next;    head-&gt;next &#x3D; nullptr;    return newHead;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>86-分隔链表</title>
      <link href="2021/06/10/LeetCode-86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
      <url>2021/06/10/LeetCode-86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-86-Partition-List"><a href="#LeetCode-86-Partition-List" class="headerlink" title="LeetCode 86. Partition List"></a>LeetCode 86. Partition List</h2><p><a href="https://leetcode.com/problems/partition-list/">LeetCode</a></p><p>Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</p><p>You should <code>preserve the original relative order</code> of the nodes in each of the two partitions.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [1,4,3,2,5,2], x &#x3D; 3Output: [1,2,2,4,3,5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>一个指针<code>head</code>负责遍历，另外两个指针<code>small</code>和<code>large</code>记录满足条件的节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* partition(ListNode* head, int x) &#123;    if (!head || !head-&gt;next) return head;    ListNode *small &#x3D; new ListNode(0);    ListNode *large &#x3D; new ListNode(0);    ListNode *smallHead &#x3D; small;    ListNode *largeHead &#x3D; large;    while (head) &#123;        if (head-&gt;val &lt; x) &#123;            small-&gt;next &#x3D; head;            small &#x3D; small-&gt;next;        &#125;        else &#123;            large-&gt;next &#x3D; head;            large &#x3D; large-&gt;next;        &#125;        head &#x3D; head-&gt;next;    &#125;    small-&gt;next &#x3D; largeHead-&gt;next;    large-&gt;next &#x3D; nullptr;    return smallHead-&gt;next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>225-用队列实现栈</title>
      <link href="2021/06/10/LeetCode-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
      <url>2021/06/10/LeetCode-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-225-Implement-Stack-using-Queues"><a href="#LeetCode-225-Implement-Stack-using-Queues" class="headerlink" title="LeetCode 225. Implement Stack using Queues"></a>LeetCode 225. Implement Stack using Queues</h2><p>Implement a last in first out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal queue <code>(push, top, pop, and empty)</code>.</p><p>Implement the MyStack class:</p><p><code>void push(int x)</code> Pushes element x to the top of the stack.<br><code>int pop()</code> Removes the element on the top of the stack and returns it.<br><code>int top()</code> Returns the element on the top of the stack.<br><code>boolean empty()</code> Returns true if the stack is empty, false otherwise.</p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>往队里插入元素时，默认是在队尾插入的，所以要实现先入后出，就要先把之前的元素弹出再插入</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class MyStack &#123;public:    queue&lt;int&gt; q;    MyStack() &#123;&#125;    void push(int x) &#123;        if (!q.empty()) &#123;            int size &#x3D; q.size();            q.push(x);            while (size--) &#123;    &#x2F;&#x2F; 前面的所有元素要先弹出再插入                int tmp &#x3D; q.front();                q.pop();                q.push(tmp);            &#125;        &#125;        else q.push(x);    &#125;        int pop() &#123;        int x &#x3D; q.front();        q.pop();        return x;    &#125;    int top() &#123;        return q.front();    &#125;        bool empty() &#123;        return q.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>232-用栈实现队列</title>
      <link href="2021/06/09/LeetCode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>2021/06/09/LeetCode-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-232-Implement-Queue-using-Stacks"><a href="#LeetCode-232-Implement-Queue-using-Stacks" class="headerlink" title="LeetCode 232. Implement Queue using Stacks"></a>LeetCode 232. Implement Queue using Stacks</h2><p>Implement a first in first out (FIFO) queue using <code>only two stacks</code>. The implemented queue should support all the functions of a normal queue <code>(push, peek, pop, and empty)</code>.</p><p>Implement the MyQueue class:</p><p><code>void push(int x)</code> Pushes element x to the back of the queue.<br><code>int pop()</code> Removes the element from the front of the queue and returns it.<br><code>int peek()</code> Returns the element at the front of the queue.<br><code>boolean empty()</code> Returns true if the queue is empty, false otherwise.</p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>用两个栈模拟队列，需要<code>pop()</code>和<code>top()</code>的时候就把一个栈里面的输出来放到另一个栈里，在这过程中顺序就反了</p><p>注意：<br>如果<code>out</code>不是空的，那<code>top()</code>和<code>pop()</code>的操作都可以在<code>out</code>中实现，不需要用到<code>in</code>里面的元素，只有当<code>out</code>里面没元素了，才需要把<code>in</code>里的元素搞过来</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class MyQueue &#123;public:    stack&lt;int&gt; in;    stack&lt;int&gt; out;    MyQueue() &#123;    &#125;        void push(int x) &#123;        in.push(x);    &#125;        int pop() &#123;        in2out();        int x &#x3D; out.top();        out.pop();        return x;    &#125;        int peek() &#123;        in2out();        return out.top();    &#125;    void in2out() &#123;        if (out.empty()) &#123;            while (!in.empty()) &#123;                int x &#x3D; in.top();                in.pop();                out.push(x);            &#125;        &#125;    &#125;    bool empty() &#123;        return in.empty() &amp;&amp; out.empty();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>725-分块链表</title>
      <link href="2021/06/09/LeetCode-725-%E5%88%86%E5%9D%97%E9%93%BE%E8%A1%A8/"/>
      <url>2021/06/09/LeetCode-725-%E5%88%86%E5%9D%97%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-725-Split-Linked-List-in-Parts"><a href="#LeetCode-725-Split-Linked-List-in-Parts" class="headerlink" title="LeetCode 725. Split Linked List in Parts"></a>LeetCode 725. Split Linked List in Parts</h2><p><a href="https://leetcode.com/problems/split-linked-list-in-parts/">LeetCode</a></p><p>Given a (singly) linked list with head node root, write a function to split the linked list into <code>k consecutive linked list &quot;parts&quot;</code>.</p><p>The length of each part should be <code>as equal as possible</code>: no two parts should have a size <code>differing by more than 1</code>. This may lead to some parts being null.</p><p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size <code>greater than or equal parts occurring later</code>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: root &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k &#x3D; 3Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p><code>mod</code>余数要分配到前面的<code>num</code>每一个，也就是前面的每个<code>num</code>都要加1，直到余数减到0</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;ListNode*&gt; splitListToParts(ListNode* root, int k) &#123;    int len &#x3D; 0;    ListNode *cur &#x3D; head;    while (cur) &#123;        len++;        cur &#x3D; cur-&gt;next;    &#125;    int num &#x3D; len &#x2F; k;  &#x2F;&#x2F; 每块有多少个    int mod &#x3D; len % k;  &#x2F;&#x2F; 还剩多少个，要均匀分配    vector&lt;ListNode*&gt; res(k);    for (unsigned i &#x3D; 0; head &amp;&amp; i &lt; k; ++i) &#123;  &#x2F;&#x2F; head确保链接完最后一个元素之后可以退出        res[i] &#x3D; head;        int count &#x3D; num + (mod &gt; 0 ? 1 : 0);    &#x2F;&#x2F; 有余数就加1        mod--;        while (--count) &#123;   &#x2F;&#x2F; 从第一个节点开始走，走count-1步            head &#x3D; head-&gt;next;        &#125;        ListNode *tmp &#x3D; head-&gt;next;        head-&gt;next &#x3D; nullptr;   &#x2F;&#x2F; 断开之后块就分出来了        head &#x3D; tmp;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>445-链表相加</title>
      <link href="2021/06/07/LeetCode-445-%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/"/>
      <url>2021/06/07/LeetCode-445-%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-445-Add-Two-Numbers-II"><a href="#LeetCode-445-Add-Two-Numbers-II" class="headerlink" title="LeetCode 445. Add Two Numbers II"></a>LeetCode 445. Add Two Numbers II</h2><p><a href="https://leetcode.com/problems/add-two-numbers-ii/">LeetCode</a></p><p>You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: l1 &#x3D; [7,2,4,3], l2 &#x3D; [5,6,4]Output: [7,8,0,7]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-栈"><a href="#method-栈" class="headerlink" title="method: 栈"></a>method: 栈</h2><p>把两个链表的元素取出来放到栈里，然后再一位一位相加。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;    stack&lt;int&gt; st1;    stack&lt;int&gt; st2;    while (l1) &#123;        st1.push(l1-&gt;val);        l1 &#x3D; l1-&gt;next;    &#125;    while (l2) &#123;        st2.push(l2-&gt;val);        l2 &#x3D; l2-&gt;next;    &#125;    ListNode *head &#x3D; nullptr;    int carry &#x3D; 0;    int add1, add2;    while (!st1.empty() || !st2.empty() || carry) &#123;        if (!st1.empty()) &#123;            add1 &#x3D; st1.top();            st1.pop();        &#125;        else add1 &#x3D; 0;        if (!st2.empty()) &#123;            add2 &#x3D; st2.top();            st2.pop();        &#125;        else add2 &#x3D; 0;        int res &#x3D; add1 + add2 + carry;        carry &#x3D; res &#x2F; 10;        ListNode *resNode &#x3D; new ListNode(res % 10);        resNode-&gt;next &#x3D; head;        head &#x3D; resNode;    &#125;    return head;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>83-删除链表重复元素</title>
      <link href="2021/06/07/LeetCode-83-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
      <url>2021/06/07/LeetCode-83-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-83-Remove-Duplicates-from-Sorted-List"><a href="#LeetCode-83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="LeetCode 83. Remove Duplicates from Sorted List"></a>LeetCode 83. Remove Duplicates from Sorted List</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">LeetCode</a></p><p>Given the head of a sorted linked list, delete all <strong>duplicates</strong> such that each element appears only once. Return the linked list sorted as well.</p><p>Example 1:<br><img src="/2021/06/07/LeetCode-83-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/83.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [1,1,2]Output: [1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><p>如果当前节点和下一个节点重复了，就返回下一个节点<br>没有重复，就返回当前节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* deleteDuplicates(ListNode* head) &#123;    if (!head) return head;    head-&gt;next &#x3D; deleteDuplicates(head-&gt;next);    if (head-&gt;next &amp;&amp; head-&gt;val &#x3D;&#x3D; head-&gt;next-&gt;val) &#123;        return head-&gt;next;    &#125;    return head;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-迭代"><a href="#method-迭代" class="headerlink" title="method: 迭代"></a>method: 迭代</h2><p>如果当前节点的值与下一个节点的值相同，就删掉下一个节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* deleteDuplicates(ListNode* head) &#123;    if (!head) return head;    ListNode *dummy &#x3D; new ListNode(0, head);    while (head) &#123;        while (head-&gt;next &amp;&amp; head-&gt;next-&gt;val &#x3D;&#x3D; head-&gt;val) &#123;            head-&gt;next &#x3D; head-&gt;next-&gt;next;        &#125;        head &#x3D; head-&gt;next;    &#125;    return dummy-&gt;next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160-相交链表</title>
      <link href="2021/06/07/LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
      <url>2021/06/07/LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-160-Intersection-of-Two-Linked-Lists"><a href="#LeetCode-160-Intersection-of-Two-Linked-Lists" class="headerlink" title="LeetCode 160. Intersection of Two Linked Lists"></a>LeetCode 160. Intersection of Two Linked Lists</h2><p><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">LeetCode</a></p><p>Given the heads of two singly linked-lists headA and headB, return the node at which the <code>two lists intersect</code>. If the two linked lists have no intersection at all, return null.</p><p>It is guaranteed that there are <code>no cycles</code> anywhere in the entire linked structure.</p><p>Note that the linked lists must <code>retain their original structure</code> after the function returns.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">A:          a1 → a2                    ↘                      c1 → c2 → c3                    ↗B:    b1 → b2 → b3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Example 1:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,6,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3Output: Intersected at &#39;8&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method-1-右端对齐"><a href="#method-1-右端对齐" class="headerlink" title="method 1: 右端对齐"></a>method 1: 右端对齐</h2><p>把短的链表往后移到跟长的链表右端对齐，长的链表的指针移动相同距离，然后两指针开始遍历</p><ul><li>指针相遇说明相交，返回当前指针</li><li>没相遇会一直找到末尾<code>nullptr</code>，退出循环，也返回当前指针<code>nullptr</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;    int lenA &#x3D; 0;    int lenB &#x3D; 0;    ListNode *curA &#x3D; headA;    ListNode *curB &#x3D; headB;    while (curA) &#123;  &#x2F;&#x2F; 得到A的长度        lenA++;        curA &#x3D; curA-&gt;next;    &#125;    while (curB) &#123;  &#x2F;&#x2F; 得到B的长度        lenB++;        curB &#x3D; curB-&gt;next;    &#125;    curA &#x3D; headA;    curB &#x3D; headB;    if (lenB &gt; lenA) &#123;  &#x2F;&#x2F; 交换，让A是长的那条        swap(lenA, lenB);        swap(curA, curB);    &#125;    int len &#x3D; lenA - lenB;    while (len--) curA &#x3D; curA-&gt;next;  &#x2F;&#x2F; A移动到与B对应的地方    while (curA) &#123;        if (curA &#x3D;&#x3D; curB) return curA;        curA &#x3D; curA-&gt;next;        curB &#x3D; curB-&gt;next;    &#125;    return curA;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-指针交叉遍历"><a href="#method-2-指针交叉遍历" class="headerlink" title="method 2: 指针交叉遍历"></a>method 2: 指针交叉遍历</h2><p>一个链表的指针遍历完了，就换到另一条链表继续遍历，两个指针相遇说明有相交，没相遇最后会都等于<code>nullptr</code>返回</p><center><img src="/2021/06/07/LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/160.png#pic_center" width="100%" height="100%"></center><p>情况一：两个链表相交</p><p>链表 <code>headA</code> 和 <code>headB</code> 的长度分别是 <code>m</code> 和 <code>n</code></p><ul><li>如果 <code>a = b</code>，则两个指针会同时到达两个链表相交的节点；</li><li>如果 <code>a != b</code>，在指针 <code>pA</code> 移动了 <code>a+c+b</code> 次、指针 <code>pB</code> 移动了 <code>b+c+a</code> 次之后，两个指针会<strong>同时到达两个链表相交的节点</strong>，该节点也是两个指针第一次同时指向的节点。</li></ul><p>情况二：两个链表不相交</p><ul><li>如果 <code>m = n</code>，则两个指针会同时到达两个链表的尾节点，然后同时变成空值 <code>null</code>，此时返回 <code>null</code>；</li><li>如果 <code>m != n</code>，则由于两个链表没有公共节点，两个指针也不会同时到达两个链表的尾节点，因此两个指针都会遍历完两个链表，在指针 <code>pA</code> 移动了 <code>m+n</code> 次、指针 <code>pB</code> 移动了 <code>n+m</code> 次之后，两个指针会同时变成空值 <code>null</code>，此时返回 <code>null</code>。</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;    ListNode *pA &#x3D; headA;    ListNode *pB &#x3D; headB;    while (pA !&#x3D; pB) &#123;        if (pA) pA &#x3D; pA-&gt;next;        else pA &#x3D; headB;        if (pB) pB &#x3D; pB-&gt;next;        else pB &#x3D; headA;    &#125;    return pA;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(m+n)$，其中 <code>m</code> 和 <code>n</code> 是分别是链表 <code>headA</code> 和 <code>headB</code> 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>707-设计链表</title>
      <link href="2021/06/06/LeetCode-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
      <url>2021/06/06/LeetCode-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-707-Design-Linked-List"><a href="#LeetCode-707-Design-Linked-List" class="headerlink" title="LeetCode 707. Design Linked List"></a>LeetCode 707. Design Linked List</h2><p><a href="https://leetcode.com/problems/design-linked-list/">LeetCode</a></p><p>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.<br>A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node.<br>If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p><p>Implement the MyLinkedList class:</p><p><code>MyLinkedList()</code> Initializes the MyLinkedList object.</p><p><code>int get(int index)</code> Get the value of the indexth node in the `linked list. If the index is invalid, return <strong>-1</strong>.</p><p>void addAtHead(int val) `Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</p><p><code>void addAtTail(int val)</code> Append a node of value val as the last element of the linked list.</p><p><code>void addAtIndex(int index, int val)</code> Add a node of value val before the indexth node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted.</p><p><code>void deleteAtIndex(int index)</code> Delete the indexth node in the linked list, if the index is valid.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;][[], [1], [3], [1, 2], [1], [1], [1]]Output[null, null, null, null, 2, null, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>取节点和删节点的<code>index</code>不能到最后一个元素的下一个<code>_size</code><br>增加节点可以到最后一个元素的下一个<code>_size</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class MyLinkedList &#123;public:    struct ListNode &#123;        int val;        ListNode *next;        ListNode(int x) : val(x), next(nullptr) &#123;&#125;    &#125;;    MyLinkedList() &#123;        _dummy &#x3D; new ListNode(0);        _size &#x3D; 0;    &#125;        int get(int index) &#123;    &#x2F;&#x2F; 等于也不行，因为是空        if (index &gt;&#x3D; _size || index &lt; 0) return -1;        ListNode *cur &#x3D; _dummy-&gt;next;        while (index--) &#123;            cur &#x3D; cur-&gt;next;        &#125;        return cur-&gt;val;    &#125;        void addAtHead(int val) &#123;        ListNode *newNode &#x3D; new ListNode(val);        newNode-&gt;next &#x3D; _dummy-&gt;next;        _dummy-&gt;next &#x3D; newNode;        _size++;    &#125;        void addAtTail(int val) &#123;        ListNode *newNode &#x3D; new ListNode(val);        ListNode *cur &#x3D; _dummy;        while (cur-&gt;next) cur &#x3D; cur-&gt;next;  &#x2F;&#x2F; 找到最后一个元素        cur-&gt;next &#x3D; newNode;        _size++;    &#125;        void addAtIndex(int index, int val) &#123;        if (index &gt; _size) return;  &#x2F;&#x2F; 等于可以，因为要新建元素        ListNode *cur &#x3D; _dummy;        while (index--) cur &#x3D; cur-&gt;next;    &#x2F;&#x2F; 增加的前一个元素        ListNode *newNode &#x3D; new ListNode(val);        newNode-&gt;next &#x3D; cur-&gt;next;        cur-&gt;next &#x3D; newNode;        _size++;    &#125;        void deleteAtIndex(int index) &#123; &#x2F;&#x2F; 等于也不行，因为是空        if (index &gt;&#x3D; _size || index &lt; 0) return;         ListNode *cur &#x3D; _dummy;        while (index--) cur &#x3D; cur-&gt;next;    &#x2F;&#x2F; 删除的前一个元素        cur-&gt;next &#x3D; cur-&gt;next-&gt;next;        _size--;    &#125;private:    int _size;    ListNode *_dummy;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>524-匹配最长单词</title>
      <link href="2021/06/06/LeetCode-524-%E5%8C%B9%E9%85%8D%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/"/>
      <url>2021/06/06/LeetCode-524-%E5%8C%B9%E9%85%8D%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-524-Longest-Word-in-Dictionary-through-Deleting"><a href="#LeetCode-524-Longest-Word-in-Dictionary-through-Deleting" class="headerlink" title="LeetCode 524. Longest Word in Dictionary through Deleting"></a>LeetCode 524. Longest Word in Dictionary through Deleting</h2><p><a href="https://leetcode.com/problems/longest-word-in-dictionary-through-deleting/">LeetCode</a></p><p>Given a string s and a string array dictionary, return the <code>longest</code> string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the <code>smallest lexicographical order</code>. If there is no possible result, return the empty string.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;abpcplea&quot;, dictionary &#x3D; [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]Output: &quot;apple&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-双指针判断子序列"><a href="#method-双指针判断子序列" class="headerlink" title="method: 双指针判断子序列"></a>method: 双指针判断子序列</h2><p>剪枝：如果后面的单词长度比我短，或者跟我一样长，但字典序比我大，那就不用判断了，肯定不会是他了</p><p><strong>判断子序列</strong>：两个指针分别指向两个字符串</p><ul><li>相同的话，子串指针+1</li><li>不同的话，原串指针+1</li><li>最后判断子串指针是不是走到末尾</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool isSubstr(string s, string target) &#123;    int i &#x3D; 0, j &#x3D; 0;    while (i &lt; s.size() &amp;&amp; j &lt; target.size()) &#123;        if (s[i] &#x3D;&#x3D; target[j]) j++;        i++;    &#125;    return j &#x3D;&#x3D; target.size();&#125;string findLongestWord(string s, vector&lt;string&gt;&amp; dictionary) &#123;    string res &#x3D; &quot;&quot;;    for (auto str : dictionary) &#123;        int i &#x3D; res.size();        int j &#x3D; str.size();        if (i &gt; j || (i &#x3D;&#x3D; j &amp;&amp; res &lt; str)) continue;   &#x2F;&#x2F; 剪枝        if (isSubstr(s, str)) res &#x3D; str;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141/142-环形链表</title>
      <link href="2021/06/06/LeetCode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>2021/06/06/LeetCode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-141-Linked-List-Cycle"><a href="#LeetCode-141-Linked-List-Cycle" class="headerlink" title="LeetCode 141. Linked List Cycle"></a>LeetCode 141. Linked List Cycle</h2><p><a href="https://leetcode.com/problems/linked-list-cycle/submissions/">LeetCode</a></p><p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</p><p>Return <code>true</code> if there is a <code>cycle</code> in the linked list. Otherwise, return false.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1Output: trueExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-快慢指针"><a href="#method-快慢指针" class="headerlink" title="method: 快慢指针"></a>method: 快慢指针</h2><p>快指针一次走两格，慢指针一次走一格，如果有环，两个指针肯定会相遇</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool hasCycle(ListNode *head) &#123;    ListNode *fast &#x3D; head;    ListNode *slow &#x3D; head;    while (fast &amp;&amp; fast-&gt;next) &#123;        fast &#x3D; fast-&gt;next-&gt;next;        slow &#x3D; slow-&gt;next;        if (fast &#x3D;&#x3D; slow) return true;    &#125;    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-142-Linked-List-Cycle-II"><a href="#LeetCode-142-Linked-List-Cycle-II" class="headerlink" title="LeetCode 142. Linked List Cycle II"></a>LeetCode 142. Linked List Cycle II</h2><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/">LeetCode</a></p><p>Given a linked list, return the <strong>node where the cycle begins</strong>. If there is no cycle, return null.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</p><p>Example 1:<br><img src="/2021/06/06/LeetCode-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/142.png" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1Output: tail connects to node index 1Explanation: There is a cycle in the linked list, where tail connects to the second node.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>一个指针从快慢指针相遇地方开始遍历，一个从头开始遍历，相遇的节点就是环形的入口</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode *detectCycle(ListNode *head) &#123;    ListNode *fast &#x3D; head;    ListNode *slow &#x3D; head;    while (fast &amp;&amp; fast-&gt;next) &#123;        fast &#x3D; fast-&gt;next-&gt;next;        slow &#x3D; slow-&gt;next;        if (slow &#x3D;&#x3D; fast) &#123; &#x2F;&#x2F; 从相遇节点开始走            ListNode *l1 &#x3D; slow;            ListNode *l2 &#x3D; head;            while (l1 !&#x3D; l2) &#123;                l1 &#x3D; l1-&gt;next;                l2 &#x3D; l2-&gt;next;            &#125;            return l1;        &#125;    &#125;    return NULL;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>88-合并两个有序数组</title>
      <link href="2021/06/06/LeetCode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>2021/06/06/LeetCode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-88-Merge-Sorted-Array"><a href="#LeetCode-88-Merge-Sorted-Array" class="headerlink" title="LeetCode 88. Merge Sorted Array"></a>LeetCode 88. Merge Sorted Array</h2><p><a href="https://leetcode.com/problems/merge-sorted-array/">LeetCode</a><br>You are given two integer arrays <code>nums1</code> and <code>nums2</code>, sorted in <code>non-decreasing order</code>, and two integers <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code> respectively.</p><p>Merge <code>nums1</code> and <code>nums2</code> into a single array sorted in <code>non-decreasing order</code>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3Output: [1,2,2,3,5,6]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-归并排序"><a href="#method-归并排序" class="headerlink" title="method: 归并排序"></a>method: 归并排序</h2><p><code>p1</code>指向数组1的末尾，<code>p2</code>指向数组2的末尾，<code>cnt</code>指向合并后数组的末尾</p><ul><li><code>nums1</code>用完了，用<code>nums2</code></li><li><code>nums2</code>用完了，用<code>nums1</code></li><li>都还有，看那个大就用哪个</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;    int p1 &#x3D; m - 1;    int p2 &#x3D; n - 1;    int cnt &#x3D; m + n - 1;    while (cnt &gt;&#x3D; 0) &#123;        if (p1 &lt; 0) nums1[cnt] &#x3D; nums2[p2--];        else if (p2 &lt; 0) nums1[cnt] &#x3D; nums1[p1--]        else if (nums1[p1] &gt; nums2[p2]) nums1[cnt] &#x3D; nums1[p1--];        else nums1[cnt] &#x3D; nums2[p2--];        cnt--;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>125/680-验证回文串</title>
      <link href="2021/06/06/LeetCode-125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>2021/06/06/LeetCode-125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-125-Valid-Palindrome"><a href="#LeetCode-125-Valid-Palindrome" class="headerlink" title="LeetCode 125. Valid Palindrome"></a>LeetCode 125. Valid Palindrome</h2><p><a href="https://leetcode.com/problems/valid-palindrome/">LeetCode</a></p><p>Given a string s, determine if it is a <strong>palindrome</strong>, considering only <strong>alphanumeric</strong> characters and ignoring cases.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;A man, a plan, a canal: Panama&quot;Output: trueExplanation: &quot;amanaplanacanalpanama&quot; is a palindrome.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p><code>isalnum()</code>判断字符是不是字母或数字<br><code>isalpha()</code>判断是不是字母<br><code>isdigit()</code>判断是不是数字<br><code>isspace()</code>判断是不是空格<br><code>tolower()</code>转化为小写字母<br><code>toupper()</code>转化为大写字母</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 判断是不是字母或数字，可以用isalnum()代替bool isValue(char c) &#123;    if (isdigit(c) || isalpha(c))        return true;    return false;&#125;bool isPalindrome(string s) &#123;    int i &#x3D; 0, j &#x3D; s.size() - 1;    while (i &lt; j) &#123;        while (i &lt; j &amp;&amp; !isValue(s[i])) i++;        while (i &lt; j &amp;&amp; !isValue(s[j])) j--;        if (tolower(s[i]) !&#x3D; tolower(s[j])) return false;        ++i;        --j;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-680-Valid-Palindrome-II"><a href="#LeetCode-680-Valid-Palindrome-II" class="headerlink" title="LeetCode 680. Valid Palindrome II"></a>LeetCode 680. Valid Palindrome II</h2><p><a href="https://leetcode.com/problems/valid-palindrome-ii/">LeetCode</a></p><p>Given a string s, return true if the s can be palindrome after deleting <strong>at most one character</strong> from it.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;abca&quot;Output: trueExplanation: You could delete the character &#39;c&#39;.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-双指针"><a href="#method-双指针" class="headerlink" title="method: 双指针"></a>method: 双指针</h2><p>遇到不相等的地方，就考虑删掉一个的情况，如果删掉还不行，那就不行了</p><p>可以删掉<code>i</code>后面的，或者<code>j</code>前面的</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool isPalindrome(string s, int i, int j) &#123;    while (i &lt; j) &#123;        if (s[i] !&#x3D; s[j]) return false;        i++;        j--;    &#125;    return true;&#125;bool validPalindrome(string s) &#123;    for (int i &#x3D; 0, j &#x3D; s.size() - 1; i &lt; j; ++i, --j) &#123;        if (s[i] !&#x3D; s[j]) &#123;            return isPalindrome(s, i, j - 1) || isPalindrome(s, i + 1, j);            &#x2F;&#x2F; 删掉i后面的或j前面的        &#125;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>54-螺旋矩阵</title>
      <link href="2021/06/05/LeetCode-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"/>
      <url>2021/06/05/LeetCode-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-54-Spiral-Matrix"><a href="#LeetCode-54-Spiral-Matrix" class="headerlink" title="LeetCode 54. Spiral Matrix"></a>LeetCode 54. Spiral Matrix</h2><p><a href="https://leetcode.com/problems/spiral-matrix/">LeetCode</a></p><p>Given an <code>m x n</code> matrix, return all elements of the matrix in spiral order.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: matrix &#x3D; [[1,2,3],[4,5,6],[7,8,9]]Output: [1,2,3,6,9,8,7,4,5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>先一圈一圈输出，注意区间<strong>左闭右开</strong>，最后</p><ul><li>没有元素剩余，直接返回</li><li>剩一个，直接赋值</li><li>剩一行或者一列，循环赋值</li></ul><p><code>(i, j)</code>都是从<code>(sx, sy)</code>开始的，<code>i--</code>和<code>j--</code>的时候不能小于<code>(sx, sy)</code><br>最后<code>(n1, m1)</code>会有6中情况<code>(0, 0), (n1, 0), (0, m1)</code>这三种不用管<br><code>(1, 1), (n1, 1), (1, m1)</code>这三种要继续赋值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;    int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();    vector&lt;int&gt; res(n * m, 0);    int n1 &#x3D; n, m1 &#x3D; m;    int offset &#x3D; 1;    int startx &#x3D; 0, starty &#x3D; 0;    int cnt &#x3D; 0;    int i &#x3D; 0, j &#x3D; 0;    while (n1 &gt; 1 &amp;&amp; m1 &gt; 1) &#123;        i &#x3D; startx, j &#x3D; starty;        for (; j &lt; starty + m - offset; j++) res[cnt++] &#x3D; matrix[i][j];        for (; i &lt; startx + n - offset; i++) res[cnt++] &#x3D; matrix[i][j];        for (; j &gt; starty; j--) res[cnt++] &#x3D; matrix[i][j];  &#x2F;&#x2F; 大于起始位置        for (; i &gt; startx; i--) res[cnt++] &#x3D; matrix[i][j];        n1 -&#x3D; 2;        m1 -&#x3D; 2;        offset +&#x3D; 2;        startx++;        starty++;    &#125;    i &#x3D; startx, j &#x3D; starty;    if (n1 &#x3D;&#x3D; 1 &amp;&amp; m1 &#x3D;&#x3D; 1) res[cnt++] &#x3D; matrix[i][j];  &#x2F;&#x2F; 剩一个    else if (n1 &#x3D;&#x3D; 1 &amp;&amp; m1 &gt; 1) &#123;   &#x2F;&#x2F; 剩一行        for (; j &lt; starty + m1; j++) res[cnt++] &#x3D; matrix[i][j];    &#125;    else if (n1 &gt; 1 &amp;&amp; m1 &#x3D;&#x3D; 1) &#123;   &#x2F;&#x2F; 剩一列        for (; i &lt; startx + n1; i++) res[cnt++] &#x3D; matrix[i][j];    &#125;    else return res;    &#x2F;&#x2F; 没剩下，直接返回    return res;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-59-Spiral-Matrix-II"><a href="#LeetCode-59-Spiral-Matrix-II" class="headerlink" title="LeetCode 59. Spiral Matrix II"></a>LeetCode 59. Spiral Matrix II</h2><p><a href="https://leetcode.com/problems/spiral-matrix-ii/">LeetCode</a></p><p>Given a positive integer n, generate an <code>n x n</code> matrix filled with elements from <code>1 to n^2</code> in spiral order.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: n &#x3D; 3Output: [[1,2,3],[8,9,4],[7,6,5]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-模拟"><a href="#method-模拟" class="headerlink" title="method: 模拟"></a>method: 模拟</h2><p>一圈一圈地往里填数，每行每列都是固定的<strong>左闭右开</strong>区间</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123;    vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0));    int startx &#x3D; 0, starty &#x3D; 0; &#x2F;&#x2F; 每圈的起始点    int num &#x3D; n &#x2F; 2;    &#x2F;&#x2F; 总共需要填几圈    int offset &#x3D; 1;     &#x2F;&#x2F; 往里一层要减去的固定长度    int count &#x3D; 1;    while (num--) &#123;        int i &#x3D; startx;        int j &#x3D; starty;        for (; j &lt; starty + n - offset; ++j)    &#x2F;&#x2F; 上行            res[i][j] &#x3D; count++;        for (; i &lt; startx + n - offset; ++i)    &#x2F;&#x2F; 右列            res[i][j] &#x3D; count++;        for (; j &gt; starty; --j)     &#x2F;&#x2F; 下行            res[i][j] &#x3D; count++;        for (; i &gt; startx; --i)     &#x2F;&#x2F; 左列            res[i][j] &#x3D; count++;        startx++;        starty++;        offset +&#x3D; 2;    &#125;    if (n &amp; 1) res[startx][starty] &#x3D; count;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>209-长度最小的子数组</title>
      <link href="2021/06/05/LeetCode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>2021/06/05/LeetCode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-209-Minimum-Size-Subarray-Sum"><a href="#LeetCode-209-Minimum-Size-Subarray-Sum" class="headerlink" title="LeetCode 209. Minimum Size Subarray Sum"></a>LeetCode 209. Minimum Size Subarray Sum</h2><p><a href="https://leetcode.com/problems/minimum-size-subarray-sum/">LeetCode</a></p><p>Given an array of positive integers nums and a positive integer target, return the minimal length of a contiguous subarray <code>[numsl, numsl+1, ..., numsr-1, numsr]</code> of which the sum is greater than or equal to target. If there is no such subarray, return <strong>0</strong> instead.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]Output: 2Explanation: The subarray [4,3] has the minimal length under the problem constraint.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: target &#x3D; 4, nums &#x3D; [1,4,4]Output: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-滑动窗口"><a href="#method-滑动窗口" class="headerlink" title="method: 滑动窗口"></a>method: 滑动窗口</h2><p><code>sum</code>是区间<code>[i, j]</code>的和</p><ul><li>如果<code>sum</code>小于<code>target</code>，区间就扩大，即<code>j++</code></li><li>如果<code>sum</code>大于<code>target</code>，区间就缩小，即<code>i++</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) &#123;    int res &#x3D; INT_MAX;    int sum &#x3D; 0;    for (int i &#x3D; 0, j &#x3D; 0; j &lt; nums.size(); j++) &#123;        sum +&#x3D; nums[j]; &#x2F;&#x2F; 就硬加        while (sum &gt;&#x3D; target) &#123;            res &#x3D; min(res, j - i + 1);  &#x2F;&#x2F; 更新最小区间长度            sum -&#x3D; nums[i];            i++;    &#x2F;&#x2F; i移动，区间缩小        &#125;    &#125;    return res &#x3D;&#x3D; INT_MAX ? 0 : res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>977-有序数组的平方</title>
      <link href="2021/06/05/LeetCode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
      <url>2021/06/05/LeetCode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-977-Squares-of-a-Sorted-Array"><a href="#LeetCode-977-Squares-of-a-Sorted-Array" class="headerlink" title="LeetCode 977. Squares of a Sorted Array"></a>LeetCode 977. Squares of a Sorted Array</h2><p><a href="https://leetcode.com/problems/squares-of-a-sorted-array/">LeetCode</a></p><p>Given an integer array nums sorted in <code>non-decreasing order</code>, return an array of the <code>squares</code> of each number sorted in <code>non-decreasing order</code>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [-4,-1,0,3,10]Output: [0,1,9,16,100]Explanation: After squaring, the array becomes [16,1,0,9,100].After sorting, it becomes [0,1,9,16,100].<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-双指针"><a href="#method-双指针" class="headerlink" title="method: 双指针"></a>method: 双指针</h2><p>因为一个区间的平方，最大值肯定是在两边，所以用双指针从两边向中间遍历</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123;    vector&lt;int&gt; res(nums.size(), 0);    int cnt &#x3D; nums.size() - 1;    for (int i &#x3D; 0, j &#x3D; nums.size() - 1; i &lt;&#x3D; j;) &#123;        if (nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;            res[cnt--] &#x3D; nums[i] * nums[i];            i++;        &#125; else &#123;            res[cnt--] &#x3D; nums[j] * nums[j];            j--;        &#125;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>时间复杂度：$O(n)$<br>如果算完平方后再排序，时间复杂度是$O(n + nlogn)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>328-奇偶链表</title>
      <link href="2021/06/05/LeetCode-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
      <url>2021/06/05/LeetCode-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-328-Odd-Even-Linked-List"><a href="#LeetCode-328-Odd-Even-Linked-List" class="headerlink" title="LeetCode 328. Odd Even Linked List"></a>LeetCode 328. Odd Even Linked List</h2><p><a href="https://leetcode.com/problems/odd-even-linked-list/">LeetCode</a></p><p>Given the head of a singly linked list, group all the nodes with <code>odd indices</code> together followed by the nodes with <code>even indices</code>, and return the reordered list.</p><p>The first node is considered odd, and the second node is even, and so on.</p><p>Note that the relative order inside both the even and odd groups should remain as it was in the input.</p><p>Example 1:<br><img src="/2021/06/05/LeetCode-328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/328.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [1,2,3,4,5]Output: [1,3,5,2,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>把偶数位分离出来，最后再串在一起<br>注意奇数个和偶数个的结束条件判断</p><ul><li>奇数，<code>even == nullptr</code></li><li>偶数，<code>even-&gt;next == nullptr</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* oddEvenList(ListNode* head) &#123;    if (!head) return head;    ListNode *odd &#x3D; head;    ListNode *even &#x3D; head-&gt;next;    ListNode *evenHead &#x3D; even;  &#x2F;&#x2F; 记录偶链表头节点    while (even &amp;&amp; even-&gt;next) &#123;        odd-&gt;next &#x3D; even-&gt;next; &#x2F;&#x2F; 重指向        odd &#x3D; odd-&gt;next;        &#x2F;&#x2F; 后移        even-&gt;next &#x3D; odd-&gt;next;        even &#x3D; even-&gt;next;    &#125;    odd-&gt;next &#x3D; evenHead;    return head;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>203-移除链表元素</title>
      <link href="2021/06/05/LeetCode-203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>2021/06/05/LeetCode-203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-203-Remove-Linked-List-Elements"><a href="#LeetCode-203-Remove-Linked-List-Elements" class="headerlink" title="LeetCode 203. Remove Linked List Elements"></a>LeetCode 203. Remove Linked List Elements</h2><p><a href="https://leetcode.com/problems/remove-linked-list-elements/">LeetCode</a></p><p>Given the head of a linked list and an integer val, remove all the nodes of the linked list that has <code>Node.val == val</code>, and return the new head.</p><p>Example 1:<br><img src="/2021/06/05/LeetCode-203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/203.jpg" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [1,2,6,3,4,5,6], val &#x3D; 6Output: [1,2,3,4,5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-1-迭代"><a href="#method-1-迭代" class="headerlink" title="method 1: 迭代"></a>method 1: 迭代</h2><p>可能会连续删除多个元素，所以要用<code>while</code><br>因为会访问<code>next</code>的成员，所以必须确保<code>next</code>不为空</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* removeElements(ListNode* head, int val) &#123;    if (!head) return head;    ListNode dummy;    dummy.next &#x3D; head;    head &#x3D; &amp;dummy;    while (head) &#123;        while (head-&gt;next &amp;&amp; head-&gt;next-&gt;val &#x3D;&#x3D; val) &#123;            head-&gt;next &#x3D; head-&gt;next-&gt;next;        &#125;        head &#x3D; head-&gt;next;    &#125;    return dummy.next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-递归"><a href="#method-2-递归" class="headerlink" title="method 2: 递归"></a>method 2: 递归</h2><p>如果这个点需要删除，就返回<code>next</code>，这样这个点就没了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* removeElements(ListNode* head, int val) &#123;    if (!head) return head;    head-&gt;next &#x3D; removeElements(head-&gt;next, val);    if (head-&gt;val &#x3D;&#x3D; val) &#123;        return head-&gt;next;    &#125;    return head;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42-接雨水</title>
      <link href="2021/06/05/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>2021/06/05/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-42-Trapping-Rain-Water"><a href="#LeetCode-42-Trapping-Rain-Water" class="headerlink" title="LeetCode 42. Trapping Rain Water"></a>LeetCode 42. Trapping Rain Water</h2><p><a href="https://leetcode.com/problems/trapping-rain-water/">LeetCode</a></p><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</p><p>Example 1:<br><img src="/2021/06/05/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/42.png" alt><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-单调栈"><a href="#method-单调栈" class="headerlink" title="method: 单调栈"></a>method: 单调栈</h2><p>维护一个从栈底到栈顶递减的栈，如果下一个值不满足递减，就要出栈计算雨水值<br>注意这里出栈要用<code>while</code>，相同的元素要全部出栈再计算</p><p>雨水高度计算：不满足递减的<code>height[i]</code>，与左边维持可积水的<code>height[st.top()]</code>中的较小值，减去出栈的<code>height[topIdx]</code><br>雨水宽度计算：不满足递减的<code>i</code>，与左边维持可积水的<code>st.top()</code>下标相减再<code>-1</code></p><p>一个雨水计算完后相当于把这个坑填上</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int trap(vector&lt;int&gt;&amp; height) &#123;    stack&lt;int&gt; st;    int ret &#x3D; 0;    for (int i &#x3D; 0; i &lt; height.size(); ++i) &#123;        while (!st.empty() &amp;&amp; height[i] &gt; height[st.top()]) &#123;            int topIdx &#x3D; st.top();            while (!st.empty() &amp;&amp; height[topIdx] &#x3D;&#x3D; height[st.top()]) st.pop();            &#x2F;&#x2F; 相同的高度要全部出栈            &#x2F;&#x2F; 判断左边有没有值，也就是栈要非空才能接水            if (!st.empty()) &#123;                int h &#x3D; min(height[i], height[st.top()]) - height[topIdx];                int w &#x3D; i - st.top() - 1;                ret +&#x3D; h * w;            &#125;        &#125;        st.push(i);    &#125;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>496/503-下一个更大元素</title>
      <link href="2021/06/03/LeetCode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
      <url>2021/06/03/LeetCode-496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-496-Next-Greater-Element-I"><a href="#LeetCode-496-Next-Greater-Element-I" class="headerlink" title="LeetCode 496. Next Greater Element I"></a>LeetCode 496. Next Greater Element I</h2><p><a href="https://leetcode.com/problems/next-greater-element-i/">LeetCode</a></p><p>You are given two integer arrays nums1 and nums2 both of unique elements, where <code>nums1 is a subset of nums2</code>.</p><p>Find all the <code>next greater numbers</code> for nums1’s elements in the corresponding places of nums2.</p><p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, return -1 for this number.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2]Output: [-1,3,-1]Explanation:For number 4 , you cannot find the next greater number for it in the second array, so output -1.For number 1 , the next greater number for it in the second array is 3.For number 2 , there is no next greater number for it in the second array, so output -1.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-单调栈-哈希表"><a href="#method-单调栈-哈希表" class="headerlink" title="method: 单调栈+哈希表"></a>method: 单调栈+哈希表</h2><p>从前往后遍历，如果<code>nums[i]</code>比栈顶元素大，就把栈顶元素出栈，同时也表明栈顶元素的右边第一个比它大的数就是<code>nums[i]</code>，注意是<code>while</code>循环</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;    stack&lt;int&gt; st;    map&lt;int, int&gt; hash;    for (int i &#x3D; 0; i &lt; nums2.size(); ++i) &#123;        while (!st.empty() &amp;&amp; nums2[i] &gt; st.top()) &#123;            hash[st.top()] &#x3D; nums2[i];            st.pop();        &#125;        st.push(nums2[i]);    &#125;    vector&lt;int&gt; res;    for (auto elem : nums1)         res.push_back(hash[elem] &#x3D;&#x3D; 0 ? -1 : hash[elem]);    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-503-Next-Greater-Element-II"><a href="#LeetCode-503-Next-Greater-Element-II" class="headerlink" title="LeetCode 503. Next Greater Element II"></a>LeetCode 503. Next Greater Element II</h2><p><a href="https://leetcode.com/problems/next-greater-element-ii/">LeetCode</a></p><p>Given a <code>circular</code> integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the <code>next greater number</code> for every element in nums.</p><p>The <code>next greater number</code> of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, return -1 for this number.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [1,2,1]Output: [2,-1,2]Explanation: The first 1&#39;s next greater number is 2; The number 2 can&#39;t find next greater number. The second 1&#39;s next greater number needs to search circularly, which is also 2.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-单调栈"><a href="#method-单调栈" class="headerlink" title="method: 单调栈"></a>method: 单调栈</h2><p><strong>注意</strong>：循环数组的写法，扩大一倍，取元素的时候对<code>index</code>取模</p><p>大于<code>nums.size()</code>的就不需要再入栈了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123;    stack&lt;int&gt; st;    vector&lt;int&gt; ret(nums.size(), -1);    int n &#x3D; nums.size();    for (int i &#x3D; 0; i &lt; n * 2; ++i) &#123;        int num &#x3D; nums[i % n];        while (!st.empty() &amp;&amp; num &gt; nums[st.top()]) &#123;            ret[st.top()] &#x3D; num;            st.pop();        &#125;        if (i &lt; n) st.push(i);    &#125;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>153-寻找旋转排序数组中的最小值</title>
      <link href="2021/06/03/LeetCode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
      <url>2021/06/03/LeetCode-153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#LeetCode-153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="LeetCode 153. Find Minimum in Rotated Sorted Array"></a>LeetCode 153. Find Minimum in Rotated Sorted Array</h2><p><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">LeetCode</a></p><p>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p><p><code>[4,5,6,7,0,1,2]</code> if it was rotated 4 times.<br><code>[0,1,2,4,5,6,7]</code> if it was rotated 7 times.<br>Notice that rotating an array <code>a[0], a[1], a[2], ..., a[n-1]</code> 1 time results in the array <code>a[n-1], a[0], a[1], a[2], ..., a[n-2]</code>.</p><p>Given the sorted rotated array nums of unique elements, return the <strong>minimum</strong> element of this array.</p><p>You must write an algorithm that runs in $O(logn)$ time.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [3,4,5,1,2]Output: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-二分模板一"><a href="#method-二分模板一" class="headerlink" title="method: 二分模板一"></a>method: 二分模板一</h2><p>如果最后一个元素比第一个元素大，说明没有旋转，直接返回第一个就可以</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int findMin(vector&lt;int&gt;&amp; nums) &#123;    if (nums[0] &lt; nums.back()) return nums[0];    int l &#x3D; 0, r &#x3D; nums.size() - 1;    while (l &lt; r) &#123;        int mid &#x3D; l + r &gt;&gt; 1;        if (nums[mid] &lt; nums[0]) r &#x3D; mid;        else l &#x3D; mid + 1;    &#125;    return nums[r];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>162-寻找峰值</title>
      <link href="2021/06/03/LeetCode-162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/"/>
      <url>2021/06/03/LeetCode-162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-162-Find-Peak-Element"><a href="#LeetCode-162-Find-Peak-Element" class="headerlink" title="LeetCode 162. Find Peak Element"></a>LeetCode 162. Find Peak Element</h2><p><a href="https://leetcode.com/problems/find-peak-element/">LeetCode</a></p><p>A <strong>peak element</strong> is an element that is strictly <strong>greater than its neighbors</strong>.</p><p>Given an integer array <code>nums</code>, find a <code>peak</code> element, and return its <strong>index</strong>. If the array contains multiple peaks, return the index to any of the peaks.</p><p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.</p><p>You must write an algorithm that runs in $O(logn)$ time.</p><p>示例 1：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：nums &#x3D; [1,2,3,1]输出：2解释：3 是峰值元素，你的函数应该返回其索引 2。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>示例 2：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：nums &#x3D; [1,2,1,3,5,6,4]输出：1 或 5 解释：你的函数可以返回索引 1，其峰值元素为 2；     或者返回索引 5， 其峰值元素为 6。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-二分模板一"><a href="#method-二分模板一" class="headerlink" title="method: 二分模板一"></a>method: 二分模板一</h2><p>如果<code>mid</code>比<code>mid+1</code>大，说明峰值在左边，所以<code>r=mid</code><br>如果<code>mid</code>比<code>mid+1</code>小，说明峰值在右边，所以<code>l=mid+1</code></p><p>考虑边界条件，<code>l</code>指向倒数第二个元素，<code>r</code>指向最后一个元素，<code>mid</code>是<code>l</code><br>如果满足条件，则<code>r = mid = l</code>，退出，结果正确<br>如果不满足，则<code>l = mid + 1 = r</code>，退出，结果也正确</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;    int l &#x3D; 0, r &#x3D; nums.size() - 1;    while (l &lt; r) &#123;        int mid &#x3D; l + r &gt;&gt; 1;        if (nums[mid] &gt; nums[mid + 1]) r &#x3D; mid;        else l &#x3D; mid + 1;    &#125;    return r;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="也可以用模板二"><a href="#也可以用模板二" class="headerlink" title="也可以用模板二"></a>也可以用模板二</h2><p>模板二是上取整，所以和<code>mid-1</code>比较不会越界</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int findPeakElement(vector&lt;int&gt;&amp; nums) &#123;    int l &#x3D; 0, r &#x3D; nums.size() - 1;    while (l &lt; r) &#123;        int mid &#x3D; l + r + 1 &gt;&gt; 1;        if (nums[mid] &gt; nums[mid - 1]) l &#x3D; mid;        else r &#x3D; mid - 1;    &#125;    return l;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>74/240-搜索二维矩阵</title>
      <link href="2021/06/03/LeetCode-74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/"/>
      <url>2021/06/03/LeetCode-74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-74-Search-a-2D-Matrix"><a href="#LeetCode-74-Search-a-2D-Matrix" class="headerlink" title="LeetCode 74. Search a 2D Matrix"></a>LeetCode 74. Search a 2D Matrix</h2><p><a href="https://leetcode.com/problems/search-a-2d-matrix/">LeetCode</a></p><p>Write an efficient algorithm that searches for a value in an <code>m x n</code> matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted from left to right.</li><li>The first integer of each row is greater than the last integer of the previous row.</li></ul><p>Example 1:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: matrix &#x3D; [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target &#x3D; 3Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method-二分"><a href="#method-二分" class="headerlink" title="method: 二分"></a>method: 二分</h2><p>注意二维下标的查找方式<br>通过一维下标<strong>除以列数、模以列数</strong>索引二维矩阵<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">0   1   2   34   5   6   78   9  10  11一维下标9对应的二维下标是：[9 &#x2F; 4][9 % 4] &#x3D; [2][1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;    int n &#x3D; matrix.size(), m &#x3D; matrix[0].size();    int l &#x3D; 0, r &#x3D; n * m - 1;    while (l &lt; r) &#123;        int mid &#x3D; l + r &gt;&gt; 1;        if (matrix[mid &#x2F; m][mid % m] &gt;&#x3D; target) r &#x3D; mid;        else l &#x3D; mid + 1;    &#125;    return matrix[r &#x2F; m][r % m] &#x3D;&#x3D; target;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-240-Search-a-2D-Matrix-II"><a href="#LeetCode-240-Search-a-2D-Matrix-II" class="headerlink" title="LeetCode 240. Search a 2D Matrix II"></a>LeetCode 240. Search a 2D Matrix II</h2><p><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/">LeetCode</a></p><p>Write an efficient algorithm that searches for a target value in an <code>m x n</code> integer matrix. The matrix has the following properties:</p><p>Integers in each row are sorted in <code>ascending from left to right</code>.<br>Integers in each column are sorted in <code>ascending from top to bottom</code>.</p><p>Example 1:</p><p><img src="/2021/06/03/LeetCode-74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/240.png" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: matrix &#x3D; [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target &#x3D; 5Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method-单调性扫描"><a href="#method-单调性扫描" class="headerlink" title="method: 单调性扫描"></a>method: 单调性扫描</h2><p>从右上角看，左边的数都比它小，下边的数都比它大<br>如果大于<code>target</code>，就往左移<br>如果小于<code>target</code>，就往下移</p><p>时间复杂度：$O(n + m)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;    int l &#x3D; 0, r &#x3D; matrix[0].size() - 1;    while (l &lt; matrix.size() &amp;&amp; r &gt;&#x3D; 0) &#123;        if (matrix[l][r] &#x3D;&#x3D; target) return true;        else if (matrix[l][r] &gt; target) r--;        else l++;    &#125;    return false;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34-查找元素/35-搜索插入位置</title>
      <link href="2021/06/02/LeetCode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0/"/>
      <url>2021/06/02/LeetCode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array"><a href="#LeetCode-34-Find-First-and-Last-Position-of-Element-in-Sorted-Array" class="headerlink" title="LeetCode 34. Find First and Last Position of Element in Sorted Array"></a>LeetCode 34. Find First and Last Position of Element in Sorted Array</h2><p><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LeetCode</a></p><p>Given an array of integers nums sorted in <code>ascending order</code>, find the starting and ending position of a given target value.</p><p>If target is not found in the array, return <code>[-1, -1]</code>.</p><p>You must write an algorithm with <code>O(logn)</code> runtime complexity.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8Output: [3,4]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6Output: [-1,-1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="二分模板"><a href="#二分模板" class="headerlink" title="二分模板"></a>二分模板</h2><center><img src="/2021/06/02/LeetCode-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0/34.png#pic_center" width="100%" height="100%"></center><p><strong>模板一</strong>：找最左边的元素<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">while (l &lt; r) &#123;    int mid &#x3D; l + r &gt;&gt; 1;    if (check(mid)) r &#x3D; mid;    else l &#x3D; mid + 1；&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p><strong>模板二</strong>：找最右边的元素<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">while (l &lt; r) &#123;    int mid &#x3D; l + r + 1 &gt;&gt; 1;    if (check(mid)) l &#x3D; mid;    else r &#x3D; mid - 1；&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method-用两次二分"><a href="#method-用两次二分" class="headerlink" title="method: 用两次二分"></a>method: 用两次二分</h2><p>一次找大于等于<code>target</code>的最小值<br>一次找小于等于<code>target</code>的最大值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123;    vector&lt;int&gt; res&#123;-1, -1&#125;;    if (nums.size() &#x3D;&#x3D; 0) return res;    &#x2F;&#x2F; 第一次：找大于等于target的最小数    int l &#x3D; 0, r &#x3D; nums.size() - 1;    while (l &lt; r) &#123;        int mid &#x3D; l + r &gt;&gt; 1;        if (nums[mid] &gt;&#x3D; target) r &#x3D; mid;        else l &#x3D; mid + 1;    &#125;    if (nums[r] &#x3D;&#x3D; target) res[0] &#x3D; r;    &#x2F;&#x2F; 第二次：找小于等于target的最大数    r &#x3D; nums.size() - 1;    while (l &lt; r) &#123;        int mid &#x3D; l + r + 1 &gt;&gt; 1;        if (nums[mid] &lt;&#x3D; target) l &#x3D; mid;        else r &#x3D; mid - 1;    &#125;    if (nums[r] &#x3D;&#x3D; target) res[1] &#x3D; r;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-35-Search-Insert-Position"><a href="#LeetCode-35-Search-Insert-Position" class="headerlink" title="LeetCode 35. Search Insert Position"></a>LeetCode 35. Search Insert Position</h2><p><a href="https://leetcode.com/problems/search-insert-position/">LeetCode</a></p><p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [1,3,5,6], target &#x3D; 5Output: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [1,3,5,6], target &#x3D; 7Output: 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-二分模板一"><a href="#method-二分模板一" class="headerlink" title="method: 二分模板一"></a>method: 二分模板一</h2><p>找大于等于<code>target</code>的最小数，用模板一不会越界<br>用模板二，当<code>l</code>指向<code>nums.size() - 1</code>，<code>r</code>指向<code>nums.size()</code>的时候，<code>mid = nums.size()</code>，此时上取整越界</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123;    int l &#x3D; 0, r &#x3D; nums.size(); &#x2F;&#x2F; 可能找到最后一个元素的下一个位置    while (l &lt; r) &#123;        int mid &#x3D; l + r &gt;&gt; 1;        if (nums[mid] &gt;&#x3D; target) r &#x3D; mid;        else l &#x3D; mid + 1;    &#125;    return r;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.3-浮点数</title>
      <link href="2021/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-3-%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
      <url>2021/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-3-%E6%B5%AE%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h2><center><img src="/2021/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-3-%E6%B5%AE%E7%82%B9%E6%95%B0/7.png#pic_center" width="100%" height="100%"></center><h2 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h2><center><img src="/2021/06/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-3-%E6%B5%AE%E7%82%B9%E6%95%B0/1.png#pic_center" width="100%" height="100%"></center><p>单精度浮点数 <code>C0 A0 00 00 H</code> 的值<br><code>C0 A0 00 00 = 1100 0000 1010 0000 0000 0000 0000 0000</code><br>数符：1为负数<br>尾数部分：<code>010 0000 0000 0000 0000 0000</code><br>对应 -&gt; <code>1.01B = 1.25D</code><br>移码：<code>100 0000 1B = 129D</code><br>阶码真值=移码-偏移量=<code>129D-127D=2</code><br>浮点数真值 = $-1.25 \times 2^{2} = -5.0$</p><ol><li>确定数符、阶码、尾数</li><li>确定尾数1.M</li><li>确定阶码的真值 = 移码 - 偏置值</li><li>$(-1)^{s} \times 1.M \times 2^{E-偏置值}$</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>504-7进制数</title>
      <link href="2021/06/01/LeetCode-504-7%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
      <url>2021/06/01/LeetCode-504-7%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-504-Base-7"><a href="#LeetCode-504-Base-7" class="headerlink" title="LeetCode 504. Base 7"></a>LeetCode 504. Base 7</h2><p><a href="https://leetcode.com/problems/base-7/">LeetCode</a></p><p>Given an integer num, return a string of its base 7 representation.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: num &#x3D; 100Output: &quot;202&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: num &#x3D; -7Output: &quot;-10&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>注意进制转换的写法<br><code>int</code>如何转换为<code>char</code>，也可以用<code>to_string()</code>转换为<code>string</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string convertToBase7(int num) &#123;    if (num &#x3D;&#x3D; 0) return &quot;0&quot;;    int x &#x3D; num;    if (x &lt; 0) x &#x3D; -x;    string ret;    while (x) &#123;        ret &#x3D; char(&#39;0&#39; + x % 7) + ret;        x &#x2F;&#x3D; 7;    &#125;    if (num &lt; 0) ret &#x3D; &#39;-&#39; + ret;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.6-try语句块和异常处理</title>
      <link href="2021/06/01/C-Primer-5-6-try%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>2021/06/01/C-Primer-5-6-try%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h2>]]></content>
      
      
      
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>234-回文链表</title>
      <link href="2021/05/31/LeetCode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
      <url>2021/05/31/LeetCode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-234-Palindrome-Linked-List"><a href="#LeetCode-234-Palindrome-Linked-List" class="headerlink" title="LeetCode 234. Palindrome Linked List"></a>LeetCode 234. Palindrome Linked List</h2><p><a href="https://leetcode.com/problems/palindrome-linked-list/">LeetCode</a></p><p>Given the head of a singly linked list, return true if it is a <strong>palindrome</strong>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [1,2,2,1]Output: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-1"><a href="#method-1" class="headerlink" title="method 1:"></a>method 1:</h2><p>反转后半段链表，头尾指针从两边向中间比较</p><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* reverseList(ListNode *head) &#123;    if (!head || !head-&gt;next) return head;    ListNode *newHead &#x3D; reverseList(head-&gt;next);    head-&gt;next-&gt;next &#x3D; head;    head-&gt;next &#x3D; NULL;    return newHead;&#125;bool isPalindrome(ListNode* head) &#123;    ListNode *slow &#x3D; head;    ListNode *fast &#x3D; head;    while(fast &amp;&amp; fast-&gt;next) &#123;        slow &#x3D; slow-&gt;next;        fast &#x3D; fast-&gt;next-&gt;next;    &#125;    ListNode *tail &#x3D; reverseList(slow);    while (head &amp;&amp; tail) &#123;        if (head-&gt;val !&#x3D; tail-&gt;val) return false;        head &#x3D; head-&gt;next;        tail &#x3D; tail-&gt;next;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="改进一下"><a href="#改进一下" class="headerlink" title="改进一下"></a>改进一下</h2><p>可以在找中间点的过程中反转前半段链表</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool isPalindrome(ListNode* head) &#123;    if (!head || !head-&gt;next) return true;    ListNode *slow &#x3D; head;    ListNode *fast &#x3D; head;    ListNode *pre &#x3D; NULL;    ListNode *tmp &#x3D; NULL;    while (fast &amp;&amp; fast-&gt;next) &#123;        fast &#x3D; fast-&gt;next-&gt;next;        tmp &#x3D; slow-&gt;next;        slow-&gt;next &#x3D; pre;        pre &#x3D; slow;        slow &#x3D; tmp;    &#125;    if (fast) tmp &#x3D; tmp-&gt;next;  &#x2F;&#x2F; 如果是奇数个节点，中间点不用比较    while (pre &amp;&amp; tmp) &#123;        if (pre-&gt;val !&#x3D; tmp-&gt;val) return false;        pre &#x3D; pre-&gt;next;        tmp &#x3D; tmp-&gt;next;    &#125;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-递归"><a href="#method-2-递归" class="headerlink" title="method 2: 递归"></a>method 2: 递归</h2><p>如果要求不能修改链表，只能用递归<br>因为递归总是先从最后一个元素开始处理的，相当于有个指针从后往前走<br>所以用一个全局的指针从前往后走就可以相互比较了</p><p>利用栈<strong>先进后出</strong>的特性从后往前遍历</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode *front &#x3D; nullptr;bool traversal(ListNode *cur) &#123;    if (!cur) return true;    if (!traversal(cur-&gt;next)) return false;    if (cur-&gt;val !&#x3D; front-&gt;val) return false;    front &#x3D; front-&gt;next;    return true;    &#x2F;&#x2F; 前面的条件都过了，说明到此为止是回文&#125;bool isPalindrome(ListNode* head) &#123;    ListNode *fast &#x3D; head;    ListNode *slow &#x3D; head;    while (fast &amp;&amp; fast-&gt;next) &#123;        fast &#x3D; fast-&gt;next-&gt;next;        slow &#x3D; slow-&gt;next;    &#125;    front &#x3D; head;    return traversal(slow);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先找到中间节点，从中间节点开始递归</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24-两两交换链表中的节点</title>
      <link href="2021/05/31/LeetCode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>2021/05/31/LeetCode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-24-Swap-Nodes-in-Pairs"><a href="#LeetCode-24-Swap-Nodes-in-Pairs" class="headerlink" title="LeetCode 24. Swap Nodes in Pairs"></a>LeetCode 24. Swap Nodes in Pairs</h2><p><a href="https://leetcode.com/problems/swap-nodes-in-pairs/">LeetCode</a></p><p>Given a linked list, <code>swap</code> every <code>two adjacent nodes</code> and return its head. You must solve the problem without modifying the values in the list’s nodes.</p><p><img src="/2021/05/31/LeetCode-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/24.png" alt></p><p>示例 1：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：head &#x3D; [1,2,3,4]输出：[2,1,4,3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-递归"><a href="#method-递归" class="headerlink" title="method: 递归"></a>method: 递归</h2><p>返回的是要交换的两两节点的下一个节点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* swapPairs(ListNode* head) &#123;    if (!head || !head-&gt;next) return head;    ListNode *temp &#x3D; head-&gt;next;    &#x2F;&#x2F; 记录后向节点，待会会断开链接    head-&gt;next &#x3D; swapPairs(head-&gt;next-&gt;next);    temp-&gt;next &#x3D; head;      &#x2F;&#x2F; 第二个节点指向第一个节点    return temp;            &#x2F;&#x2F; 返回新的头结点&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-计算机硬件</title>
      <link href="2021/05/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"/>
      <url>2021/05/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<center><img src="/2021/05/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/4.png#pic_center" width="80%" height="80%"></center><center><img src="/2021/05/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/5.png#pic_center" width="80%" height="80%"></center><p>主存：内存条<br>辅存：机械硬盘、固态硬盘</p><h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><ul><li>输入设备</li><li>输出设备</li><li>主存储器</li><li>运算器</li><li>控制器</li></ul><p>主存储器、运算器、控制器构成了<strong>主机</strong></p><p>冯诺依曼结构：以运算器为中心<br>现代计算机结构：以存储器为中心，<code>CPU = 运算器 + 控制器</code></p><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><center><img src="/2021/05/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/8.png#pic_center" width="80%" height="80%"></center><ul><li>存储体</li><li><code>MAR(Memory Address Register)</code>存储地址寄存器</li><li><code>MDR(Memory Data Register)</code>存储数据寄存器</li></ul><p>每个地址对应一个存储单元<br>存储单元：每个存储单元存放一串二进制代码<br>存储字<code>(word)</code>：存储单元中二进制代码的组合<br>存储字长：存储单元中二进制代码的位数</p><p><code>MAR = 4</code>位，说明有$2^{4}$个存储单元<br><code>MDR = 16</code>位，说明存储单元是<code>16</code>位，即<code>1word = 16bit</code></p><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p>用于实现算术运算、逻辑运算</p><ul><li><code>ACC(Accumulator)</code>: 累加器，用于存放操作数或运算结果</li><li><code>MQ(Multiple-Quotient Register)</code>: 乘商寄存器，在乘除运算时，用于存放操作数或运算结果</li><li><code>X</code>: 通用的操作数寄存器，用于存放操作数</li><li><code>ALU(Arithmetic and Logic Unit)</code>: 算术逻辑单元，通过内部复杂的电路实现算术和逻辑运算</li></ul><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><ul><li><code>CU(Control Unit)</code>: 控制单元，分析指令，放出控制信号</li><li><code>IR(Instruction Register)</code>: 指令寄存器，存放当前执行的指令</li><li><code>PC(Program Counter)</code>: 程序计数器，存放下一条指令地址，有自动加1功能</li></ul><p>完成一条指令</p><ul><li><code>PC</code>: 取指令</li><li><code>IR</code>: 分析指令</li><li><code>CU</code>: 执行指令</li></ul><center><img src="/2021/05/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/7.png#pic_center" width="80%" height="80%"></center>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>58-最后一个单词的长度</title>
      <link href="2021/05/29/LeetCode-58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
      <url>2021/05/29/LeetCode-58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-58-Length-of-Last-Word"><a href="#LeetCode-58-Length-of-Last-Word" class="headerlink" title="LeetCode 58. Length of Last Word"></a>LeetCode 58. Length of Last Word</h2><p><a href="https://leetcode.com/problems/length-of-last-word/">LeetCode</a></p><p>Given a string s consists of some words separated by spaces, return the length of the last word in the string. If the last word does not exist, return <strong>0</strong>.</p><p>A <code>word</code> is a maximal substring consisting of non-space characters only.</p><p>Example 1:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;Hello World&quot;Output: 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>Example 2:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot; &quot;Output: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>因为后面可能有空格，所以得先找到第一个非空格的元素，再从这个元素开始找是空格的元素</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int lengthOfLastWord(string s) &#123;    int r &#x3D; s.size() - 1;    while (r &gt;&#x3D; 0 &amp;&amp; s[r] &#x3D;&#x3D; &#39; &#39;) r--;    int l &#x3D; r;    while (l &gt;&#x3D; 0 &amp;&amp; s[l] !&#x3D; &#39; &#39;) l--;    return r - l;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>215-数组中的第k个最大元素</title>
      <link href="2021/05/29/LeetCode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
      <url>2021/05/29/LeetCode-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-215-Kth-Largest-Element-in-an-Array"><a href="#LeetCode-215-Kth-Largest-Element-in-an-Array" class="headerlink" title="LeetCode 215. Kth Largest Element in an Array"></a>LeetCode 215. Kth Largest Element in an Array</h2><p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/">LeetCode</a></p><p>Given an integer array <code>nums</code> and an integer <code>k</code>, return the <code>kth</code> largest element in the array.</p><p>Note that it is the <code>kth</code> largest element in the sorted order, not the <code>kth</code> distinct element.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [3,2,1,5,6,4], k &#x3D; 2Output: 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [3,2,3,1,2,4,5,5,6], k &#x3D; 4Output: 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>维护一个小根堆（从小到大排序），如果新的数比堆顶元素大，就把堆顶元素弹出，新的数入队<br>如果队列是<code>|4|6|</code>，4是第二大的数，后面又来个5，那4就不是第二大的数了，所以把4弹出，5入队，至于6和5谁是第二大的数，优先队列按从小到大排序之后就知道了</p><p><strong>注意</strong>：<br>小根堆的写法<br><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code><br>同理，大根堆<br><code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt;</code><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;    for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;        q.push(nums[i]);        if (q.size() &gt; k) q.pop();    &#125;    return q.top();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-两数之和</title>
      <link href="2021/05/29/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2021/05/29/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-1-Two-Sum"><a href="#LeetCode-1-Two-Sum" class="headerlink" title="LeetCode 1. Two Sum"></a>LeetCode 1. Two Sum</h2><p><a href="https://leetcode.com/problems/two-sum/">LeetCode</a></p><p>Given an array of integers nums and an integer target, return <code>indices</code> of the two numbers such that they <code>add up to target</code>.</p><p>You may assume that each input would have <code>exactly one solution</code>, and you may <code>not use the same element twice</code>.</p><p>You can return the answer in <code>any order</code>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [2,7,11,15], target &#x3D; 9Output: [0,1]Output: Because nums[0] + nums[1] &#x3D;&#x3D; 9, we return [0, 1].<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: nums &#x3D; [3,2,4], target &#x3D; 6Output: [1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-哈希表"><a href="#method-哈希表" class="headerlink" title="method: 哈希表"></a>method: 哈希表</h2><p>用<code>map</code>存储值和下标的映射，用<code>unordered_map</code>可以快一点</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;    unordered_map&lt;int, int&gt; mp;    vector&lt;int&gt; res(2);    for (unsigned i &#x3D; 0; i &lt; nums.size(); ++i) &#123;        int tmp &#x3D; target - nums[i];        if (mp.find(tmp) !&#x3D; mp.end()) &#123;            res[0] &#x3D; i;            res[1] &#x3D; mp[tmp];            return res;        &#125;        else mp[nums[i]] &#x3D; i;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-167-Two-Sum-II-Input-array-is-sorted"><a href="#LeetCode-167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="LeetCode 167. Two Sum II - Input array is sorted"></a>LeetCode 167. Two Sum II - Input array is sorted</h2><p><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">LeetCode</a></p><p>Given an array of integers numbers that is already <code>sorted</code> in non-decreasing order, find two numbers such that they add up to a specific target number.</p><p>Return the indices of the two numbers (1-indexed) as an integer array answer of size 2, where <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length.</code></p><p>The tests are generated such that there is <code>exactly one solution</code>. You may <code>not use the same element twice</code>.</p><p>Example 1:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9输出：[1,2]解释：2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="method-二分-哈希"><a href="#method-二分-哈希" class="headerlink" title="method: 二分+哈希"></a>method: 二分+哈希</h2><p>用二分法优化右指针的位置：用模板二，找到和<code>nums[0]</code>相加小于等于<code>target</code>的最大数，因为<code>nums[0] + nums[mid]</code>已经小于等于<code>target</code>了，再往右就是大于<code>target</code>了，所以没必要再往右找了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;    vector&lt;int&gt; res(2);    int l &#x3D; 0, r &#x3D; nums.size() - 1;    while (l &lt; r) &#123;        int mid &#x3D; (l + r + 1) &gt;&gt; 1;        if (nums[mid] + nums[0] &lt;&#x3D; target) l &#x3D; mid;        else r &#x3D; mid - 1;    &#125;    unordered_map&lt;int, int&gt; hash;    for (int i &#x3D; 0; i &lt;&#x3D; r; ++i) &#123;        int tmp &#x3D; target - nums[i];        if (hash.find(tmp) !&#x3D; hash.end()) &#123;            res[0] &#x3D; hash[tmp] + 1; &#x2F;&#x2F; 哈希表值肯定比i小，所以放前面            res[1] &#x3D; i + 1;            return res;        &#125;        else hash[nums[i]] &#x3D; i;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以不用哈希<br>既然是一个有序区间<code>[l, r]</code>找和为某个数，那么大了就 <code>r--</code>，小了就 <code>l++</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;    vector&lt;int&gt; res&#123;0, 0&#125;;    int l &#x3D; 0, r &#x3D; nums.size() - 1;    while (l &lt; r) &#123;        int mid &#x3D; (l + r + 1) &gt;&gt; 1;        if (nums[mid] + nums[0] &lt;&#x3D; target) l &#x3D; mid;        else r &#x3D; mid - 1;    &#125;    l &#x3D; 0;    while (l &lt; r) &#123;        if (nums[l] + nums[r] &#x3D;&#x3D; target) &#123;            res[0] &#x3D; l + 1;            res[1] &#x3D; r + 1;            return res;        &#125;        else if (nums[l] + nums[r] &lt; target) l++;        else r--;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>735-行星碰撞</title>
      <link href="2021/05/29/LeetCode-735-%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E/"/>
      <url>2021/05/29/LeetCode-735-%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-735-Asteroid-Collision"><a href="#LeetCode-735-Asteroid-Collision" class="headerlink" title="LeetCode 735. Asteroid Collision"></a>LeetCode 735. Asteroid Collision</h2><p><a href="https://leetcode.com/problems/asteroid-collision/">LeetCode</a></p><p>We are given an array asteroids of integers representing asteroids in a row.</p><p>For each asteroid, the absolute value represents its size, and the sign represents its direction (<code>positive meaning right, negative meaning left</code>). Each asteroid moves at the same speed.</p><p>Find out the state of the asteroids after all collisions. If two asteroids meet, <code>the smaller one will explode</code>. If both are the same size, <code>both will explode</code>. Two asteroids moving in the same direction will never meet.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: asteroids &#x3D; [5,10,-5]Output: [5,10]Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: asteroids &#x3D; [8,-8]Output: []Explanation: The 8 and -8 collide exploding each other.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-栈"><a href="#method-栈" class="headerlink" title="method: 栈"></a>method: 栈</h2><ul><li>正数就直接入栈</li><li>负数要考虑几种情况<ul><li>栈顶元素是正数并且小于<code>nums[i]</code>的相反数，要退栈，这个要<code>while</code></li><li>栈空或者栈顶元素是负数，<code>nums[i]</code>入栈(正数可以放到这种情况里)</li><li>否则栈非空并且栈顶是正数，<code>nums[i]</code>是负数，如果栈顶等于<code>-nums[i]</code>，要出栈</li></ul></li><li>最后把栈里的元素逆序存到<code>vector</code>里</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; asteroidCollision(vector&lt;int&gt;&amp; nums) &#123;    stack&lt;int&gt; st;    for (int i &#x3D; 0; i &lt; nums.size(); ++i) &#123;        while (!st.empty() &amp;&amp; st.top() &gt; 0 &amp;&amp; st.top() &lt; -nums[i]) st.pop();        if (st.empty() || st.top() &lt; 0 || nums[i] &gt; 0) st.push(nums[i]);        else if (st.top() &#x3D;&#x3D; -nums[i]) st.pop();    &#125;    vector&lt;int&gt; ret(st.size());    for (int i &#x3D; st.size() - 1; i &gt;&#x3D; 0; --i) &#123;        ret[i] &#x3D; st.top();        st.pop();    &#125;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.11-类型转换</title>
      <link href="2021/05/28/C-Primer-4-11-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>2021/05/28/C-Primer-4-11-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>任何具有明确定义的类型转换，只要不包括底层<code>const</code>，都可以使用<code>static_cast</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">double slope &#x3D; static_cast&lt;double&gt;(j) &#x2F; i;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>static_cast</code>将<code>void*</code>指针转换回原来的类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 任何非常量对象的地址都能存入void*void *p &#x3D; &amp;d;doule *dp &#x3D; static_cast&lt;double*&gt;(p);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>改变对象的底层const，不能改变类型<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const char *p;char *p &#x3D; const_cast&lt;char*&gt;(pc);&#x2F;&#x2F; 通过p写值是未定义的行为<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>强制类型转换</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int *ip;char *pc &#x3D; reinterpret_cast&lt;char*&gt;(ip);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>876-链表的中间节点</title>
      <link href="2021/05/28/LeetCode-876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/"/>
      <url>2021/05/28/LeetCode-876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-876-Middle-of-the-Linked-List"><a href="#LeetCode-876-Middle-of-the-Linked-List" class="headerlink" title="LeetCode 876. Middle of the Linked List"></a>LeetCode 876. Middle of the Linked List</h2><p><a href="https://leetcode.com/problems/middle-of-the-linked-list/">LeetCode</a></p><p>Given a <code>non-empty</code>, singly linked list with head node head, return a <code>middle node</code> of linked list.</p><p>If there are two middle nodes, return the <code>second middle node</code>.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: [1,2,3,4,5]Output: Node 3 from this list (Serialization: [3,4,5])The returned node has value 3.  (The judge&#39;s serialization of this node is [3,4,5]).Note that we returned a ListNode object ans, such that:ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, and ans.next.next.next &#x3D; NULL.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>Example 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: [1,2,3,4,5,6]Output: Node 4 from this list (Serialization: [4,5,6])Since the list has two middle nodes with values 3 and 4, we return the second one.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-双指针"><a href="#method-双指针" class="headerlink" title="method: 双指针"></a>method: 双指针</h2><p>快指针每次走两步，慢指针每次走一步，用快指针作为判断条件</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* middleNode(ListNode* head) &#123;    ListNode *fast &#x3D; head;    ListNode *slow &#x3D; head;    while (fast &amp;&amp; fast-&gt;next) &#123;        fast &#x3D; fast-&gt;next-&gt;next;        slow &#x3D; slow-&gt;next;    &#125;    return slow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18-删除链表的节点</title>
      <link href="2021/05/28/%E5%89%91%E6%8C%87Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>2021/05/28/%E5%89%91%E6%8C%87Offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-18-删除链表的节点"><a href="#剑指-Offer-18-删除链表的节点" class="headerlink" title="剑指 Offer 18. 删除链表的节点"></a>剑指 Offer 18. 删除链表的节点</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动</p><p>示例 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: head &#x3D; [4,5,1,9], val &#x3D; 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* deleteNode(ListNode* head, int val) &#123;    ListNode dummy(0, NULL);    dummy.next &#x3D; head;    head &#x3D; &amp;dummy;    while (head-&gt;next) &#123;        if (head-&gt;next-&gt;val &#x3D;&#x3D; val) &#123;            head-&gt;next &#x3D; head-&gt;next-&gt;next;            break;        &#125;        head &#x3D; head-&gt;next;    &#125;    return dummy.next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>739-每日温度</title>
      <link href="2021/05/28/LeetCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
      <url>2021/05/28/LeetCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-739-Daily-Temperatures"><a href="#LeetCode-739-Daily-Temperatures" class="headerlink" title="LeetCode 739. Daily Temperatures"></a>LeetCode 739. Daily Temperatures</h2><p><a href="https://leetcode.com/problems/daily-temperatures/">LeetCode</a></p><p>Given a list of daily temperatures temperatures, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.</p><p>For example, given the list of temperatures temperatures = <code>[73, 74, 75, 71, 69, 72, 76, 73]</code>, your output should be <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>.</p><p>Note: The length of temperatures will be in the range <code>[1, 30000]</code>. Each temperature will be an integer in the range <code>[30, 100].</code></p><h2 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h2><center><img src="/2021/05/28/LeetCode-739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/222.png#pic_center" width="100%" height="100%"></center><h2 id="method-单调栈"><a href="#method-单调栈" class="headerlink" title="method: 单调栈"></a>method: 单调栈</h2><p>从栈底到栈顶的下标在数组<code>arr</code>中对应的值是单调不升的</p><p>从前往后遍历，如果比栈顶元素小，就入栈，否则一直把栈顶元素弹出，直到栈空或者可以入栈为止。</p><p>入栈的是数组的下标，因为可以用下标找元素，但不能用元素找下标</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; arr) &#123;    stack&lt;int&gt; st;    vector&lt;int&gt; ret(arr.size());    for (int i &#x3D; 0; i &lt; arr.size(); ++i) &#123;        while (!st.empty() &amp;&amp; arr[i] &gt; arr[st.top()]) &#123;            ret[st.top()] &#x3D; i - st.top();   &#x2F;&#x2F; 下标的差值            st.pop();        &#125;        st.push(i);    &#125;    return ret;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>237-删除链表中的节点</title>
      <link href="2021/05/28/LeetCode-237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
      <url>2021/05/28/LeetCode-237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-237-Delete-Node-in-a-Linked-List"><a href="#LeetCode-237-Delete-Node-in-a-Linked-List" class="headerlink" title="LeetCode 237. Delete Node in a Linked List"></a>LeetCode 237. Delete Node in a Linked List</h2><p><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/">LeetCode</a></p><p>Write a function to <code>delete a node</code> in a singly-linked list. You will <code>not</code> be given access to the <code>head</code> of the list, instead you will be given access to <code>the node to be deleted</code> directly.</p><p>It is guaranteed that the node to be deleted is <code>not a tail node</code> in the list.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: head &#x3D; [4,5,1,9], node &#x3D; 5Output: [4,1,9]Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><center><img src="/2021/05/28/LeetCode-237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/3.png#pic_center" width="100%" height="100%"></center><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void deleteNode(ListNode* node) &#123;    node-&gt;val &#x3D; node-&gt;next-&gt;val;    &#x2F;&#x2F; 把自己赋值为下一个节点    node-&gt;next &#x3D; node-&gt;next-&gt;next;  &#x2F;&#x2F; 删除下一个节点&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>461-汉明距离</title>
      <link href="2021/05/28/LeetCode-461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/"/>
      <url>2021/05/28/LeetCode-461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-461-Hamming-Distance"><a href="#LeetCode-461-Hamming-Distance" class="headerlink" title="LeetCode 461. Hamming Distance"></a>LeetCode 461. Hamming Distance</h2><p><a href="https://leetcode.com/problems/hamming-distance/">LeetCode</a></p><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers x and y, return the <strong>Hamming distance</strong> between them.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: x &#x3D; 1, y &#x3D; 4Output: 2Explanation:1   (0 0 0 1)4   (0 1 0 0)       ↑   ↑The above arrows point to positions where the corresponding bits are different.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>转化为计算异或结果中<code>1</code>的个数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int hammingDistance(int x, int y) &#123;    int z &#x3D; x ^ y;    int cnt &#x3D; 0;    while (z) &#123;        if (z &amp; 1) cnt++;        z &gt;&gt;&#x3D; 1;    &#125;    return cnt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>n &amp; (n-1)</code>可以去掉<code>n</code>最低位的<code>1</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int hammingDistance(int x, int y) &#123;    int z &#x3D; x ^ y;    int cnt &#x3D; 0;    while (z) &#123;        z &amp;&#x3D; (z - 1);        cnt++;    &#125;    return cnt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>344/345-反转字符串</title>
      <link href="2021/05/28/LeetCode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2021/05/28/LeetCode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-344-Reverse-String"><a href="#LeetCode-344-Reverse-String" class="headerlink" title="LeetCode 344. Reverse String"></a>LeetCode 344. Reverse String</h2><p><a href="https://leetcode.com/problems/reverse-string/">LeetCode</a></p><p>Write a function that reverses a string. The input string is given as an array of characters s.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]Output: [&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-反向双指针"><a href="#method-反向双指针" class="headerlink" title="method: 反向双指针"></a>method: 反向双指针</h2><p>两个指针从两边同时向中间遍历，不断交换元素</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void reverseString(vector&lt;char&gt;&amp; s) &#123;    int l &#x3D; 0, r &#x3D; s.size() - 1;    while (l &lt; r) &#123;        swap(s[l], s[r]);        l++;        r--;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-345-Reverse-Vowels-of-a-String"><a href="#LeetCode-345-Reverse-Vowels-of-a-String" class="headerlink" title="LeetCode 345. Reverse Vowels of a String"></a>LeetCode 345. Reverse Vowels of a String</h2><p><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/submissions/">LeetCode</a></p><p>Given a string s, reverse only all the vowels in the string and return it.</p><p>The vowels are ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’, and they can appear in both cases.</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: s &#x3D; &quot;hello&quot;Output: &quot;holle&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-集合存储元音字母"><a href="#method-集合存储元音字母" class="headerlink" title="method: 集合存储元音字母"></a>method: 集合存储元音字母</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string reverseVowels(string s) &#123;    set&lt;char&gt; st&#123;&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;,&#39;A&#39;,&#39;E&#39;,&#39;I&#39;,&#39;O&#39;,&#39;U&#39;&#125;;    int l &#x3D; 0, r &#x3D; s.size() - 1;    while (l &lt; r) &#123;        while (l &lt; r &amp;&amp; st.find(s[l]) &#x3D;&#x3D; st.end()) l++;        while (l &lt; r &amp;&amp; st.find(s[r]) &#x3D;&#x3D; st.end()) r--;        swap(s[l], s[r]);        l++;        r--;    &#125;    return s;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>191-位1的个数</title>
      <link href="2021/05/28/LeetCode-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>2021/05/28/LeetCode-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-191-Number-of-1-Bits"><a href="#LeetCode-191-Number-of-1-Bits" class="headerlink" title="LeetCode 191. Number of 1 Bits"></a>LeetCode 191. Number of 1 Bits</h2><p><a href="https://leetcode.com/problems/number-of-1-bits/">LeetCode</a></p><p>Write a function that takes an unsigned integer and returns the number of <code>&#39;1&#39;</code> bits it has (also known as the <code>Hamming weight</code>).</p><p>Example 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: n &#x3D; 00000000000000000000000000001011Output: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p><code>lowBit</code>函数返回二进制最低位的1和后面的0，比如<code>1100</code>返回<code>100</code><br><code>1100</code>返回<code>100</code>，做差得<code>1000</code>，<code>ans=1</code><br><code>1000</code>返回<code>1000</code>，做差得<code>0</code>，<code>ans=2</code>，结束</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">uint32_t lowBit(uint32_t x) &#123;    return x &amp; (-x);&#125;int hammingWeight(uint32_t n) &#123;    int cnt &#x3D; 0;    while (n) &#123;        n -&#x3D; lowBit(n);        cnt++;    &#125;    return cnt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以用<code>n &amp; (n - 1)</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int hammingWeight(uint32_t n) &#123;    int cnt &#x3D; 0;    while (n) &#123;        n &#x3D; n &amp; (n - 1);        cnt++;    &#125;    return cnt;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27-移除元素</title>
      <link href="2021/05/27/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
      <url>2021/05/27/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-27-Remove-Element"><a href="#LeetCode-27-Remove-Element" class="headerlink" title="LeetCode 27. Remove Element"></a>LeetCode 27. Remove Element</h2><p><a href="https://leetcode.com/problems/remove-element/">LeetCode</a></p><p>Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements <code>may be changed</code>.</p><p>Return k after placing the final result in the first k slots of nums.</p><p>Do not allocate extra space for another array. You must do this by modifying the input array in-place with $O(1)$ extra memory.</p><h2 id="method-1-反向双指针"><a href="#method-1-反向双指针" class="headerlink" title="method 1: 反向双指针"></a>method 1: 反向双指针</h2><center><img src="/2021/05/27/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/1.png#pic_center" width="100%" height="100%"></center><center><img src="/2021/05/27/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/2.png#pic_center" width="100%" height="100%"></center><p>双指针，前指针找等于<code>val</code>的数，后指针找不等于<code>val</code>的数，然后交换。</p><p><strong>注意</strong>：这种方法会改变元素的相对位置</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;    if (nums.empty()) return 0;    int l &#x3D; 0, r &#x3D; nums.size() - 1;    while (l &lt; r) &#123;        while (l &lt; r &amp;&amp; nums[l] !&#x3D; val) l++;        while (l &lt; r &amp;&amp; nums[r] &#x3D;&#x3D; val) r--;        swap(nums, l, r);    &#125;    return (nums[l] &#x3D;&#x3D; val ? l : l + 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-同向双指针"><a href="#method-2-同向双指针" class="headerlink" title="method 2: 同向双指针"></a>method 2: 同向双指针</h2><p>不改变相对位置</p><ul><li>如果右指针不等于<code>val</code>，就把右指针的值赋给左指针，同时移动一格</li><li>如果右指针等于<code>val</code>，右指针移动，左指针不动</li></ul><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;    int l &#x3D; 0, r &#x3D; 0;    while (r &lt; nums.size()) &#123;        if (nums[r] !&#x3D; val) &#123;            nums[l] &#x3D; nums[r];            l++;        &#125;        r++;    &#125;    return l;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-链表中倒数第k个节点</title>
      <link href="2021/05/27/%E5%89%91%E6%8C%87Offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>2021/05/27/%E5%89%91%E6%8C%87Offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-22-链表中倒数第k个节点"><a href="#剑指-Offer-22-链表中倒数第k个节点" class="headerlink" title="剑指 Offer 22. 链表中倒数第k个节点"></a>剑指 Offer 22. 链表中倒数第k个节点</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p><p>示例：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.返回链表 4-&gt;5.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>用两个相隔<code>k-1</code>的指针，从前往后移</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* getKthFromEnd(ListNode* head, int k) &#123;    ListNode *left &#x3D; head;    ListNode *right &#x3D; head;    int i &#x3D; 1;    while (i &lt; k) &#123;        right &#x3D; right-&gt;next;        i++;    &#125;    while (right-&gt;next) &#123;        left &#x3D; left-&gt;next;        right &#x3D; right-&gt;next;    &#125;    return left;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-替换空格</title>
      <link href="2021/05/26/%E5%89%91%E6%8C%87Offer-5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>2021/05/26/%E5%89%91%E6%8C%87Offer-5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成<code>&quot;%20&quot;</code>。</p><h2 id="method-1-直接用string的特性"><a href="#method-1-直接用string的特性" class="headerlink" title="method 1: 直接用string的特性"></a>method 1: 直接用string的特性</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string replaceSpace(string s) &#123;    string t;    for (auto elem : s) &#123;        if (elem &#x3D;&#x3D; &#39; &#39;) t +&#x3D; &quot;%20&quot;;        else t +&#x3D; elem;    &#125;    return t;&#125;执行用时: 4 ms内存消耗: 6.1 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-模拟"><a href="#method-2-模拟" class="headerlink" title="method 2: 模拟"></a>method 2: 模拟</h2><p>两个指针从后往前赋值，<code>p1</code>指向原<code>string</code>的末尾，<code>p2</code>指向新<code>string</code>末尾，如果<code>p1</code>不是空格，给<code>p2</code>赋值<code>p1</code>，否则<code>p2</code>从后往前赋值<code>%20</code><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string replaceSpace(string s) &#123;    int len &#x3D; s.size();    for (int i &#x3D; 0; i &lt; len; ++i) &#123;        if (isspace(s[i])) s +&#x3D; &quot;  &quot;;    &#125;    int p1 &#x3D; len - 1, p2 &#x3D; s.size() - 1;    while (p1) &#123;        if (!isspace(s[p1])) &#123;            s[p2--] &#x3D; s[p1];        &#125;        else &#123;            s[p2--] &#x3D; &#39;0&#39;;            s[p2--] &#x3D; &#39;2&#39;;            s[p2--] &#x3D; &#39;%&#39;;        &#125;        p1--;    &#125;    return s;&#125;执行用时: 0 ms内存消耗: 6.1 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.2-算术运算符</title>
      <link href="2021/05/26/C-Primer-4-2-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2021/05/26/C-Primer-4-2-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="除法与取模的符号"><a href="#除法与取模的符号" class="headerlink" title="除法与取模的符号"></a>除法与取模的符号</h2><p>除法：符号相同商为正，否则为负<br>取模：符号与被取模数相同。<code>m % n</code>的结果符号与<code>m</code>相同</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9-回文数</title>
      <link href="2021/05/25/LeetCode-9-%E5%9B%9E%E6%96%87%E6%95%B0/"/>
      <url>2021/05/25/LeetCode-9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-9-Palindrome-Number"><a href="#LeetCode-9-Palindrome-Number" class="headerlink" title="LeetCode 9. Palindrome Number"></a>LeetCode 9. Palindrome Number</h2><p><a href="https://leetcode.com/problems/palindrome-number/">LeetCode</a></p><p>Given an integer x, return true if x is palindrome integer.</p><p>An integer is a <code>palindrome</code> when it reads the same backward as forward. For example, 121 is palindrome while 123 is not.</p><p>示例 1：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：x &#x3D; 121输出：true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>示例 2：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：x &#x3D; -121输出：false解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">bool isPalindrome(int x) &#123;    if (x &lt; 0) return false;        &#x2F;&#x2F; 负数肯定是false    long num &#x3D; 0, temp &#x3D; x;    &#x2F;&#x2F; 反转可能会超出int    while (x) &#123;        num &#x3D; num * 10 + x % 10;        x &#x2F;&#x3D; 10;    &#125;    return temp &#x3D;&#x3D; num&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53-在排序数组中查找数字/缺失的数字</title>
      <link href="2021/05/25/%E5%89%91%E6%8C%87Offer-53-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>2021/05/25/%E5%89%91%E6%8C%87Offer-53-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-53-I-在排序数组中查找数字"><a href="#剑指-Offer-53-I-在排序数组中查找数字" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字"></a>剑指 Offer 53 - I. 在排序数组中查找数字</h2><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8输出: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>示例 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6输出: 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h3 id="method-二分法"><a href="#method-二分法" class="headerlink" title="method: 二分法"></a>method: 二分法</h3><p>分别找大于等于<code>target</code>的最小数下标<code>low</code>和小于等于<code>target</code>的最大数的下标<code>high</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">low &lt; high  一定满足，返回下标差low &#x3D;&#x3D; high 不一定满足，可能指向同一个不满足的数low &gt; high  肯定不满足<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int search(vector&lt;int&gt;&amp; nums, int target) &#123;    if (!nums.size()) return 0;    int l &#x3D; 0, r &#x3D; nums.size() - 1;    while (l &lt; r) &#123;        int mid &#x3D; l + r &gt;&gt; 1;        if (nums[mid] &gt;&#x3D; target) r &#x3D; mid;        else l &#x3D; mid + 1;    &#125;    int low &#x3D; r;    l &#x3D; 0, r &#x3D; nums.size() - 1;    while (l &lt; r) &#123;        int mid &#x3D; l + r + 1 &gt;&gt; 1;        if (nums[mid] &lt;&#x3D; target) l &#x3D; mid;        else r &#x3D; mid - 1;    &#125;    int high &#x3D; r;    if (low &lt; high) return high - low + 1;    else if (low &#x3D;&#x3D; high) return nums[low] &#x3D;&#x3D; target;    else return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="剑指-Offer-53-II-0～n-1中缺失的数字"><a href="#剑指-Offer-53-II-0～n-1中缺失的数字" class="headerlink" title="剑指 Offer 53 - II. 0～n-1中缺失的数字"></a>剑指 Offer 53 - II. 0～n-1中缺失的数字</h2><p>一个长度为<code>n-1</code>的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围<code>0 ~ n-1</code>之内。在范围<code>0 ~ n-1</code>内的<code>n</code>个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p>示例 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: [0,1,3]输出: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br>示例 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: [0,1,2,3,4,5,6,7,9]输出: 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-二分模板一"><a href="#method-二分模板一" class="headerlink" title="method: 二分模板一"></a>method: 二分模板一</h2><p>如果<code>mid</code>满足<code>index != value</code>，那么解区间应该是<code>[l, mid]</code>，所以是模板一</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int missingNumber(vector&lt;int&gt;&amp; nums) &#123;    int l &#x3D; 0, r &#x3D; nums.size();    while (l &lt; r) &#123;        int mid &#x3D; l + r &gt;&gt; 1;        if (nums[mid] !&#x3D; mid) r &#x3D; mid;        else l &#x3D; mid + 1;    &#125;    return r;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24-反转链表</title>
      <link href="2021/05/25/%E5%89%91%E6%8C%87Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>2021/05/25/%E5%89%91%E6%8C%87Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-24-反转链表"><a href="#剑指-Offer-24-反转链表" class="headerlink" title="剑指 Offer 24. 反转链表"></a>剑指 Offer 24. 反转链表</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>示例:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method-1-迭代"><a href="#method-1-迭代" class="headerlink" title="method 1: 迭代"></a>method 1: 迭代</h2><center><img src="/2021/05/25/%E5%89%91%E6%8C%87Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/cyc-1.png#pic_center" width="100%" height="100%"></center><center><img src="/2021/05/25/%E5%89%91%E6%8C%87Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/cyc-2.png#pic_center" width="100%" height="100%"></center><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* reverseList(ListNode* head) &#123;    ListNode *pre &#x3D; NULL, *cur &#x3D; head;    if (!cur) return head;    while (cur) &#123;        ListNode *tmp &#x3D; cur-&gt;next;  &#x2F;&#x2F; 用temp记录后向节点        cur-&gt;next &#x3D; pre;            &#x2F;&#x2F; 当前节点的指针指向前向节点        pre &#x3D; cur;                  &#x2F;&#x2F; 当前节点成为前向节点        cur &#x3D; tmp;                  &#x2F;&#x2F; cur指向下一个要处理的节点    &#125;    return pre;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-递归"><a href="#method-2-递归" class="headerlink" title="method 2: 递归"></a>method 2: 递归</h2><center><img src="/2021/05/25/%E5%89%91%E6%8C%87Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/33.png#pic_center" width="100%" height="100%"></center><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* reverseList(ListNode* head) &#123;    if (!head || !head-&gt;next) return head;    ListNode *newHead &#x3D; reverseList(head-&gt;next);    head-&gt;next-&gt;next &#x3D; head;    head-&gt;next &#x3D; nullptr;    return newHead;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69-x的平方根</title>
      <link href="2021/05/24/LeetCode-69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
      <url>2021/05/24/LeetCode-69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-69-Sqrt-x"><a href="#LeetCode-69-Sqrt-x" class="headerlink" title="LeetCode 69. Sqrt(x)"></a>LeetCode 69. Sqrt(x)</h2><p><a href="https://leetcode.com/problems/sqrtx/">LeetCode</a></p><p>Given a non-negative integer x, compute and return the <code>square root</code> of x.</p><p>Since the return type is an <code>integer</code>, the decimal digits are <code>truncated</code>, and only the integer part of the result is returned.</p><p>示例 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: 4输出: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>示例 2:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>模板二：满足条件的最大数<br><code>r</code>和<code>l</code>相加可能超过<code>int</code>，所以用<code>long</code><br>两个<code>mid</code>相乘也可能越界，把一个除到另一边去</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int mySqrt(int x) &#123;    long l &#x3D; 0, r &#x3D; x;    while (l &lt; r) &#123;        long mid &#x3D; l + r + 1 &gt;&gt; 1;      &#x2F;&#x2F; 左移一位就相当于除以2        if (mid &lt;&#x3D; x &#x2F; mid) l &#x3D; mid;    &#x2F;&#x2F; 把乘移到另一边        else r &#x3D; mid - 1;    &#125;    return l;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>65-不用加减乘除做加法</title>
      <link href="2021/05/24/%E5%89%91%E6%8C%87Offer-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
      <url>2021/05/24/%E5%89%91%E6%8C%87Offer-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a>剑指 Offer 65. 不用加减乘除做加法</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用四则运算符号。</p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><center><img src="/2021/05/24/%E5%89%91%E6%8C%87Offer-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/1.png#pic_center" width="60%" height="60%"></center><p>通过观察异或运算的真值表，与加法的真值表特别地像。需要注意的是<strong>异或只看本位</strong>，加法可能需要进位。从而用到与运算&amp;。</p><center><img src="/2021/05/24/%E5%89%91%E6%8C%87Offer-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/2.png#pic_center" width="60%" height="60%"></center><p>与运算可以很好地解决加法进位的问题，加法进位和与运算结果对应：<code>1+0、0+1、0+0</code>的进位都是<code>0</code>，<code>1+1</code>的进位为<code>1</code><br>通过异或得到了本位和，通过与运算得到了进位值，最后，只需要将进位值给高一位即可。</p><p><strong>建议</strong><br>对有符号数使用位运算，符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理<strong>无符号类型</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int add(int a, int b) &#123;    while (b) &#123;        int temp &#x3D; a ^ b;        b &#x3D; (unsigned)(a &amp; b) &lt;&lt; 1;        a &#x3D; temp;    &#125;    return a;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>64-求1到n的和</title>
      <link href="2021/05/24/%E5%89%91%E6%8C%87Offer-64-%E6%B1%821%E5%88%B0n%E7%9A%84%E5%92%8C/"/>
      <url>2021/05/24/%E5%89%91%E6%8C%87Offer-64-%E6%B1%821%E5%88%B0n%E7%9A%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a>剑指 Offer 64. 求1+2+…+n</h2><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>用递归</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int sumNums(int n) &#123;    if (n &#x3D;&#x3D; 1) return 1;    else return n + sumNums(n-1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39-数组中出现次数超过一半的数字</title>
      <link href="2021/05/23/%E5%89%91%E6%8C%87Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>2021/05/23/%E5%89%91%E6%8C%87Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a>剑指 Offer 39. 数组中出现次数超过一半的数字</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>利用<code>map</code>保存每个数字出现的次数，超过一半就返回</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int majorityElement(vector&lt;int&gt;&amp; nums) &#123;    int count &#x3D; nums.size() &#x2F; 2 + 1;    map&lt;int, int&gt; m;    for (auto elem : nums) &#123;        m[elem]++;        if (m[elem] &gt;&#x3D; count) return elem;    &#125;    return -1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-数据信息表示方法</title>
      <link href="2021/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/"/>
      <url>2021/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="符号数表示"><a href="#符号数表示" class="headerlink" title="符号数表示"></a>符号数表示</h2><p>原码：最高位为符号，其余二进制真值<br>补码：最高位符号</p><ul><li>正：与原码相同</li><li>负：符号位不变，其余<strong>取反</strong>后再<strong>加1</strong></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">-69原码：1100 0101补码：1011 1011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>8位原码的表示范围：<strong>-127 ~ 127</strong><br>8位补码的表示范围：<strong>-128 ~ 127</strong><br>因为补码利用了<code>-0</code>这个编码，作为最小的负数<br>比如8位有符号数，最小数<code>-128</code>的编码就是<code>1000 0000</code><br>最大数<code>127</code>的编码是<code>0111 1111</code>(正数的补码和原码一样)<br>所以补码可表示范围比原码多1<br>n位数：$-2^{n-1} \sim 2^{n-1}-1$</p><p><strong>tips:</strong><br>因为计算机中以补码形式存储数据，所以<code>32</code>位的有符号数的<code>int</code>的范围是：$-2^{31} \sim 2^{31}-1$，即 <strong>-2147483648 ~ 2147483647</strong></p><p><code>16</code>位的有符号数的<code>short</code>的范围是：$-2^{15} \sim 2^{15}-1$，即 <strong>-32768 ~ 32767</strong></p><ul><li>已知<code>x</code>的补码，求<code>-x</code>的补码：符号位、数值位全部取反，再<code>+1</code></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">-69补码：1011 1011取反+1：0100 0101 即69的补码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main() &#123;    int a &#x3D; 2147483647;    cout &lt;&lt; a+1 &lt;&lt; endl;    return 0;&#125;-2147483648<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反码</p><ul><li>正数：与补码相同</li><li>负数：原码符号不变，其余取反</li></ul><p>移码：补码符号位取反，移码只能用于表示整数</p><center><img src="/2021/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/1.png#pic_center" width="100%" height="100%"></center><p>真值增大时，移码也是增大的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><center><img src="/2021/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/2.png#pic_center" width="100%" height="100%"></center><h2 id="补码的作用"><a href="#补码的作用" class="headerlink" title="补码的作用"></a>补码的作用</h2><p>用加法运算替换减法运算<br>88-66<br>找到-66的补码：<br>模$2^{8}$ - 66的绝对值(补码最原始的计算方式)<br><code>= 1 0000 0000 - 0100 0100 = 1011 1110</code><br>然后用 <code>88 = 0101 1000</code>，所以<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">   0101 1000+  1011 1110&#x3D; 10001 0110转化成十进制就是22<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h2><center><img src="/2021/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/4.png#pic_center" width="100%" height="100%"></center><p><strong>补码</strong><br>以最低位的1为分界<br>右移：前段跟反码一样，所以补1<br>左移：后段跟原码一样，所以补0</p><center><img src="/2021/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/3.png#pic_center" width="100%" height="100%"></center><h2 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h2><p>逻辑移位可以看作是对无符号数的算数移位，<strong>符号位也会移动</strong>，最高位补0</p><h2 id="原码、补码一位乘法"><a href="#原码、补码一位乘法" class="headerlink" title="原码、补码一位乘法"></a>原码、补码一位乘法</h2><p>原码：</p><ul><li>符号位通过异或确定，数值位由被乘数和乘数的绝对值进行n轮加法、移位</li><li>每次加法可能是<code>+0</code>、<code>+x的原码</code>，看<code>MQ</code>的最低位<code>(0 1)</code></li><li>每次移位是逻辑右移</li></ul><p>补码：</p><ul><li>符号位、数值位都是由被乘数和乘数进行n轮加法、移位，最后还有一次加法</li><li>每次加法可能是<code>+0</code>、<code>+x的补码</code>、<code>+(-x)的的补码</code>，看辅助位和<code>MQ&#39;最低位&#39;</code>的差值<code>(0 1 -1)</code></li><li>每次移位是补码的算数右移，整数补0，负数补1</li></ul><h2 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h2><center><img src="/2021/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/5.png#pic_center" width="100%" height="100%"></center><h2 id="边界对齐"><a href="#边界对齐" class="headerlink" title="边界对齐"></a>边界对齐</h2><center><img src="/2021/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/6.png#pic_center" width="100%" height="100%"></center>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim基本操作</title>
      <link href="2021/05/22/Linux-vim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>2021/05/22/Linux-vim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<ul><li><code>vim ~/.vimrc</code>可以编辑配置文件</li><li><code>syntax on</code> 语法高亮</li><li><code>set number</code> 行号</li><li><code>w(word)</code> 移动到下一个单词，b移动到上一个单词</li><li><code>page up/down</code> 上下翻页 也可以用 <code>ctrl+f(forward)/b(back)</code></li><li><code>cc</code> 剪切进入编辑，<code>cnc</code> 剪切第n行</li><li><code>v</code> 进入visual模式，可以选择多行，按<code>c</code>删除</li><li><code>starti</code> 可以从第一条指令开始执行程序</li><li><code>layout asm</code> 可以更方便地查看汇编</li><li><code>info register</code> 可以查看寄存器</li></ul><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><h3 id="命令模式的常用命令"><a href="#命令模式的常用命令" class="headerlink" title="命令模式的常用命令"></a>命令模式的常用命令</h3><table><tbody align="center">    <tr>        <th bgcolor="#A1A3A6">命令</th><th bgcolor="#A1A3A6">作用</th>    </tr>    <tr>        <td>dd</td><td>删除(剪切)光标所在行</td>    </tr>    <tr>        <td>xdd</td><td>删除(剪切)从光标所在行开始的x行</td>    </tr>    <tr>        <td>行号+gg</td><td>快速跳转到该行，gg跳到首行</td>    </tr>    <tr>        <td>G</td><td>调转到末尾</td>    </tr>    <tr>        <td>/+内容+enter</td><td>搜索</td>    </tr>    <tr>        <td>n</td><td>显示搜索命令定位到的下一个字符串</td>    </tr>    <tr>        <td>N</td><td>显示搜索命令定位到的上一个字符串</td>    </tr>    <tr>        <td>p</td><td>将之前剪切(dd)或复制(yy)的数据粘贴到光标后面</td>    </tr>    <tr>        <td>u</td><td>撤销上一步的操作</td>    </tr>    <tr>        <td>yy</td><td>复制光标所在行</td>    </tr>    <tr>        <td>xyy</td><td>复制从光标所在行开始的x行</td>    </tr>    <tr>        <td>^</td><td>跳到行首</td>    </tr>    <tr>        <td>$</td><td>跳到行末</td>    </tr></tbody></table><h3 id="底行命令模式的常用命令"><a href="#底行命令模式的常用命令" class="headerlink" title="底行命令模式的常用命令"></a>底行命令模式的常用命令</h3><table><tbody align="center">    <tr>        <th bgcolor="#A1A3A6">命令</th><th bgcolor="#A1A3A6">作用</th>    </tr>    <tr>        <td>:w</td><td>保存</td>    </tr>    <tr>        <td>:q</td><td>退出</td>    </tr>    <tr>        <td>:q!</td><td>强制退出(放弃对文档的修改内容)</td>    </tr>    <tr>        <td>:wq!</td><td>强制保存退出</td>    </tr>    <tr>        <td>:整数</td><td>跳转到该行</td>    </tr></tbody></table><h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>.c文件 -&gt; 预处理(preprocess) -&gt; .i文件 -&gt; 编译(compile) -&gt; .s文件 -&gt; 汇编(assembly) -&gt; .o文件 -&gt; 链接(link) -&gt; a.out</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>40-最小的k个数</title>
      <link href="2021/05/21/%E5%89%91%E6%8C%87Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
      <url>2021/05/21/%E5%89%91%E6%8C%87Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a>剑指 Offer 40. 最小的k个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p>示例 1：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：arr &#x3D; [3,2,1], k &#x3D; 2输出：[1,2] 或者 [2,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>示例 2：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1输出：[0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>用优先队列维护一个长度为<code>k</code>的大根堆<br>如果后面的数比堆里最大的数小，就要替换掉堆中的数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;    vector&lt;int&gt; res;    if (k &#x3D;&#x3D; 0) return res;         &#x2F;&#x2F; 返回空    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;    for (int i &#x3D; 0; i &lt; arr.size(); i++) &#123;        if (i &lt; k) q.push(arr[i]);  &#x2F;&#x2F; 先放入k个数        else if (arr[i] &lt; q.top()) &#123;                q.pop();                q.push(arr[i]);            &#125;    &#125;        while (!q.empty()) &#123;            &#x2F;&#x2F; 把堆里的数据搬到vector        int x &#x3D; q.top();        q.pop();        res.push_back(x);    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48-最长不含重复字符的子字符串</title>
      <link href="2021/05/20/%E5%89%91%E6%8C%87Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2021/05/20/%E5%89%91%E6%8C%87Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a>剑指 Offer 48. 最长不含重复字符的子字符串</h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p>示例 1:<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method-双指针"><a href="#method-双指针" class="headerlink" title="method: 双指针"></a>method: 双指针</h2><p>用<code>[l, r)</code>维护一个不含重复元素的子串<br>利用<code>set</code>集合不含重复元素的特性<br>如果<code>r</code>所指的元素集合中已经存在，就把<code>l</code>所指的元素删除掉，再看<code>r</code>所指元素是否在集合中</p><center><img src="/2021/05/20/%E5%89%91%E6%8C%87Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/222.png#pic_center" width="100%" height="100%"></center><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int lengthOfLongestSubstring(string s) &#123;    set&lt;char&gt; st;    unsigned l &#x3D; 0, r &#x3D; 0;    unsigned res &#x3D; 0;    while (r &lt; s.size() &amp;&amp; l &lt;&#x3D; r) &#123;        if (st.find(s[r]) &#x3D;&#x3D; st.end()) &#123;    &#x2F;&#x2F; 如果r所指元素不在集合中            st.insert(s[r]);            r++;            res &#x3D; max(res, r - l);      &#x2F;&#x2F; 串长度为(r-1)-l+1&#x3D;r-l        &#125;        else &#123;            st.erase(s[l]);     &#x2F;&#x2F; 删掉l所指的元素            l++;        &#125;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-数组中重复的数字</title>
      <link href="2021/05/19/%E5%89%91%E6%8C%87Offer-3-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>2021/05/19/%E5%89%91%E6%8C%87Offer-3-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a>剑指 Offer 03. 数组中重复的数字</h2><p>在一个长度为 <code>n</code> 的数组 <code>nums</code> 里的所有数字都在 <code>0~n-1</code> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>思路：因为限制时间复杂度为$O(n)$，所以不能用排序<br>对于这种元素是<code>[0, n-1]</code>的数组，可以把元素放回自己的<code>index</code>，如果要放回的位置已经有元素了，并且是没错的，就说明重复了</p><center><img src="/2021/05/19/%E5%89%91%E6%8C%87Offer-3-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/03.png#pic_center" width="60%" height="60%"></center><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;public:    void swap(vector&lt;int&gt; &amp;vi, int i, int j) &#123;        int temp &#x3D; vi[i];        vi[i] &#x3D; vi[j];        vi[j] &#x3D; temp;    &#125;    int findRepeatNumber(vector&lt;int&gt;&amp; num) &#123;        for (int i &#x3D; 0; i &lt; num.size(); i++) &#123;  &#x2F;&#x2F; 遍历数组            while (i !&#x3D; num[i]) &#123;               &#x2F;&#x2F; 发现和index对不上                if (num[i] &#x3D;&#x3D; num[num[i]])      &#x2F;&#x2F; 如果那个位置已经正确                    return num[i];              &#x2F;&#x2F; 就说明重复了                swap(num, i, num[i]);           &#x2F;&#x2F; 否则交换两个数            &#125;        &#125;        return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.2-标准库类型string</title>
      <link href="2021/05/19/C-Primer-3-2-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/"/>
      <url>2021/05/19/C-Primer-3-2-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/</url>
      
        <content type="html"><![CDATA[<h2 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string::size_type类型"></a>string::size_type类型</h2><p><code>str.size()</code>的返回类型是无符号数<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto len &#x3D; str.size();cout &lt;&lt; len &lt;&lt; endl;int x &#x3D; -1;cout &lt;&lt; x * len &lt;&lt; endl;输出：18446744073709551615<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><code>str.size()</code>的返回结果是<code>size_type</code>类型，貌似是<code>unsigned long long</code>，反正就是无符号数，注意不要和有符号数混用</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1-基本内置类型</title>
      <link href="2021/05/19/C-Primer-2-1-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>2021/05/19/C-Primer-2-1-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="切勿混用带符号类型和无符号类型"><a href="#切勿混用带符号类型和无符号类型" class="headerlink" title="切勿混用带符号类型和无符号类型"></a>切勿混用带符号类型和无符号类型</h2><p>因为<strong>带符号类型</strong>会自动转换为<strong>无符号数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unsigned int x &#x3D; -1;cout &lt;&lt; x &lt;&lt; endl;输出：4294967295<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>危</strong><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int x &#x3D; -1;unsigned y &#x3D; 1;cout &lt;&lt; x * y &lt;&lt; endl;输出：4294967295<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>带符号类型的x会被转换为无符号类型的4294967295</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.9-重载、类型转换与运算符</title>
      <link href="2021/05/15/C-Primer-14-9-%E9%87%8D%E8%BD%BD%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2021/05/15/C-Primer-14-9-%E9%87%8D%E8%BD%BD%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="Conversion-Function-转换函数"><a href="#Conversion-Function-转换函数" class="headerlink" title="Conversion Function 转换函数"></a>Conversion Function 转换函数</h2><p>必要时对class类型进行转换</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Fraction &#123;public:    &#x2F;&#x2F; non-explicit-one-argument ctor    Fraction(int num, int den&#x3D;1) : m_num(num), m_den(den) &#123;&#125;    &#x2F;&#x2F; 将Fraction转为double    operator double() const &#123;        return (double)m_num &#x2F; m_den;    &#125;private:    int m_num;    int m_den;&#125;;int main(int argc, char const *argv[])&#123;    Fraction f1(3, 4);    cout &lt;&lt; 1 + f1 &lt;&lt; endl;    return 0;&#125;1.75<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要实现下面的功能<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Fraction f2 &#x3D; f1 + 4;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br>只需要重载<code>+</code>运算符，编译器会调用<code>non-explicit-one-argument</code>构造函数，即隐式的一个参数的构造函数，将<code>4</code>这个<code>int</code>型变量转换为<code>Fraction(4, 1)</code>类型，再进行相加。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Fraction operator + (const Fraction&amp; f) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><strong>但是</strong>，如果有转换函数，又有<code>non-explicit-one-argument ctor</code>，编译器就会陷入矛盾，不知道是该把<code>Fraction</code>转为<code>double</code>，还是把<code>int</code>转为<code>Fraction</code></p><p>解决办法，把构造函数声明为<code>explicit</code>，这样就不能隐式地把<code>int</code>转为<code>Fraction</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="2021/05/15/C-exercise-String/"/>
      <url>2021/05/15/C-exercise-String/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class String &#123;public:    String(const char* cstr &#x3D; 0);    String(const String&amp; str);    String&amp; operator &#x3D; (const String&amp; str);    ~String();    char* get_c_str() const &#123; return m_data; &#125;private:    char* m_data;&#125;;inline String::String(const char* cstr) &#123;    if (cstr) &#123;        m_data &#x3D; new char[strlen(cstr) + 1];        strcpy(m_data, cstr);    &#125;    else &#123;        m_data &#x3D; new char[1];        *m_data &#x3D; &#39;\0&#39;;    &#125;&#125;inline String::~String() &#123;    delete[] m_data;&#125;inline String::String(const String&amp; str) &#123;    m_data &#x3D; new char[strlen(str.m_data) + 1];    strcpy(m_data, str.m_data);&#125;&#x2F;&#x2F; 赋值前必须检查是否是自我赋值inline String&amp; String::operator &#x3D; (const String&amp; str) &#123;    if (this &#x3D;&#x3D; &amp;str)         return *this;    delete[] m_data;    m_data &#x3D; new char[strlen(str.m_data) + 1];    strcpy(m_data, str.m_data);    return *this;&#125;&#x2F;* 重载流输出运算符 * 必须放在类外面，或者声明为友元函数 *&#x2F;inline ostream&amp; operator &lt;&lt; (ostream&amp; os, const String&amp; str) &#123;    return os &lt;&lt; str.get_c_str();&#125;int main(int argc, char const *argv[])&#123;    const char* ptr &#x3D; &quot;hello&quot;;    String s1(ptr);    cout &lt;&lt; s1 &lt;&lt; endl;    String s2(s1);    cout &lt;&lt; s2 &lt;&lt; endl;    String s3;    s3 &#x3D; s1;    cout &lt;&lt; s3 &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>条形图</title>
      <link href="2021/05/12/Python-%E7%94%BB%E5%9B%BE-%E6%9D%A1%E5%BD%A2%E5%9B%BE/"/>
      <url>2021/05/12/Python-%E7%94%BB%E5%9B%BE-%E6%9D%A1%E5%BD%A2%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>不同y轴的图例表示方法</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.pyplot import MultipleLocatorfrom matplotlib import rcnum_list1 &#x3D; [152.8,122.23,101.9,87.31,76.4,68,61.15,55.6,52.41]num_list2 &#x3D; [23393.3,17956.2,14406,11938.7,10180.5,8899.45,7917.17,7178.32,6832.4]for i in range(len(num_list2)):    num_list2[i] &#x2F;&#x3D; 1000fig &#x3D; plt.figure()ax &#x3D; fig.add_subplot(111)x &#x3D; range(4, 13)ax.bar(x&#x3D;x, height&#x3D;num_list1, width&#x3D;0.4, alpha&#x3D;0.8, color&#x3D;&#39;#00a6ac&#39;, label&#x3D;&#39;time(s)&#39;)ax2 &#x3D; ax.twinx()ax2.bar(x&#x3D;[i + 0.4 for i in x], height&#x3D;num_list2, width&#x3D;0.4, color&#x3D;&#39;#d71345&#39;, label&#x3D;&#39;Energy Consumption(kJ)&#39;)fig.legend(loc&#x3D;1, bbox_to_anchor&#x3D;(1,1), bbox_transform&#x3D;ax.transAxes)font &#x3D; &#123;&#39;family&#39;: &#39;Arial&#39;, &#39;weight&#39;: &#39;normal&#39;, &#39;size&#39;: 20&#125;ax.set_xlabel(&quot;Maximal Speed(m&#x2F;s)&quot;, font)ax.set_ylabel(&#39;Time(s)&#39;, font)x_locator &#x3D; MultipleLocator(1)      # 横轴间隔ax.xaxis.set_major_locator(x_locator)ax.spines[&#39;top&#39;].set_linewidth(2)   # 边框加粗ax.spines[&#39;bottom&#39;].set_linewidth(2)ax.spines[&#39;left&#39;].set_linewidth(2)ax.spines[&#39;right&#39;].set_linewidth(2)font2 &#x3D; &#123;&#39;family&#39;: &#39;Arial&#39;, &#39;weight&#39;: &#39;normal&#39;, &#39;size&#39;: 20, &#39;color&#39;:&#39;#d71345&#39;&#125;ax2.set_ylabel(&#39;Energy Consumption(kJ)&#39;, font2)plt.tick_params(axis&#x3D;&#39;y&#39;, colors&#x3D;&#39;#d71345&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/05/12/Python-%E7%94%BB%E5%9B%BE-%E6%9D%A1%E5%BD%A2%E5%9B%BE/1.png#pic_center" width="80%" height="80%" alt="test"></center>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三维图</title>
      <link href="2021/05/12/Python-%E7%94%BB%E5%9B%BE-%E4%B8%89%E7%BB%B4%E5%9B%BE/"/>
      <url>2021/05/12/Python-%E7%94%BB%E5%9B%BE-%E4%B8%89%E7%BB%B4%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="np-arange"><a href="#np-arange" class="headerlink" title="np.arange()"></a>np.arange()</h2><p>函数返回一个有<strong>起点</strong>和<strong>终点</strong>的<strong>固定步长</strong>的排列，如<code>[1,2,3,4,5]</code>，起点是1，终点是6，步长为1</p><ul><li>只有一个参数时表示<code>[0, n)</code>，默认步长为1</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">np.arange(3)[0 1 2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>有两个参数表示起点到终点，默认步长为1</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">np.arange(5, 10)[5 6 7 8 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>三个参数表示起点、终点、步长</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">np.arange(1, 10, 2)[1 3 5 7 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>支持小数步长</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">np.arange(1, 5, 0.5)[1.  1.5 2.  2.5 3.  3.5 4.  4.5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="np-linspace"><a href="#np-linspace" class="headerlink" title="np.linspace()"></a>np.linspace()</h2><p>返回<code>start</code>到<code>stop</code>之间<strong>等间隔</strong>的<code>num</code>个点<br><pre class="line-numbers language-py" data-language="py"><code class="language-py">numpy.linspace(start, stop, num&#x3D;50, endpoint&#x3D;True, retstep&#x3D;False, dtype&#x3D;None, axis&#x3D;0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><pre class="line-numbers language-py" data-language="py"><code class="language-py">np.linspace(2.0, 3.0, num&#x3D;5)[2.   2.25 2.5  2.75 3.  ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">x &#x3D; np.arange(-10, 10, 0.2)y &#x3D; np.arange(-10, 10, 0.2)f_x_y &#x3D; np.power(x, 2) + np.power(y, 2)plt.figure()ax &#x3D; plt.gca(projection&#x3D;&#39;3d&#39;)ax.plot(x, y, f_x_y)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/05/12/Python-%E7%94%BB%E5%9B%BE-%E4%B8%89%E7%BB%B4%E5%9B%BE/1.png#pic_center" width="80%" height="80%" alt="test"></center>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04_初始化</title>
      <link href="2021/05/01/C-Effective-04-%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>2021/05/01/C-Effective-04-%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="确定对象被使用前已经初始化"><a href="#确定对象被使用前已经初始化" class="headerlink" title="确定对象被使用前已经初始化"></a>确定对象被使用前已经初始化</h2><p>不同编译单元内定之<code>non-local static</code>对象的初始化次序是不确定的</p><p>广义的<code>static</code>对象包括：</p><ul><li><code>global</code>对象</li><li>定义于<code>namespace</code>作用域内的对象</li><li>在<code>class</code>内、函数内、<code>file</code>作用域内声明为<code>static</code>的对象</li></ul><p><code>local static</code>：定义在函数内的<code>static</code>对象</p><p>比如我有两个类<code>FileSystem</code>和<code>Directory</code></p><ol><li><code>FileSystem</code>的声明和定义</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;class FileSystem&#123;public:    FileSystem(int a) : num(a) &#123;&#125;    std::size_t getNum() const;private:    int num;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;FileSystem.h&quot;std::size_t FileSystem::getNum() const &#123;    return num;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><code>Directory</code>的声明和定义</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;FileSystem.h&quot;class Directory &#123;public:    Directory();    int display();private:    int val;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;Directory.h&quot;extern FileSystem tfs;  &#x2F;&#x2F; 这里声明了一个FileSystem对象，因为Directory的初始化要用到Directory::Directory() &#123;    std::size_t disks &#x3D; tfs.getNum();    val &#x3D; disks;&#125;int Directory::display() &#123;    return val;&#125;Directory tempDir;  &#x2F;&#x2F; 定义一个Directory对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><code>tfs</code>的定义</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;FileSystem.h&quot;FileSystem tfs(10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li><code>main</code>函数</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;Directory.h&quot;#include &lt;iostream&gt;using namespace std;extern Directory tempDir;int main(int argc, char const *argv[])&#123;    cout &lt;&lt; tempDir.display() &lt;&lt; endl;    return 0;&#125;0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现输出不是我们预期的<code>10</code>，原因在于定义<code>dir</code>时调用了<code>Directory</code>的构造函数，用到了<code>FileSystem</code>的对象<code>tfs</code>，但这个<code>tfs</code>此时未必已经初始化了，因为编译器对文件的编译顺序没有严格的要求，所以会出现问题</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>不要把<code>tfs</code>声明为全局变量，即<code>non-local static</code>变量，而要声明为<code>local static</code>，就是函数里面的<code>static</code>变量<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;Directory.h&quot;extern FileSystem&amp; tfs();Directory::Directory() &#123;    std::size_t disks &#x3D; tfs().getNum();    val &#x3D; disks;&#125;int Directory::display() &#123;    return val;&#125;&#x2F;&#x2F; Directory dir;   &#x2F;&#x2F; dir也声明为non-local staticDirectory&amp; dir() &#123;    static Directory tempDir;    return tempDir;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;FileSystem.h&quot;&#x2F;&#x2F; FileSystem tfs(10);FileSystem&amp; tfs() &#123;    static FileSystem fs(10);   &#x2F;&#x2F; 在函数里面定义，就是local static    return fs;                  &#x2F;&#x2F; 返回引用&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;Directory.h&quot;#include &lt;iostream&gt;using namespace std;extern Directory&amp; dir();int main(int argc, char const *argv[])&#123;    cout &lt;&lt; dir().display() &lt;&lt; endl;    return 0;&#125;10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就符合我们的预期了<br><code>tfs()</code>函数内部实现了<code>FileSystem</code>对象的初始化，调用该函数之后，就可以确保对象一定会被初始化了<br>所以用调用函数替换直接使用<code>non-local static</code>对象，就可以得到对象初始化保证</p>]]></content>
      
      
      
        <tags>
            
            <tag> Effective_C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inline关键字</title>
      <link href="2021/04/30/C-inline%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2021/04/30/C-inline%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-类中内联"><a href="#1-类中内联" class="headerlink" title="1.类中内联"></a>1.类中内联</h2><p>头文件中声明方法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;public:    void f1(int x);    &#x2F;**     * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。     * @param x     * @param y     *&#x2F;    void Foo(int x,int y) &#123;&#125;; &#x2F;&#x2F; 定义即隐式内联函数！    void f1(int x); &#x2F;&#x2F; 声明后，要想成为内联函数，必须在定义处加inline&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现文件中定义内联函数：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &quot;inline.h&quot;using namespace std; &#x2F;** * @brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字” * * @param x * @param y * * @return  *&#x2F;int Foo(int x,int y);  &#x2F;&#x2F; 函数声明inline int Foo(int x,int y) &#x2F;&#x2F; 函数定义&#123;    return x + y;&#125;&#x2F;&#x2F; 定义处加inline关键字，推荐这种写法！inline void A::f1(int x) &#123;&#125;int main() &#123;    cout&lt;&lt;Foo(1,2)&lt;&lt;endl;&#125;&#x2F;** * 编译器对 inline 函数的处理步骤 * 将 inline 函数体复制到 inline 函数调用点处； * 为所用 inline 函数中的局部变量分配内存空间； * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内联能提高函数效率，但并不是所有的函数都定义成内联函数！内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。</p><ul><li><p>如果执行函数体内代码的时间相比于函数调用的开销较大，那么效率的收获会更少！</p></li><li><p>另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p></li></ul><p>以下情况不宜用内联：</p><p>（1）如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高。</p><p>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</p><h2 id="2-虚函数（virtual）可以是内联函数（inline）吗？"><a href="#2-虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="2.虚函数（virtual）可以是内联函数（inline）吗？"></a>2.虚函数（virtual）可以是内联函数（inline）吗？</h2><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;  using namespace std;class Base &#123;public:    inline virtual void info() &#123;        cout &lt;&lt; &quot;I am Base&quot; &lt;&lt; endl;    &#125;    virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;public:    inline void info()  &#x2F;&#x2F; 不写inline时隐式内联    &#123;        cout &lt;&lt; &quot;I am Derived&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    &#x2F;&#x2F; 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。     Base b;    b.info();    &#x2F;&#x2F; 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。      Base *ptr &#x3D; new Derived();    ptr-&gt;info();    &#x2F;&#x2F; 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。    delete ptr;    ptr &#x3D; nullptr;    return 0;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03_const代替#defind</title>
      <link href="2021/04/29/C-Effective-03-const/"/>
      <url>2021/04/29/C-Effective-03-const/</url>
      
        <content type="html"><![CDATA[<h2 id="尽可能使用const代替-define"><a href="#尽可能使用const代替-define" class="headerlink" title="尽可能使用const代替#define"></a>尽可能使用const代替#define</h2><p>有时候需要重载<code>const</code>版本与非<code>const</code>版本的成员函数，但他们的代码又很多重复<br>所以可以直接用非<code>const</code>函数调用<code>const</code>函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Text &#123;private:    string text;public:    Text(string input): text(input) &#123;&#125;    const char&amp; operator [] (size_t pos) const &#123;        cout &lt;&lt; &quot;const operator: &quot;;        return text[pos];    &#125;    char&amp; operator [] (size_t pos) &#123;        cout &lt;&lt; &quot;non-const operator: &quot;;        &#x2F;&#x2F; return text[pos];        return const_cast&lt;char&amp;&gt;(static_cast&lt;const Text&amp;&gt;(*this)[pos]);    &#125;&#125;;int main(int argc, char const *argv[])&#123;    Text t(&quot;hello&quot;);    cout &lt;&lt; t[0] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>static_cast</code>将<code>this</code>指针转换为<code>const</code>指针，这样就可以调用<code>const operator[]</code><br><code>const_cast</code>将返回值解除<code>const</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Effective_C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mutable</title>
      <link href="2021/04/29/C-mutable%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2021/04/29/C-mutable%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p><code>const</code>成员函数不能修改成员变量，如果一定要修改，可以将变量声明为<code>mutable</code>类型<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;private:    mutable int x;public:    A(int _x): x(_x) &#123;&#125;    void func() const &#123;x &#x3D; 10;&#125; &#x2F;&#x2F; 在const成员函数里面修改成员变量&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错题1</title>
      <link href="2021/04/29/NowCoder-%E9%94%99%E9%A2%981/"/>
      <url>2021/04/29/NowCoder-%E9%94%99%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<ol><li><p>运算符优先级<br>算术运算符&gt;关系运算符&gt;逻辑运算符&gt;赋值运算符</p></li><li><p>(p++)-&gt;num<br>会先执行<code>p-&gt;num</code>，然后再<code>p++</code></p></li><li><p><code>getline()</code>读取一行字符</p></li><li><p>派生类的成员函数是虚函数，基类不是，就会执行基类的成员函数</p></li><li><p>除了类属关系运算符<code>&quot;.&quot;</code>、成员指针运算符<code>&quot;.*&quot;</code>、作用域运算符<code>&quot;::&quot;</code>、<code>sizeof</code>运算符和三目运算符<code>&quot;?:&quot;</code>以外，C++中的所有运算符都可以重载</p></li><li><p>重载</p></li></ol><ul><li>函数名相同</li><li>参数必须不同（个数或类型或顺序）</li><li>返回值类型可以相同也可以不同</li></ul><ol><li><code>malloc</code>对应<code>free</code><br><code>new</code>对应<code>delete</code></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>构造函数</title>
      <link href="2021/04/29/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>2021/04/29/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="一、类对象成员的构造"><a href="#一、类对象成员的构造" class="headerlink" title="一、类对象成员的构造"></a>一、类对象成员的构造</h2><p>先构造成员<br>再构造自身（调用构造函数）</p><h2 id="二、派生类构造函数"><a href="#二、派生类构造函数" class="headerlink" title="二、派生类构造函数"></a>二、派生类构造函数</h2><p>派生类可能有多个基类，也可能包括多个成员对象，在创建派生类对象时，派生类的构造函数除了要负责本类成员的初始化外，还要调用基类和成员对象的构造函数，并向它们传递参数，以完成基类子对象和成员对象的建立和初始化。</p><p><strong>派生类只能采用构造函数初始化列表的方式向基类或成员对象的构造函数传递参数</strong>，形式如下：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">派生类构造函数名(参数表): 基类构造函数名(参数表), 成员对象名1(参数表) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></p><h2 id="三、构造函数和析构函数调用次序"><a href="#三、构造函数和析构函数调用次序" class="headerlink" title="三、构造函数和析构函数调用次序"></a>三、构造函数和析构函数调用次序</h2><p><strong>派生类对象的构造</strong></p><ul><li>先构造基类</li><li>再构造成员</li><li>最后构造自身（调用构造函数）</li></ul><p>基类构造顺序由派生层次决定：<strong>最远的基类最先构造</strong><br>成员构造顺序和定义顺序相同<br>析构函数的析构顺序与构造相反</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class A&#123;    int x;public:    A(int i &#x3D; 0) &#123;        x &#x3D; i;        cout &lt;&lt; &quot;A constructor: &quot; &lt;&lt; x &lt;&lt; endl;     &#125;&#125;;class B&#123;    int y;public:    B(int i) &#123;        y &#x3D; i;        cout &lt;&lt; &quot;B constructor: &quot; &lt;&lt; y &lt;&lt; endl;     &#125;&#125;;class C&#123;    int z;public:    C(int i) &#123;        z &#x3D; i;        cout &lt;&lt; &quot;C constructor: &quot; &lt;&lt; z &lt;&lt; endl;     &#125;&#125;;class D: public B&#123;public:    C c1;    A* a1 &#x3D; new A(10);    A a0, a4;    D(): a4(4), c1(1), B(1) &#123;        cout &lt;&lt; &quot;D constructor&quot; &lt;&lt; endl;    &#125;    &#125;;int main(int argc, char const *argv[])&#123;    D d;    return 0;&#125;B constructor: 1    &#x2F;&#x2F; 先调用基类构造函数C constructor: 1    &#x2F;&#x2F; 按照声明的顺序调用成员对象的构造函数，c1A constructor: 10   &#x2F;&#x2F; a1A constructor: 0    &#x2F;&#x2F; a0A constructor: 4    &#x2F;&#x2F; a4D constructor       &#x2F;&#x2F; 最后才是自身<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    int x;    A(int x) &#123;this-&gt;x &#x3D; x;&#125;    A(const A &amp;a) &#123;this-&gt;x &#x3D; a.x;&#125;&#125;;int main() &#123;    A a1(5);        &#x2F;&#x2F; 显示调用初始化函数    A a2 &#x3D; 9;       &#x2F;&#x2F; 隐式调用初始化函数    A a3(a1);       &#x2F;&#x2F; 显示调用拷贝构造函数    A a4 &#x3D; a1       &#x2F;&#x2F; 隐式调用拷贝构造函数    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没加<code>explicit</code>时显示调用和隐式调用都可以<br>加了<code>explicit</code>就相当于禁用隐式调用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    int x;    explicit A(int x) &#123;this-&gt;x &#x3D; x;&#125;    explicit A(const A &amp;a) &#123;this-&gt;x &#x3D; a.x;&#125;&#125;;int main() &#123;    A a1(5);        &#x2F;&#x2F; 显示调用初始化函数    &#x2F;&#x2F; A a2 &#x3D; 9;       &#x2F;&#x2F; error    A a3(a1);       &#x2F;&#x2F; 显示调用拷贝构造函数    &#x2F;&#x2F; A a4 &#x3D; a1       &#x2F;&#x2F; error    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C基础</title>
      <link href="2021/04/29/C-C-%E5%9F%BA%E7%A1%80/"/>
      <url>2021/04/29/C-C-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><ul><li>作用域解析运算符<code>(::)</code></li><li>成员访问运算符<code>(. -&gt;)</code></li><li>下标运算符<code>[]</code></li><li>函数调用运算符<code>()</code></li><li>后置递增递减运算符<code>(++ --)</code></li><li><code>typeid</code></li><li>前置递增递减运算符<code>(++ --)</code></li><li>位求反<code>(~)</code></li><li>逻辑非<code>(!)</code></li><li>一元正负<code>+(正) -(负)</code></li><li>解引用，取地址<code>(* &amp;)</code></li><li><code>sizeof</code></li><li><code>new delete</code></li><li>乘、除、取模<code>* / %</code></li><li>加减<code>+ -</code></li><li>左移右移<code>&lt;&lt; &gt;&gt;</code></li><li>关系运算符<code>== != &lt; &lt;= &gt; &gt;=</code></li><li>位与、位异或、位或<code>&amp; ^ |</code></li><li>逻辑与、逻辑或<code>&amp;&amp; ||</code></li><li>条件运算符<code>(? :)</code></li><li>赋值运算符<code>(=)</code></li><li>复合赋值运算符<code>*= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= |= ^=</code></li><li>抛出异常<code>throw</code></li><li>逗号运算符<code>,</code></li></ul><p><strong><code>WARNING</code></strong><br>对有符号数使用位运算，符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理<strong>无符号类型</strong></p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p><code>new</code>出来的对象存储在<strong>堆</strong>里面</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>可以用函数指针指向一个函数<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int Add(int x, int y) &#123;    return x + y;&#125;int main(int argc, char const *argv[])&#123;    int (*func)(int x, int y);    func &#x3D; &amp;Add;    cout &lt;&lt; (*func)(1, 2) &lt;&lt; endl;  &#x2F;&#x2F; 可以对函数指针取值再调用    cout &lt;&lt; func(1, 2) &lt;&lt; endl;     &#x2F;&#x2F; 也可以直接调用    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作</title>
      <link href="2021/04/29/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>2021/04/29/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="创建文本文件并写入"><a href="#创建文本文件并写入" class="headerlink" title="创建文本文件并写入"></a>创建文本文件并写入</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(int argc, char const *argv[])&#123;    myFile.open(&quot;test.txt&quot;, ios_base::out);    if (myFile.is_open()) &#123;        cout &lt;&lt; &quot;open file&quot; &lt;&lt; endl;        myFile &lt;&lt; &quot;hello world&quot;;        myFile.close();    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ios_base::out</code>表示以只写模式打开文件，用<code>is_open</code>检查是否成功打开文件</p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    ifstream myFile;    myFile.open(&quot;test.txt&quot;, ios_base::in);    if (myFile.is_open()) &#123;        cout &lt;&lt; &quot;Open File&quot; &lt;&lt; endl;        string fileContent;        while (myFile.good()) &#123;            getline(myFile, fileContent);            cout &lt;&lt; fileContent &lt;&lt; endl;        &#125;        myFile.close();    &#125;    return 0;&#125;Open Filehello world &#x2F;&#x2F; 输出文件内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ios_base::in</code>以只读方式打开文件，循环读取文件里的所有字符，保存在<code>string</code>类型的<code>fileContent</code>里面</p><h2 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h2><p>可以用<code>stringstream</code>把其他类型的数据转换为<code>string</code>类型<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main() &#123;    int input &#x3D; 34;    stringstream str;    str &lt;&lt; input;        string strInput;    str &gt;&gt; strInput;    cout &lt;&lt; strInput &lt;&lt; endl;&#125;34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试_1</title>
      <link href="2021/04/28/%E9%9D%A2%E8%AF%95-1/"/>
      <url>2021/04/28/%E9%9D%A2%E8%AF%95-1/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="变量的声明和定义有声明区别"><a href="#变量的声明和定义有声明区别" class="headerlink" title="变量的声明和定义有声明区别"></a>变量的声明和定义有声明区别</h2><p>变量的定义是为变量分配地址和存储空间，变量的声明不分配地址。<br>一个变量可以在多个地方声明，但是只在一个地方定义。<br>加入<code>extern</code>修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。<br><strong>说明</strong>：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main() &#123;    extern int A;    &#x2F;&#x2F; 这是声明不是定义，声明A是一个外部变量    &#x2F;&#x2F; 注意：声明外部变量时可以把变量类型去掉，如：extern A;&#125;int A;  &#x2F;&#x2F; 定义，定义了A为整形的外部变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="简述-ifdef、-else、-endif和-ifndef的作用"><a href="#简述-ifdef、-else、-endif和-ifndef的作用" class="headerlink" title="简述#ifdef、#else、#endif和#ifndef的作用"></a>简述#ifdef、#else、#endif和#ifndef的作用</h2><p>利用<code>#ifdef</code>、<code>#endif</code>将某程序功能模块包括进去，以向特定用户提供该功能<br>在不需要时用户可轻易将其屏蔽。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#ifdef __MATH__ #include &quot;math.c&quot; #endif <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>在子程序前加上标记，以便于追踪和调试。<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#ifdef DEBUGprintf (&quot;In debugging......!&quot;);#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>应对硬件的限制。由于一些具体应用环境的硬件不一样，限于条件，本地缺乏这种设备，只能绕过硬件，直接写出预期结果。<br><strong>注意</strong>：虽然不用条件编译命令而直接用<code>if</code>语句也能达到要求，但那样做目标程序长（因为所有语句都编译），运行时间长因为在程序运行时间对<code>if</code>语句进行测试）。<br>而采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间</p><h2 id="写出int-bool-float-指针变量与“零值”比较的if语句"><a href="#写出int-bool-float-指针变量与“零值”比较的if语句" class="headerlink" title="写出int/bool/float/指针变量与“零值”比较的if语句"></a>写出int/bool/float/指针变量与“零值”比较的if语句</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; int与零值比较if (n &#x3D;&#x3D; 0)if (n !&#x3D; 0)&#x2F;&#x2F; bool与零值比较 if (flag)     &#x2F;&#x2F; 表示flag为真 if (!flag)    &#x2F;&#x2F; 表示flag为假 &#x2F;&#x2F; float与零值比较 const float EPSINON &#x3D; 0.00001;if ((x &gt;&#x3D; -EPSINON) &amp;&amp; (x &lt;&#x3D; EPSINON)) &#x2F;&#x2F;其中EPSINON是允许的误差（即精度） &#x2F;&#x2F; 指针变量与零值比较 if (p &#x3D;&#x3D; NULL)if (p !&#x3D; NULL)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构体可以直接赋值吗"><a href="#结构体可以直接赋值吗" class="headerlink" title="结构体可以直接赋值吗"></a>结构体可以直接赋值吗</h2><p>声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针成员时一定要小心。<br><strong>注意</strong>：当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作，因此在释放前一定要确保其他指针不再使用这段内存空间</p><h2 id="sizeof-和strlen-的区别"><a href="#sizeof-和strlen-的区别" class="headerlink" title="sizeof 和strlen 的区别"></a>sizeof 和strlen 的区别</h2><ul><li><code>sizeof</code>是一个操作符，<code>strlen</code>是库函数。</li><li><code>sizeof</code>的参数可以是数据的类型，也可以是变量，而<code>strlen</code>只能以结尾为<code>&#39;\0&#39;</code>的字符串作参数。</li><li>编译器在编译时就计算出了sizeof的结果，而<code>strlen</code>函数必须在运行时才能计算出来。并且<code>sizeof</code>计算的是数据类型占内存的大小，而<code>strlen</code>计算的是字符串实际的长度。</li><li>数组做<code>sizeof</code>的参数不退化，传递给<code>strlen</code>就退化为指针了</li></ul><h2 id="C-语言的关键字-static-和-C-的关键字-static-有什么区别"><a href="#C-语言的关键字-static-和-C-的关键字-static-有什么区别" class="headerlink" title="C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"></a>C 语言的关键字 static 和 C++ 的关键字 static 有什么区别</h2><p>在<code>C</code>中<code>static</code>用来修饰局部静态变量和外部静态变量、函数。而<code>C++</code>中除了上述功能外，还用来定义类的成员变量和函数，即静态成员和静态成员函数<br><strong>注意</strong>：编程时，<code>static</code>的记忆性和全局性的特点可以让在不同时期调用的函数进行通信，而<code>C++</code>的静态成员则可以在多个对象实例间进行通信</p><h2 id="C-语言的-malloc-和-C-中的-new-有什么区别"><a href="#C-语言的-malloc-和-C-中的-new-有什么区别" class="headerlink" title="C 语言的 malloc 和 C++ 中的 new 有什么区别"></a>C 语言的 malloc 和 C++ 中的 new 有什么区别</h2><ul><li><code>new</code>和<code>delete</code>是操作符，可以重载，只能在<code>C++</code>中使用。</li><li><code>malloc</code>和<code>free</code>是函数，可以覆盖，<code>C/C++</code>中都可以使用。</li><li><code>new</code>可以调用对象的构造函数，对应的<code>delete</code>调用相应的析构函数。</li><li><code>malloc</code>仅仅分配内存，<code>free</code>仅仅回收内存，并不执行构造和析构函数</li><li><code>new</code>和<code>delete</code>返回的是某种数据类型指针，<code>malloc</code>和<code>free</code>返回的是<code>void</code>指针。<br>注意：<code>malloc</code>申请的内存空间要用<code>free</code>释放，而<code>new</code>申请的内存空间要用<code>delete</code>释放，不要混用</li></ul><h2 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h2><p><code>size_t</code> 是<code>cstddef</code>头文件定义的一种与机器实现有关的无符号整数类型，他的空间足够大，能够表示任意数的大小</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26/80-删除有序数组中的重复项</title>
      <link href="2021/04/27/LeetCode-26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
      <url>2021/04/27/LeetCode-26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-26-Remove-Duplicates-from-Sorted-Array"><a href="#LeetCode-26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="LeetCode 26. Remove Duplicates from Sorted Array"></a>LeetCode 26. Remove Duplicates from Sorted Array</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">LeetCode</a></p><p>Given an integer array nums <code>sorted in non-decreasing order</code>, <code>remove the duplicates</code> in-place such that each unique element appears only <code>once</code>. The <code>relative order</code> of the elements should be kept the <code>same</code>.</p><p>Return k after placing the final result in the first k slots of nums.</p><p>Do not allocate extra space for another array. You must do this by modifying the input array in-place with $O(1)$ extra memory.</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：nums &#x3D; [1,1,2]输出：2, nums &#x3D; [1,2]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="method-1-用STL提供的算法unique和erase"><a href="#method-1-用STL提供的算法unique和erase" class="headerlink" title="method 1: 用STL提供的算法unique和erase"></a>method 1: 用STL提供的算法unique和erase</h2><p><code>unique</code>可以把重复的那些元素移动到后面去，<code>it</code>指向重复的第一个元素<br>因为他要的是<code>vector</code>的长度，所以直接返回有用部分的长度就可以了，不用删除</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;    auto it &#x3D; unique(nums.begin(), nums.end());    return distance(nums.begin(), it);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="method-2-快慢指针"><a href="#method-2-快慢指针" class="headerlink" title="method 2: 快慢指针"></a>method 2: 快慢指针</h2><p>快指针指向的元素与慢指针<code>-1</code>的元素相比较</p><ul><li>相同，快指针<code>+1</code>，慢指针不动</li><li>不同，快指针赋值给慢指针，都<code>+1</code></li></ul><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;    if (nums.size() &#x3D;&#x3D; 0) return 0;    int fast &#x3D; 1, slow &#x3D; 1;    while (fast &lt; nums.size()) &#123;        if (nums[fast] !&#x3D; nums[slow - 1]) &#123;            nums[slow] &#x3D; nums[fast];            slow++;            fast++;        &#125;        else fast++;    &#125;    return slow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="LeetCode-80-Remove-Duplicates-from-Sorted-Array-II"><a href="#LeetCode-80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="LeetCode 80. Remove Duplicates from Sorted Array II"></a>LeetCode 80. Remove Duplicates from Sorted Array II</h2><p><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/">LeetCode</a></p><p>Given an integer array nums <code>sorted in non-decreasing order</code>, remove some duplicates in-place such that each unique element appears <code>at most twice</code>. The <code>relative order</code> of the elements should be kept the <code>same</code>.</p><h2 id="method-快慢指针"><a href="#method-快慢指针" class="headerlink" title="method: 快慢指针"></a>method: 快慢指针</h2><p>原理一样，只是快指针与慢指针<code>-2</code>的元素相比较</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;    if (nums.size() &lt; 2) return nums.size();    int fast &#x3D; 2, slow &#x3D; 2;    while (fast &lt; nums.size()) &#123;        if (nums[fast] !&#x3D; nums[slow - 2]) &#123;            nums[slow] &#x3D; nums[fast];            slow++;            fast++;        &#125;        else fast++;    &#125;    return slow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果是允许<code>N</code>个元素重复，快指针与慢指针<code>-N</code>的元素相比较</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;    if (nums.size() &lt; N) return nums.size();    int fast &#x3D; N, slow &#x3D; N;    while (fast &lt; nums.size()) &#123;        if (nums[fast] !&#x3D; nums[slow - N]) &#123;            nums[slow] &#x3D; nums[fast];            slow++;            fast++;        &#125;        else fast++;    &#125;    return slow;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-bitset</title>
      <link href="2021/04/27/C-STL-STL-bitset/"/>
      <url>2021/04/27/C-STL-STL-bitset/</url>
      
        <content type="html"><![CDATA[<p>位标志只能在初始化时指定大小，后面不能再改<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main(int argc, char const *argv[]) &#123;    bitset&lt;4&gt; fourbit(&quot;1011&quot;);    cout &lt;&lt; fourbit &lt;&lt; endl;    cout &lt;&lt; &quot;Num of 1: &quot; &lt;&lt; fourbit.count() &lt;&lt; endl;    bitset&lt;4&gt; fourbit2(~fourbit);    cout &lt;&lt; fourbit2 &lt;&lt; endl;    bitset&lt;4&gt; fourbit3 &#x3D; fourbit.flip();    cout &lt;&lt; fourbit3 &lt;&lt; endl;    bitset&lt;8&gt; eightbit(255);    cout &lt;&lt; eightbit &lt;&lt; endl;    return 0;&#125;1011Num of 1: 30100010011111111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="2021/04/27/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>2021/04/27/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p><code>unique_ptr</code>禁止对指针进行复制和赋值<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Fish &#123;  public:    Fish() &#123;cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl;&#125;    ~Fish() &#123;cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;&#125;    void Swim() &#123;        cout &lt;&lt; &quot;Fish swim in water&quot; &lt;&lt; endl;    &#125;&#125;;void MakeFishSwim(const unique_ptr&lt;Fish&gt;&amp; ptr) &#123;    ptr-&gt;Swim();&#125;int main(int argc, char const *argv[]) &#123;    unique_ptr&lt;Fish&gt; pFish(new Fish);    pFish-&gt;Swim();    MakeFishSwim(pFish);    return 0;&#125;constructorFish swim in waterFish swim in waterdestructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><ul><li>只能有一个<code>Ownership</code>，离开作用域就自动销毁</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Entity&#123;public:    Entity() &#123; cout &lt;&lt; &quot;Entity created!&quot; &lt;&lt; endl; &#125;    ~Entity() &#123;cout &lt;&lt; &quot;Entity destroyed!&quot; &lt;&lt; endl; &#125;&#125;;void ex1() &#123;    puts(&quot;&gt;&gt;&gt;&gt;&gt;Entering ex1&lt;&lt;&lt;&lt;&lt;&quot;);    &#123;        puts(&quot;-----Entering scope-----&quot;);        auto e1 &#x3D; std::make_unique&lt;Entity&gt;();        puts(&quot;-----Leaving scope-----&quot;);    &#125;    puts(&quot;&gt;&gt;&gt;&gt;&gt;Leaving ex1&lt;&lt;&lt;&lt;&lt;&quot;);&#125;int main(int argc, char const *argv[])&#123;    ex1();    return 0;&#125;&gt;&gt;&gt;&gt;&gt;Entering ex1&lt;&lt;&lt;&lt;&lt;-----Entering scope-----Entity created!-----Leaving scope-----Entity destroyed!&gt;&gt;&gt;&gt;&gt;Leaving ex1&lt;&lt;&lt;&lt;&lt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>Ownership</code>转移到<code>foo</code>里面，所以离开<code>foo</code>之后就销毁了<br><code>move</code>是<code>ownership</code>的直接转移，调用者不再拥有对象</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void foo(std::unique_ptr&lt;Entity&gt;) &#123;    puts(&quot;-----Entering foo-----&quot;);    puts(&quot;-----Leaving foo-----&quot;);&#125;void ex2() &#123;    puts(&quot;&gt;&gt;&gt;&gt;&gt;Entering ex2&lt;&lt;&lt;&lt;&lt;&quot;);    auto e1 &#x3D; std::make_unique&lt;Entity&gt;();    foo(std::move(e1));    puts(&quot;&gt;&gt;&gt;&gt;&gt;Leaving ex2&lt;&lt;&lt;&lt;&lt;&quot;);&#125;int main(int argc, char const *argv[])&#123;    ex2();    return 0;&#125;&gt;&gt;&gt;&gt;&gt;Entering ex2&lt;&lt;&lt;&lt;&lt;Entity created!-----Entering foo----------Leaving foo-----Entity destroyed!&gt;&gt;&gt;&gt;&gt;Leaving ex2&lt;&lt;&lt;&lt;&lt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p><code>shared_ptr</code>会进行引用计数，引用计数为0时自动销毁</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void ex3() &#123;    puts(&quot;&gt;&gt;&gt;&gt;&gt;Entering ex3&lt;&lt;&lt;&lt;&lt;&quot;);    auto e1 &#x3D; std::make_shared&lt;Entity&gt;();    std::cout &lt;&lt; e1.use_count() &lt;&lt; std::endl;    &#123;        puts(&quot;-----Entering scope-----&quot;);        auto e2 &#x3D; e1;        std::cout &lt;&lt; e1.use_count() &lt;&lt; std::endl;        auto e3 &#x3D; std::move(e2);    &#x2F;&#x2F; move是ownership转移        std::cout &lt;&lt; e1.use_count() &lt;&lt; std::endl;        puts(&quot;-----Leaving scope-----&quot;);    &#125;    std::cout &lt;&lt; e1.use_count() &lt;&lt; std::endl;    puts(&quot;&gt;&gt;&gt;&gt;&gt;Leaving ex3&lt;&lt;&lt;&lt;&lt;&quot;);&#125;int main(int argc, char const *argv[])&#123;    ex3();    return 0;&#125;&gt;&gt;&gt;&gt;&gt;Entering ex3&lt;&lt;&lt;&lt;&lt;Entity created!1-----Entering scope-----22-----Leaving scope-----1&gt;&gt;&gt;&gt;&gt;Leaving ex3&lt;&lt;&lt;&lt;&lt;Entity destroyed!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><code>weak_ptr</code>使用前检查对象是否还存在，确认存在才能使用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void observe(std::weak_ptr&lt;Entity&gt; ew) &#123;    puts(&quot;*****Entering observe*****&quot;);    if (std::shared_ptr&lt;Entity&gt; spt &#x3D; ew.lock()) &#123;        std::cout &lt;&lt; spt.use_count() &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;entity still alive&quot; &lt;&lt; std::endl;    &#125; else &#123;        std::cout &lt;&lt; &quot;entity was expired&quot; &lt;&lt; std::endl;    &#125;    puts(&quot;*****Leaving observe*****&quot;);&#125;void ex4() &#123;    puts(&quot;&gt;&gt;&gt;&gt;&gt;Entering ex4&lt;&lt;&lt;&lt;&lt;&quot;);    std::weak_ptr&lt;Entity&gt; ew;    &#123;        puts(&quot;-----Entering scope-----&quot;);        auto e1 &#x3D; std::make_shared&lt;Entity&gt;();        std::cout &lt;&lt; e1.use_count() &lt;&lt; std::endl;        ew &#x3D; e1;        std::cout &lt;&lt; e1.use_count() &lt;&lt; std::endl;        observe(ew);        puts(&quot;-----Leaving scope-----&quot;);    &#125;    observe(ew);    puts(&quot;&gt;&gt;&gt;&gt;&gt;Leaving ex4&lt;&lt;&lt;&lt;&lt;&quot;);&#125;int main(int argc, char const *argv[])&#123;    ex4();    return 0;&#125;&gt;&gt;&gt;&gt;&gt;Entering ex4&lt;&lt;&lt;&lt;&lt;-----Entering scope-----Entity created!11*****Entering observe*****2entity still alive*****Leaving observe*****-----Leaving scope-----Entity destroyed!*****Entering observe*****entity was expired*****Leaving observe*****&gt;&gt;&gt;&gt;&gt;Leaving ex4&lt;&lt;&lt;&lt;&lt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="2021/04/27/C-STL-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>2021/04/27/C-STL-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;int main(int argc, char const *argv[]) &#123;    stack&lt;int&gt; st;    st.push(12);    st.push(34);    st.push(56);    while (!st.empty()) &#123;        cout &lt;&lt; st.top() &lt;&lt; &quot; &quot;;        st.pop();    &#125;    cout &lt;&lt; endl;    queue&lt;int&gt; q;    q.push(14);    q.push(25);    q.push(36);    while (!q.empty()) &#123;        cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;;        q.pop();    &#125;    cout &lt;&lt; endl;    return 0;&#125;56 34 12 &#x2F;&#x2F; 先进后出14 25 36 &#x2F;&#x2F; 先进先出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">priority_queue&lt;int&gt; q;q.push(14);q.push(25);q.push(36);while (!q.empty()) &#123;    cout &lt;&lt; q.top() &lt;&lt; &quot; &quot;;    q.pop();&#125;cout &lt;&lt; endl;36 25 14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>lamda表达式</title>
      <link href="2021/04/26/C-lamda/"/>
      <url>2021/04/26/C-lamda/</url>
      
        <content type="html"><![CDATA[<h2 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h2><p>以<code>[]</code>开头，后面是参数列表，比函数对象更简洁<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Print&#123;public:    void operator () (const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;for_each(vi.begin(), vi.end(), Print());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>可以简写为<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">for_each(vi.begin(), vi.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><code>[]</code>内可以接受参数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Greater&#123;public:    bool operator () (const int&amp; val) &#123;return (val &gt; 5);&#125;&#125;;auto it &#x3D; find_if(vi.begin(), vi.end(), Greater());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以简写为<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int num &#x3D; 5;auto it &#x3D; find_if(vi.begin(), vi.end(), [num](const int&amp; val) &#123;return (val &gt; num);&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><p>添加关键字multable可以在lamda表达式内部修改通过[]传入的参数，离开lamda表达式之后就无效了，要在外部有效，需要按引用传递<br>可以用<code>-&gt;</code>指定返回类型<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">[State1, State2](Type var1, Type var2) -&gt; ReturnType&#123; return (value or expression); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="二元lamda表达式"><a href="#二元lamda表达式" class="headerlink" title="二元lamda表达式"></a>二元lamda表达式</h2><p>两个<code>vector</code>中的元素对应相乘<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">transform(vi.begin(), vi.end(), multiple.begin(), result.begin(), [](int&amp; a, int&amp; b) &#123;return a * b;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi;    for (int i &#x3D; 0; i &lt; 10; i++) &#123;        vi.push_back(i);    &#125;    for_each(vi.begin(), vi.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);    cout &lt;&lt; endl;    vector&lt;int&gt; multiple;    for (int i &#x3D; 10; i &lt; 20; i++) &#123;        multiple.push_back(i);    &#125;    for_each(multiple.begin(), multiple.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);    cout &lt;&lt; endl;    vector&lt;int&gt; result;    result.resize(vi.size());    transform(vi.begin(), vi.end(), multiple.begin(), result.begin(), [](int&amp; a, int&amp; b) &#123;return a * b;&#125;);    for_each(result.begin(), result.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);    cout &lt;&lt; endl;    return 0;&#125;0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 0 11 24 39 56 75 96 119 144 171 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="通过lamda表达式自定义sort"><a href="#通过lamda表达式自定义sort" class="headerlink" title="通过lamda表达式自定义sort"></a>通过lamda表达式自定义sort</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">for_each(result.begin(), result.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);sort(result.begin(), result.end(), [](int&amp; a, int&amp; b) &#123;return a &gt; b;&#125;);for_each(result.begin(), result.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);0 11 24 39 56 75 96 119 144 171 171 144 119 96 75 56 39 24 11 0     &#x2F;&#x2F; 自定义从大到小排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出满足条件的元素个数<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 输出偶数个数cout &lt;&lt; count_if(vi.begin(), vi.end(), [](const int&amp; val) &#123;return !(val % 2);&#125;) &lt;&lt; endl;0 1 2 3 4 5 6 7 8 9 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL常用算法</title>
      <link href="2021/04/24/C-STL-STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>2021/04/24/C-STL-STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="遍历每个元素-for-each"><a href="#遍历每个元素-for-each" class="headerlink" title="遍历每个元素 for_each"></a>遍历每个元素 for_each</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">for_each(vi.begin(), vi.end(), Print());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查找某个元素-find-find-if"><a href="#查找某个元素-find-find-if" class="headerlink" title="查找某个元素 find/find_if"></a>查找某个元素 find/find_if</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto it &#x3D; find(vi.begin(), vi.end(), 5);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct IsMultiple &#123;    int Divisor;    IsMultiple(int x &#x3D; 0) : Divisor(x) &#123;&#125;    bool operator () (const int&amp; input) &#123;return !(input % Divisor);&#125;&#125;;int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi;    for (size_t i &#x3D; 23; i &lt; 32; i++) &#123;        vi.push_back(i);    &#125;    int Divisor &#x3D; 7;    auto iElement &#x3D; find_if(vi.begin(), vi.end(), IsMultiple(Divisor));    if (iElement !&#x3D; vi.end()) &#123;        cout &lt;&lt; &quot;First element divisible by &quot; &lt;&lt; Divisor;        cout &lt;&lt; &quot;: &quot; &lt;&lt; *iElement &lt;&lt; endl;    &#125;    return 0;&#125;First element divisible by 7: 28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用了<code>find_if</code>方法<br>对<code>vi</code>里的每个元素调用一元谓词<code>IsMultiple(Divisor)</code>函数对象，找到第一个整除<code>Divisor</code>的数</p><h2 id="转换-transform"><a href="#转换-transform" class="headerlink" title="转换 transform"></a>转换 transform</h2><p>字符串大小写转换<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string str &#x3D; &quot;hello&quot;;string copy;copy.resize(str.size());transform(str.begin(), str.end(), copy.begin(), ::toupper);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>从一个<code>vector</code>转换到另一个<code>vector</code>，进行一些变换<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template&lt;typename T&gt;class Add &#123;public:    T operator () (const T&amp; val) &#123;return (val + 100);&#125;&#125;;transform(vi.begin(), vi.end(), target.begin(), Add&lt;int&gt;());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="计数-count-count-if"><a href="#计数-count-count-if" class="headerlink" title="计数 count/count_if"></a>计数 count/count_if</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">count(vi.begin(), vi.end(), 6)  返回等于6的数量count_if(vi.begin(), vi.end(), Greater())   返回满足条件的数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="复制-copy-copy-if"><a href="#复制-copy-copy-if" class="headerlink" title="复制 copy/copy_if"></a>复制 copy/copy_if</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; copyVec(vi.size() * 2);auto it2 &#x3D; copy(vi.begin(), vi.end(), copyVec.begin());for_each(copyVec.begin(), copyVec.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);cout &lt;&lt; endl;copy_if(vi.begin(), vi.end(), it2, [](int&amp; val) &#123;return (val % 2);&#125;);for_each(copyVec.begin(), copyVec.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);cout &lt;&lt; endl;0 1 2 3 4 5 6 7 8 9                         &#x2F;&#x2F; vi0 1 2 3 4 5 6 7 8 9 0 0 0 0 0 0 0 0 0 0     &#x2F;&#x2F; 复制了vi的全部元素0 1 2 3 4 5 6 7 8 9 1 3 5 7 9 0 0 0 0 0     &#x2F;&#x2F; 从返回的迭代器位置开始复制vi的奇数元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="搜索-binary-search"><a href="#搜索-binary-search" class="headerlink" title="搜索 binary_search"></a>搜索 binary_search</h2><p>二分查找只能用于已排序的容器，返回<code>true/false</code></p><h2 id="删除-remove-remove-if"><a href="#删除-remove-remove-if" class="headerlink" title="删除 remove/remove_if"></a>删除 remove/remove_if</h2><p><code>remove_if</code>要配合<code>erase</code>使用，因为返回的是无用的部分的迭代器<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; vi;for (size_t i &#x3D; 0; i &lt; 10; i++) &#123;    vi.push_back(i);&#125;info(vi);int x &#x3D; 5;auto it &#x3D; remove_if(vi.begin(), vi.end(), [x](int&amp; val) &#123;return val &lt; x;&#125;);info(vi);cout &lt;&lt; *it &lt;&lt; endl;vi.erase(it, vi.end());info(vi);0 1 2 3 4 5 6 7 8 9 5 6 7 8 9 5 6 7 8 9     &#x2F;&#x2F; 把 5~9替换掉前面的0~45   &#x2F;&#x2F; 返回指向无用部分的第一个元素5 6 7 8 9   &#x2F;&#x2F; 再用erase把后面那些没用的删掉<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="删除重复元素-unique"><a href="#删除重复元素-unique" class="headerlink" title="删除重复元素 unique"></a>删除重复元素 unique</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto it &#x3D; unique(vi.begin(), vi.end());vi.erase(it, vi.end());info(vi);-1 -1 -1 -1 8 8 8 8-1 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="替换-replace-replace-if"><a href="#替换-replace-replace-if" class="headerlink" title="替换 replace/replace_if"></a>替换 replace/replace_if</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; vi(8);fill(vi.begin(), vi.begin() + 4, 5);fill_n(vi.begin() + 4, 4, 8);info(vi);replace(vi.begin(), vi.end(), 5, 1);info(vi);replace_if(vi.begin(), vi.end(), [](int&amp; val) &#123;return (val % 2);&#125;, -1);info(vi);5 5 5 5 8 8 8 8         &#x2F;&#x2F; 填充前4格为5，后4歌为81 1 1 1 8 8 8 8         &#x2F;&#x2F; 把5替换成1-1 -1 -1 -1 8 8 8 8     &#x2F;&#x2F; 把奇数替换成-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分区-partition-stable-partition"><a href="#分区-partition-stable-partition" class="headerlink" title="分区 partition/stable_partition"></a>分区 partition/stable_partition</h2><p><code>partition</code>是乱序的<br><code>stable_partition</code>保持原来的顺序<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; partition(vi.begin(), vi.end(), [](int&amp; val) &#123;return (val % 2);&#125;);info(vi);stable_partition(vi.begin(), vi.end(), [](int&amp; val) &#123;return (val % 2);&#125;);info(vi);0 1 2 3 4 5 6 7 8 9 1 3 5 7 9 0 2 4 6 8 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound/upper_bound"></a>lower_bound/upper_bound</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto it &#x3D; lower_bound(vi.begin(), vi.end(), 5);cout &lt;&lt; *it &lt;&lt; endl;it &#x3D; upper_bound(vi.begin(), vi.end(), 5);cout &lt;&lt; *it &lt;&lt; endl;0 1 2 3 4 5 6 7 8 9 5   &#x2F;&#x2F; 小于等于5的最大数是56   &#x2F;&#x2F; 大于5的最小数是6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例：基本数据类型"><a href="#代码示例：基本数据类型" class="headerlink" title="代码示例：基本数据类型"></a>代码示例：基本数据类型</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 这种叫函数对象class Print&#123;public:    void operator () (const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;class Add&#123;public:    int operator () (const int&amp; val) &#123;return (val + 100);&#125;&#125;;class Greater&#123;public:    bool operator () (const int&amp; val) &#123;return (val &gt; 5);&#125;&#125;;int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi;    for (int i &#x3D; 0; i &lt; 10; i++) &#123;        vi.push_back(i);    &#125;    for_each(vi.begin(), vi.end(), Print());    cout &lt;&lt; endl;    auto it &#x3D; find(vi.begin(), vi.end(), 5);    if (it !&#x3D; vi.end()) &#123;        cout &lt;&lt; *it &lt;&lt; endl;    &#125;    cout &lt;&lt; binary_search(vi.begin(), vi.end(), 8) &lt;&lt; endl;    it &#x3D; find_if(vi.begin(), vi.end(), Greater());    if (it !&#x3D; vi.end()) &#123;        cout &lt;&lt; &quot;Found greater than five: &quot; &lt;&lt; *it &lt;&lt; endl;    &#125;    vi.push_back(6);    cout &lt;&lt; &quot;number of six: &quot; &lt;&lt; count(vi.begin(), vi.end(), 6) &lt;&lt; endl;    cout &lt;&lt; &quot;num of greater than five: &quot; &lt;&lt; count_if(vi.begin(), vi.end(), Greater()) &lt;&lt; endl;    vector&lt;int&gt; target;    target.resize(vi.size());    transform(vi.begin(), vi.end(), target.begin(), Add());    for_each(target.begin(), target.end(), Print());    cout &lt;&lt; endl;    return 0;&#125;0 1 2 3 4 5 6 7 8 9 51   &#x2F;&#x2F; binary_search的返回值是true&#x2F;false，表示是否找到该元素Found greater than five: 6number of six: 2num of greater than five: 5100 101 102 103 104 105 106 107 108 109 106 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例：自定义数据类型Person"><a href="#代码示例：自定义数据类型Person" class="headerlink" title="代码示例：自定义数据类型Person"></a>代码示例：自定义数据类型Person</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;class Person&#123;public:    string name;    int age;    Person(string _name, int _age): name(_name), age(_age) &#123;&#125;    bool operator &#x3D;&#x3D; (const Person&amp; input) &#123;        if (this-&gt;age &#x3D;&#x3D; input.age) &#123;            return true;        &#125;        else &#123;            return false;        &#125;    &#125;&#125;;class Add&#123;public:    int operator () (const int&amp; val) &#123;return (val + 100);&#125;&#125;;class GreaterAge&#123;public:    bool operator () (const Person&amp; input) &#123;        return (input.age &gt; 20);    &#125;&#125;;int main(int argc, char const *argv[])&#123;    printf(&quot;&gt;&gt;&gt;&gt;&gt;自定义数据类型&lt;&lt;&lt;&lt;&lt;&lt;\n&quot;);    vector&lt;Person&gt; person;    Person p1(&quot;kavin&quot;, 23);    Person p2(&quot;jack&quot;, 12);    Person p3(&quot;lisa&quot;, 12);    person.push_back(p1);    person.push_back(p2);    person.push_back(p3);    Person test(&quot;kavin&quot;, 23);    auto it2 &#x3D; find(person.begin(), person.end(), test);    if (it2 !&#x3D; person.end()) &#123;        cout &lt;&lt; &quot;Found test: &quot; &lt;&lt; it2-&gt;name &lt;&lt; &quot;, &quot; &lt;&lt; it2-&gt;age &lt;&lt; endl;    &#125;    auto it3 &#x3D; find_if(person.begin(), person.end(), GreaterAge());    if (it3 !&#x3D; person.end()) &#123;        cout &lt;&lt; &quot;Found age &gt; 20: &quot; &lt;&lt; it3-&gt;name &lt;&lt; &quot;, &quot; &lt;&lt; it3-&gt;age &lt;&lt; endl;    &#125;    Person p(&quot;test&quot;, 12);    cout &lt;&lt; &quot;same age: &quot; &lt;&lt; count(person.begin(), person.end(), p) &lt;&lt; endl;    cout &lt;&lt; &quot;num of age &gt; 20: &quot; &lt;&lt; count_if(person.begin(), person.end(), GreaterAge()) &lt;&lt; endl;    return 0;&#125;Found test: kavin, 23Found age &gt; 20: kavin, 23same age: 2num of age &gt; 20: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一元谓词"><a href="#一元谓词" class="headerlink" title="一元谓词"></a>一元谓词</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template&lt;typename T&gt;struct Count&#123;    int count;    Count(int x &#x3D; 0) : count(x) &#123;&#125;    void operator () (const T&amp; input) &#123;        ++count;        cout &lt;&lt; input &lt;&lt; &quot; &quot;;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi;    for (size_t i  &#x3D; 0; i &lt; 10; i++) &#123;        vi.push_back(i);    &#125;    Count&lt;int&gt; res;    &#x2F;&#x2F; Count&lt;int&gt;() 是函数对象    res &#x3D; for_each(vi.begin(), vi.end(), Count&lt;int&gt;());    cout &lt;&lt; endl;    cout &lt;&lt; res.count &lt;&lt; endl;    return 0;&#125;0 1 2 3 4 5 6 7 8 910<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对<code>vi</code>里的每个元素调用了<code>Count&lt;int&gt;()</code>函数，所以在<code>res</code>内部<code>count++</code>执行了10次，所以最后<code>count = 10</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-map</title>
      <link href="2021/04/24/C-STL-STL-map/"/>
      <url>2021/04/24/C-STL-STL-map/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="映射map"><a href="#映射map" class="headerlink" title="映射map"></a>映射map</h2><p><code>map</code>可以存储键-值对，不能重复的键，可以按键的大小排序，或者自定义<br><code>multimap</code>可以重复的键<br><code>unordered_map</code>查找时间复杂度为常数</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">map&lt;int, string, Compare&lt;int&gt;&gt; mapIntToString;int --&gt; stringCompare&lt;int&gt; 是排序结构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="构造键值对"><a href="#构造键值对" class="headerlink" title="构造键值对"></a>构造键值对</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mapIntToString.insert(make_pair(23, &quot;kavin&quot;));mapIntToString.insert(pair&lt;int, string&gt;(10, &quot;jack&quot;));mapIntToString[100] &#x3D; &quot;lisa&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;&#x2F;&#x2F; 自定义的排序结构template&lt;typename T&gt;struct Compare&#123;    bool operator () (const T&amp; key1, const T&amp; key2) const &#123;        return key1 &gt; key2;    &#125;&#125;;template&lt;typename T&gt;void info(const T&amp; se) &#123;    cout &lt;&lt; &quot;INFO: &quot;;    for (auto it &#x3D; se.begin(); it !&#x3D; se.end(); it++) &#123;        cout &lt;&lt; &quot;(&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    map&lt;int, string, Compare&lt;int&gt;&gt; mapIntToString;    mapIntToString.insert(make_pair(23, &quot;kavin&quot;));    mapIntToString.insert(pair&lt;int, string&gt;(10, &quot;jack&quot;));    mapIntToString[100] &#x3D; &quot;lisa&quot;;    info(mapIntToString);    auto it &#x3D; mapIntToString.find(100);    if (it !&#x3D; mapIntToString.end()) &#123;        cout &lt;&lt; &quot;Found: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    &#x2F;&#x2F; mapIntToString.erase(it);    mapIntToString.erase(10);    info(mapIntToString);    return 0;&#125;INFO: (100-&gt;lisa) (23-&gt;kavin) (10-&gt;jack) Found: 100-&gt;lisaINFO: (100-&gt;lisa) (23-&gt;kavin) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    multimap&lt;int, string&gt; multimapIntToString(mapIntToString.begin(), mapIntToString.end());    multimapIntToString.insert(make_pair(100, &quot;lili&quot;));    info(multimapIntToString);    cout &lt;&lt; multimapIntToString.count(100) &lt;&lt; endl;    it &#x3D; multimapIntToString.find(100);    if (it !&#x3D; multimapIntToString.end()) &#123;        size_t numOfKey &#x3D; multimapIntToString.count(100);        for (size_t i &#x3D; 0; i &lt; numOfKey; i++) &#123;            cout &lt;&lt; &quot;Found: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;            ++it;        &#125;    &#125;    return 0;&#125;INFO: (100-&gt;lisa) (23-&gt;kavin) INFO: (23-&gt;kavin) (100-&gt;lisa) (100-&gt;lili) 2Found: 100-&gt;lisaFound: 100-&gt;lili<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用循环的方式遍历找到的值</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-set</title>
      <link href="2021/04/23/C-STL-STL-set/"/>
      <url>2021/04/23/C-STL-STL-set/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><p>集合内部元素是有序的不能重复<br>不能通过指针修改元素的值，只能删掉，重新插入<br><code>multiset</code>可以添加重复元素</p><ul><li>插入元素 </li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Integer.insert(12);multiInteger.insert(Integer.begin(), Integer.end());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>查找元素</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto it &#x3D; Integer.find(23);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>删除元素</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Integer.erase(it);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>统计元素个数（针对multiset）</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">multiInteger.count(10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查找第一个大于或小于某个值的数</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">upper_bound()lower_bound()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="代码示例1-set与multiset"><a href="#代码示例1-set与multiset" class="headerlink" title="代码示例1: set与multiset"></a>代码示例1: set与multiset</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;struct Contact&#123;    string name;    int num;    Contact(const string&amp; _name, const int&amp; _num) &#123;        name &#x3D; _name;        num &#x3D; _num;    &#125;    bool operator &lt; (const Contact&amp; itemToCompare) const &#123;        return this-&gt;num &lt; itemToCompare.num;    &#125;    void display() const &#123;        cout &lt;&lt; &quot;name&#x3D;&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;, num&#x3D;&quot; &lt;&lt; this-&gt;num &lt;&lt; endl;    &#125;&#125;;template&lt;typename T&gt;void info(const T&amp; se) &#123;    cout &lt;&lt; &quot;INFO: &quot;;    for (auto&amp; s : se) &#123;        cout &lt;&lt; s &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    set&lt;int&gt; Integer;    Integer.insert(12);    Integer.insert(23);    Integer.insert(1);    info(Integer);    it &#x3D; Integer.upper_bound(10);    if (it !&#x3D; Integer.end())        cout &lt;&lt; &quot;Found: &quot; &lt;&lt; *it &lt;&lt; endl;    else        cout &lt;&lt; &quot;NOT Found&quot; &lt;&lt; endl;    auto it &#x3D; Integer.find(23);    if (it !&#x3D; Integer.end()) &#123;        cout &lt;&lt; *it &lt;&lt; endl;    &#125;    Integer.erase(it);    info(Integer);    Integer.clear();    info(Integer);    multiset&lt;int&gt; multiInteger;    multiInteger.insert(10);    multiInteger.insert(10);    multiInteger.insert(Integer.begin(), Integer.end());    info(multiInteger);    cout &lt;&lt; multiInteger.count(10) &lt;&lt; endl;    return 0;&#125;INFO: 1 12 23 Found: 12   &#x2F;&#x2F; 找到第一个大于10的元素23INFO: 1 12 INFO: INFO: 10 10 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例2-存储结构体"><a href="#代码示例2-存储结构体" class="headerlink" title="代码示例2: 存储结构体"></a>代码示例2: 存储结构体</h2><p>要重载&lt;和==运算符，前者用于排序，后者用于查找<br><strong>问题</strong><br>用哪个值去实现&lt;运算符，也会用那个值去find<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct Contact&#123;    string name;    int num;    Contact(const string&amp; _name, const int&amp; _num) &#123;        name &#x3D; _name;        num &#x3D; _num;    &#125;    &#x2F;&#x2F; 如果这里用num去排序，查找时也是看num相不相同    bool operator &lt; (const Contact&amp; itemToCompare) const &#123;        return (this-&gt;name &lt; itemToCompare.name);    &#125;    &#x2F;&#x2F; 所以这里的规则最好一样    bool operator &#x3D;&#x3D; (const Contact&amp; itemToCompare) const &#123;        return (this-&gt;name &#x3D;&#x3D; itemToCompare.name);    &#125;    void display() const &#123;        cout &lt;&lt; &quot;name&#x3D;&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;, num&#x3D;&quot; &lt;&lt; this-&gt;num &lt;&lt; endl;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    const string NameInput &#x3D; &quot;kavin&quot;;    auto iterator &#x3D; setContacts.find(Contact(NameInput, 0));    if (iterator !&#x3D; setContacts.end()) &#123;        cout &lt;&lt; &quot;Found: &quot;;        iterator-&gt;display();    &#125;    else &#123;        cout &lt;&lt; &quot;NOT Found!!!&quot; &lt;&lt; endl;    &#125;    return 0;&#125;name&#x3D;jack, num&#x3D;23name&#x3D;joke, num&#x3D;0name&#x3D;kavin, num&#x3D;12name&#x3D;lisa, num&#x3D;34Found: name&#x3D;kavin, num&#x3D;12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>这里可以看到输入的是<code>(&quot;kavin&quot;,0)</code>，但是他还是找到了<code>(&quot;kavin&quot;,12)</code>，因为相等的规则是名字相同就可以</p><h2 id="散列表unordered-set"><a href="#散列表unordered-set" class="headerlink" title="散列表unordered_set"></a>散列表unordered_set</h2><p>无序的集合，不能重复<br>但是可以实现查找时间复杂度为常数<br><code>unordered_multiset</code>可以存储重复元素<br>查找、删除、<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;unordered_set&gt;using namespace std;template&lt;typename T&gt;void info(const T&amp; input) &#123;    cout &lt;&lt; &quot;Size&#x3D;&quot; &lt;&lt; input.size() &lt;&lt; endl;    cout &lt;&lt; &quot;Max bucket&#x3D;&quot; &lt;&lt; input.max_bucket_count() &lt;&lt; endl;    cout &lt;&lt; &quot;Load factor&#x3D;&quot; &lt;&lt; input.load_factor() &lt;&lt; endl;    cout &lt;&lt; &quot;INFO: &quot;;    for (auto&amp; s : input) &#123;        cout &lt;&lt; s &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    unordered_set&lt;int&gt; num &#x3D; &#123;45, 23, 78, 54&#125;;    info(num);    auto it &#x3D; num.find(78);    if (it !&#x3D; num.end()) &#123;        cout &lt;&lt; &quot;Found: &quot; &lt;&lt; *it &lt;&lt; endl;    &#125;    num.erase(it);    info(num);    return 0;&#125;Size&#x3D;4  &#x2F;&#x2F; 当前存储的元素个数Max bucket&#x3D;1152921504606846975  &#x2F;&#x2F; 最大可存储的元素数Load factor&#x3D;0.8INFO: 54 78 23 45 Found: 78Size&#x3D;3Max bucket&#x3D;1152921504606846975Load factor&#x3D;0.6INFO: 54 23 45 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-list</title>
      <link href="2021/04/23/C-STL-STL-list/"/>
      <url>2021/04/23/C-STL-STL-list/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="list双向链表"><a href="#list双向链表" class="headerlink" title="list双向链表"></a>list双向链表</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;list&gt;using namespace std;struct Contact&#123;    string name;    int num;    Contact(const string&amp; _name, const int&amp; _num) &#123;        name &#x3D; _name;        num &#x3D; _num;    &#125;    &#x2F;&#x2F; 需要重载&quot;&lt;&quot;运算符，让list知道怎么排序    bool operator &lt; (const Contact&amp; itemToCompare) const &#123;        return this-&gt;num &lt; itemToCompare.num;    &#125;&#125;;&#x2F;&#x2F; 自定义二元谓词函数实现自定义排序顺序bool descending(const int&amp; lsh, const int&amp; rsh) &#123;    return lsh &gt; rsh;&#125;int main(int argc, char const *argv[])&#123;    list&lt;int&gt; li &#x3D; &#123;12, 23&#125;;    info(li);       &#x2F;&#x2F; 12 23     li.push_back(100);  &#x2F;&#x2F; 从尾部插入    li.push_front(-1);  &#x2F;&#x2F; 从头部插入    info(li);       &#x2F;&#x2F; -1 12 23 100    li.insert(li.begin(), 2, 20);    info(li);       &#x2F;&#x2F; 20 20 -1 12 23 100     li.pop_back();  &#x2F;&#x2F; 从尾部弹出    li.pop_front(); &#x2F;&#x2F; 从头部弹出    info(li);    &#x2F;&#x2F; 20 -1 12 23     li.reverse();   &#x2F;&#x2F; 翻转    info(li);    &#x2F;&#x2F; 23 12 -1 20     li.sort();      &#x2F;&#x2F; 默认是从小到大排序    info(li);    &#x2F;&#x2F; -1 12 20 23     li.sort(descending);    &#x2F;&#x2F; 自定义从大到小排序    info(li);    &#x2F;&#x2F; 23 20 12 -1     Contact c1(&quot;kavin&quot;, 12);    Contact c2(&quot;jack&quot;, 23);    Contact c3(&quot;lisa&quot;, 34);    list&lt;Contact&gt; contacts &#x3D; &#123;c1, c2, c3&#125;;    contacts.sort();    for (auto it : contacts) &#123;        it.info();    &#125;    return 0;&#125;name&#x3D;kavin, num&#x3D;12name&#x3D;jack, num&#x3D;23name&#x3D;lisa, num&#x3D;34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-vector</title>
      <link href="2021/04/20/C-STL-STL-vector/"/>
      <url>2021/04/20/C-STL-STL-vector/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="vector动态数组"><a href="#vector动态数组" class="headerlink" title="vector动态数组"></a>vector动态数组</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li>初始化列表</li><li>n个相同的元素</li><li>复制另一个vector初始化</li><li>复制另一个vector的一部分初始化</li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi &#x3D; &#123;20, 30&#125;;    vi.push_back(45);    vi.push_back(67);    for (auto&amp; v : vi) &#123;        cout &lt;&lt; v &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        vector&lt;int&gt; vec1(5, 23);    for (auto&amp; v : vec1) &#123;        cout &lt;&lt; v &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    vector&lt;int&gt; vec2(vec1);    for (auto&amp; v : vec2) &#123;        cout &lt;&lt; v &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    vector&lt;int&gt; vec3(vec1.begin(), vec1.begin() + 3);    for (auto&amp; v : vec3) &#123;        cout &lt;&lt; v &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;20 30 45 6723 23 23 23 23 23 23 23 23 23 23 23 23 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto it &#x3D; find(vi.begin(), vi.end(), 67);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><ol><li>在某个位置插入一个元素</li><li>在某个位置插入n个相同的元素</li><li>在某个位置插入另一个vector的元素</li></ol><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi &#x3D; &#123;20, 30&#125;;    vi.push_back(45);    vi.push_back(67);    vi.insert(vi.begin(), 123);    vi.insert(vi.end(), 2, 89);    vector&lt;int&gt; temp(3, 100);    vi.insert(vi.begin() + 1, temp.begin(), temp.end());    return 0;&#125;20 30 45 67 123 20 30 45 67     &#x2F;&#x2F; 在头部插入一个元素123 20 30 45 67 89 89   &#x2F;&#x2F; 在尾部插入2个相同的元素123 100 100 100 20 30 45 67 89 89   &#x2F;&#x2F; 在第一个元素位置插入一个vector<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">begin()end()cbegin()cend()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><ol><li>迭代器</li><li>下标运算符[]</li><li>成员函数at()</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main() &#123;    vector&lt;int&gt; vi;    vi.push_back(45);    vi.push_back(67);    cout &lt;&lt; *vi.cbegin() &lt;&lt; endl;    auto it &#x3D; find(vi.begin(), vi.end(), 67);    if (it !&#x3D; vi.end()) &#123;        int index &#x3D; distance(vi.begin(), it);        cout &lt;&lt; *it &lt;&lt; endl;        cout &lt;&lt; index;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pop_back()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="大小和容量"><a href="#大小和容量" class="headerlink" title="大小和容量"></a>大小和容量</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size(): 返回vector大小capacity(): 返回vector容量，容量不够时会自动重新分配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">push_front(): 从头部插入pop_front(): 从头部弹出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template&lt;typename T&gt;void info(const deque&lt;T&gt;&amp; q) &#123;    for (auto&amp; x : q) &#123;        cout &lt;&lt; x &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void disp(const deque&lt;int&gt;&amp; q) &#123;    for (auto it &#x3D; q.begin(); it !&#x3D; q.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    deque&lt;int&gt; q;    q.push_back(10);    q.push_back(11);    q.push_back(12);    q.push_front(9);    info(q);    q.pop_back();    q.pop_front();    disp(q);    return 0;&#125;9 10 11 12 10 11 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载赋值运算符</title>
      <link href="2021/04/20/C-%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2021/04/20/C-%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>运算符重载是<code>C++</code>的一项强大功能。通过重载，可以扩展<code>C++</code>运算符的功能，使它们能够操作用户自定义的数据类型，增加程序代码的直观性和可读性。</p><p>本章主要介绍类成员运算符重载与友元运算符重载，二元运算符与一元运算符重载，运算符<code>++、--、[]、()</code>重载，<code>this</code>指针与运算符重载及 流运算符<code>&lt;&lt;</code>和<code>&gt;&gt;</code>的重载</p><h2 id="一、重载二元运算符"><a href="#一、重载二元运算符" class="headerlink" title="一、重载二元运算符"></a>一、重载二元运算符</h2><h3 id="二元运算符的调用形式与解析"><a href="#二元运算符的调用形式与解析" class="headerlink" title="二元运算符的调用形式与解析"></a>二元运算符的调用形式与解析</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">aa@bb可解释成: aa.operator@(bb)或解释成: operator@(aa,bb)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果两者都有定义,就按照重载解析</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class X&#123;public:    void operator + (int);    X(int);&#125;;void operator + (X, X);void operator + (X, double);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="类运算符重载形式"><a href="#类运算符重载形式" class="headerlink" title="类运算符重载形式"></a>类运算符重载形式</h3><h4 id="非静态成员运算符重载"><a href="#非静态成员运算符重载" class="headerlink" title="非静态成员运算符重载"></a>非静态成员运算符重载</h4><p>以类成员形式重载的运算符参数比实际参数少一个，第1个参数是以<code>this</code>指针隐式传递的。 </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Complex&#123;    double real,image;public:    Complex operator+(Complex b)&#123;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="友元运算符重载"><a href="#友元运算符重载" class="headerlink" title="友元运算符重载"></a>友元运算符重载</h4><p>如果将运算符函数作为类的友元重载，它需要的参数个数就与运算符实际需要的参数个数相同。比如，若用友元函数重载Complex类的加法运算符，则形式如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Complex&#123;    friend Complex operator+(Complex a,Complex b);  &#x2F;&#x2F;声明&#125;;Complex operator+(Complex a,Complex b)&#123;&#125;         &#x2F;&#x2F;定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、重载一元运算符"><a href="#二、重载一元运算符" class="headerlink" title="二、重载一元运算符"></a>二、重载一元运算符</h2><p>一元运算符只需要一个运算参数，如取地址运算符（&amp;）、负数（-）、自增加（++）等。</p><p>常见调用形式为：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">@a 或 a@  &#x2F;&#x2F;隐式调用形式a.operator@()   &#x2F;&#x2F; 显式调用一元运算符@其中的@代表一元运算符，a代表操作数。@a代表前缀一元运算，如“++a”；a@表示后缀运算，如“a++”。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>@a将被C++解释为下面的形式之一</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">a.operator@()operator@(a) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一元运算符作为类成员函数重载时不需要参数，其形式如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class X&#123;    T operator@()&#123;&#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>T是运算符@的返回类型。从形式上看，作为类成员函数重载的一元运算符没有参数，但实际上它包含了一个隐含参数<br>即调用对象的this指针。</p><h3 id="前自增-减-与后自增-减"><a href="#前自增-减-与后自增-减" class="headerlink" title="前自增(减)与后自增(减)"></a>前自增(减)与后自增(减)</h3><p>C++编译器可以通过在运算符函数参数表中是否插入关键字<code>int</code>来区分这两种方式</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;前缀operator -- ();operator -- (X &amp; x);&#x2F;&#x2F;后缀operator -- (int);operator -- (X &amp; x, int);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、重载赋值运算符"><a href="#三、重载赋值运算符" class="headerlink" title="三、重载赋值运算符="></a>三、重载赋值运算符<code>=</code></h2><p>赋值运算进行时将调用此运算符</p><p>只能用成员函数重载</p><p>如果需要而没有定义时，编译器自动生成，该版本进行<code>bit-by-bit</code>拷贝</p><h2 id="四、重载"><a href="#四、重载" class="headerlink" title="四、重载[]"></a>四、重载<code>[]</code></h2><p>1、<code>[]</code>是一个二元运算符，其重载形式如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class X&#123;    X&amp; operator[](int n);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2、 重载<code>[]</code>需要注意的问题</p><ul><li><code>[]</code>是一个二元运算符，其第1个参数是通过对象的<code>this</code>指针传递的，第2个参数代表数组的下标</li><li>由于<code>[]</code>既可以出现在赋值符<code>=</code>的左边，也可以出现在赋值符<code>=</code>的右边，所以重载运算符<code>[]</code>时常返回引用。</li><li><strong><code>[]</code>只能被重载为类的非静态成员函数，不能被重载为友元和普通函数</strong>。</li></ul><h2 id="五、重载"><a href="#五、重载" class="headerlink" title="五、重载()"></a>五、重载<code>()</code></h2><p>1、运算符<code>()</code>是函数调用运算符，也能被重载。且只能被重载为类的成员函数。</p><p>2、运算符<code>()</code>的重载形式如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class X&#123;    X&amp; operator()(参数表);&#125;；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中的参数表可以包括任意多个参数。</p><p>3、运算符( )的调用形式如下：<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">X Obj;      &#x2F;&#x2F;对象定义Obj()(参数表);      &#x2F;&#x2F;调用形式1Obj(参数表);        &#x2F;&#x2F;调用形式2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><h2 id="六、代码示例"><a href="#六、代码示例" class="headerlink" title="六、代码示例"></a>六、代码示例</h2><p>返回值要写成类引用<code>Class&amp;</code>，不然会再调用构造函数新建一个临时变量</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A&#123;public:    A(int val &#x3D; 0): x(val) &#123;         cout &lt;&lt; &quot;A: constructor. &quot;;         cout &lt;&lt; &quot;x &#x3D; &quot; &lt;&lt; val &lt;&lt; endl;    &#125;    &#x2F;&#x2F;返回引用类型    A&amp; operator &#x3D; (const A&amp; input) &#123;        cout &lt;&lt; &quot;copy Assignment&quot; &lt;&lt; endl;        x &#x3D; input.x;        return *this;    &#125;private:    int x;&#125;;int main(int argc, char const *argv[])&#123;    A a(34), b;    b &#x3D; a;    b.operator&#x3D;(a); &#x2F;&#x2F;写成这样也可以    A c &#x3D; a;    &#x2F;&#x2F; 写成这样就不会调用复制赋值运算符函数，编译器内部实现了    return 0;&#125;A: constructor. x &#x3D; 34A: constructor. x &#x3D; 0copy Assignment &#x2F;&#x2F; 调用了复制复制运算符函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载运算符</title>
      <link href="2021/04/18/C-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2021/04/18/C-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="project-1-重载-运算符"><a href="#project-1-重载-运算符" class="headerlink" title="project 1 重载()运算符"></a>project 1 重载()运算符</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Clock &#123;private:    int hour, minute, second;public:    Clock(int h, int m, int s) : hour(h), minute(m), second(s) &#123;&#125;    &#x2F;&#x2F; 重载()运算符    void operator()(int h, int m, int s) &#123;        hour &#x3D; h;        minute &#x3D; m;        second &#x3D; s;    &#125;    void ShowTime() &#123;        cout &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; second &lt;&lt; endl;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    Clock t1(12, 34, 45);    t1.ShowTime();    t1.operator()(10, 21, 32);    t1.ShowTime();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="project-2-重载-和-运算符"><a href="#project-2-重载-和-运算符" class="headerlink" title="project 2 重载()和[]运算符"></a>project 2 重载()和[]运算符</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;using namespace std;class X&#123;public:    int operator() (int i &#x3D; 0) &#123;        cout &lt;&lt; &quot;X operator (&quot; &lt;&lt; i &lt;&lt; &quot;)&quot; &lt;&lt; endl;        return i;    &#125;    int operator[] (int j) &#123;        cout &lt;&lt; &quot;X operator [&quot; &lt;&lt; j &lt;&lt; &quot;]&quot; &lt;&lt; endl;        return j;    &#125;&#125;;int main (void)&#123;       X obj;    int i &#x3D; obj(1);    cout &lt;&lt; i &lt;&lt; endl;    int j &#x3D; obj[234];    cout &lt;&lt; j &lt;&lt; endl;    return 0;&#125;X operator (1)1X operator [234]234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sublime</code>的代码复制到<code>VScode</code>之后会出现空格不一致的问题，解决方法是在<code>sublime</code>中把<code>tab</code>替换为空格<br><code>Perference-&gt;setting</code>添加<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&quot;tab_size&quot;: 4,&quot;translate_tabs_to_spaces&quot;: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p><h2 id="project-3-员工工资系统"><a href="#project-3-员工工资系统" class="headerlink" title="project 3 员工工资系统"></a>project 3 员工工资系统</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct person &#123;    double salary;    char* name;&#125;;class SalaryManage &#123;private:    person* employee;    int max;    &#x2F;&#x2F; 可容纳员工数    int count;  &#x2F;&#x2F; 当前员工数public:    SalaryManage(int Max &#x3D; 0) &#123;        max &#x3D; Max;        count &#x3D; 0;        employee &#x3D; new person[max];    &#125;    double &amp;operator [] (const char* Name) &#123;        person* ptr;        for (ptr &#x3D; employee; ptr &lt;&#x3D; employee + count; ptr++) &#123;            if (strcmp(ptr-&gt;name, Name) &#x3D;&#x3D; 0) &#123;                return ptr-&gt;salary;            &#125;            ptr &#x3D; employee + count; &#x2F;&#x2F; 跳到最后一个            count++;                &#x2F;&#x2F; 员工数++            ptr-&gt;name &#x3D; new char[strlen(Name) + 1]; &#x2F;&#x2F; 新建一个员工            strcpy(ptr-&gt;name, Name);            ptr-&gt;salary &#x3D; 0;            return ptr-&gt;salary;        &#125;    &#125;    void display() &#123;        for (int i &#x3D; 0; i &lt; count; i++) &#123;            cout &lt;&lt; employee[i].name &lt;&lt; &quot;: &quot; &lt;&lt; employee[i].salary &lt;&lt; endl;        &#125;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    SalaryManage s(2);    const char* ch1 &#x3D; &quot;kavin&quot;;    s[ch1] &#x3D; 3.2;    const char* ch2 &#x3D; &quot;jack&quot;;    s[ch2] &#x3D; 123.2;    cout &lt;&lt; s[ch1] &lt;&lt; endl;    s.display();    return 0;&#125;3.2kavin: 3.2jack: 123.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>C++11</code>不能直接从<code>string</code>字符串转为<code>char*</code>，所以用一个指向字符串常量的指针指向他</p><h2 id="project-4-重载二元运算符"><a href="#project-4-重载二元运算符" class="headerlink" title="project 4 重载二元运算符"></a>project 4 重载二元运算符</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Complex&#123;public:    Complex(int _r &#x3D; 0, int _i &#x3D; 0) : r(_r), i(_i) &#123;&#125;    Complex operator + (Complex input);    Complex operator - (Complex input);    void info();private:    int r, i;&#125;;Complex Complex::operator + (Complex input) &#123;    return Complex(this-&gt;r + input.r, this-&gt;i + input.i);&#125;Complex Complex::operator - (Complex input) &#123;    return Complex(this-&gt;r - input.r, this-&gt;i - input.i);&#125;void Complex::info() &#123;    cout &lt;&lt; this-&gt;r;    if (this-&gt;i &gt; 0) cout &lt;&lt; &quot;+&quot;;    if (this-&gt;i !&#x3D; 0) cout &lt;&lt; this-&gt;i &lt;&lt; &quot;i&quot; &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    Complex a(2, -3);    a.info();    Complex b(3, 4);    b.info();    Complex c &#x3D; a + b;    c.info();    Complex d &#x3D; a - b;    d.info();    return 0;&#125;2-3i3+4i5+1i-1-7i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="project5-自定义String类"><a href="#project5-自定义String类" class="headerlink" title="project5 自定义String类"></a>project5 自定义String类</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class String&#123;public:    String(const char* &#x3D; &quot;&quot;);    ~String()&#123;&#125;    friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const String&amp; s) &#123;        return os &lt;&lt; s.sPtr;    &#125;    &#x2F;&#x2F; 声明为友元函数，参数要与实际需要的参数相同    friend String operator + (const String&amp; a, const String&amp; b);    const String&amp; operator &#x3D; (const String&amp;);    const String&amp; operator +&#x3D; (const String&amp;);    bool operator &#x3D;&#x3D; (const String&amp;);    bool operator !&#x3D; (const String&amp;);    bool operator &lt; (const String&amp;);    char&amp; operator [] (int index);    int getLength() &#123; return this-&gt;length; &#125;private:    char* sPtr;    int length;&#125;;String::String(const char* str) &#123;    this-&gt;sPtr &#x3D; new char[strlen(str) + 1];    strcpy(this-&gt;sPtr, str);    this-&gt;length &#x3D; strlen(str);&#125;&#x2F;&#x2F; 友元就不需要作用域String::了String operator + (const String&amp; a, const String&amp; b) &#123;    String res;    res.sPtr &#x3D; new char[a.length + b.length + 1];    strcpy(res.sPtr, a.sPtr);    strcat(res.sPtr, b.sPtr);    return String(res.sPtr);&#125;const String&amp; String::operator &#x3D; (const String&amp; s) &#123;    cout &lt;&lt; &quot;copy assignment&quot; &lt;&lt; endl;    this-&gt;length &#x3D; s.length;    strcpy(this-&gt;sPtr, s.sPtr);    return *this;&#125;const String&amp; String::operator +&#x3D; (const String&amp; s) &#123;    char* temp &#x3D; this-&gt;sPtr;    this-&gt;length +&#x3D; s.length;    this-&gt;sPtr &#x3D; new char[this-&gt;length + 1];    strcpy(this-&gt;sPtr, temp);    strcat(this-&gt;sPtr, s.sPtr);    delete[] temp;    return *this;&#125;bool String::operator &#x3D;&#x3D; (const String&amp; s) &#123;    return strcmp(this-&gt;sPtr, s.sPtr) &#x3D;&#x3D; 0;&#125;bool String::operator !&#x3D; (const String&amp; s) &#123;    return !(*this &#x3D;&#x3D; s);&#125;bool String::operator &lt; (const String&amp; s) &#123;    return strcmp(this-&gt;sPtr, s.sPtr) &lt; 0;&#125;char&amp; String::operator [] (int index) &#123;    return this-&gt;sPtr[index];&#125;int main(int argc, char const *argv[])&#123;    String s1(&quot;hello&quot;);    cout &lt;&lt; &quot;s1&#x3D;&quot; &lt;&lt; s1 &lt;&lt; endl;        String s2;    s2.operator&#x3D;(s1);    cout &lt;&lt; &quot;s2&#x3D;&quot; &lt;&lt; s2 &lt;&lt; endl;    s2 +&#x3D; &quot; world&quot;;    cout &lt;&lt; &quot;s2&#x3D;&quot; &lt;&lt; s2 &lt;&lt; endl;    for (int i &#x3D; 0; i &lt; s2.getLength(); i++) &#123;        cout &lt;&lt; s2[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    String s3 &#x3D; s1 + s2;    cout &lt;&lt; &quot;s3&#x3D;&quot; &lt;&lt; s3 &lt;&lt; endl;    String s4(&quot;hello world&quot;);    if (s2 !&#x3D; s4) &#123;        cout &lt;&lt; &quot;s2!&#x3D;s4&quot; &lt;&lt; endl;    &#125; else &#123;        cout &lt;&lt; &quot;s2&#x3D;&#x3D;s4&quot; &lt;&lt; endl;    &#125;    String str1(&quot;abd&quot;);    String str2(&quot;abc&quot;);    if (str1 &lt; str2) &#123;        cout &lt;&lt; &quot;str1 &lt; str2&quot; &lt;&lt; endl;    &#125; else &#123;        cout &lt;&lt; &quot;str1 &gt;&#x3D; str2&quot; &lt;&lt; endl;    &#125;    return 0;&#125;s1&#x3D;hellocopy assignments2&#x3D;hellos2&#x3D;hello worldh e l l o   w o r l d s3&#x3D;hellohello worlds2&#x3D;&#x3D;s4str1 &gt;&#x3D; str2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="2021/04/18/C-%E7%BB%A7%E6%89%BF/"/>
      <url>2021/04/18/C-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="重载基类的方法"><a href="#重载基类的方法" class="headerlink" title="重载基类的方法"></a>重载基类的方法</h2><p>如果要使用基类的方法，可以用作用域解析运算符<code>(::)</code><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    void info() &#123;        cout &lt;&lt; this-&gt;x &lt;&lt; endl;    &#125;&#125;;class B : public A &#123;public:    void info() &#123;   &#x2F;&#x2F; 重载基类的方法        cout &lt;&lt; &quot;B: &quot; &lt;&lt; this-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; this-&gt;y &lt;&lt; endl;        A::info();  &#x2F;&#x2F; 使用基类的方法    &#125;&#125;;int main(int argc, char const *argv[])&#123;    B* b &#x3D; new B(3, 4);    b-&gt;info();    delete b;    return 0;&#125;A constructorB constructorB: 3, 4     &#x2F;&#x2F; 调用派生类的info()A: 3        &#x2F;&#x2F; 调用基类的info()B destructorA destructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="隐藏基类的方法"><a href="#隐藏基类的方法" class="headerlink" title="隐藏基类的方法"></a>隐藏基类的方法</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    void info() &#123;        cout &lt;&lt; &quot;A: &quot; &lt;&lt; this-&gt;x &lt;&lt; endl;    &#125;    void info(int val) &#123;        cout &lt;&lt; &quot;A: receive &quot; &lt;&lt; val &lt;&lt; endl;    &#125;&#125;;class B : public A &#123;public:    void info() &#123;        cout &lt;&lt; &quot;B: &quot; &lt;&lt; this-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; this-&gt;y &lt;&lt; endl;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    B* b &#x3D; new B(3, 4);    b-&gt;info(34);    &#x2F;&#x2F; error，B中没有实现info(int val)    delete b;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>派生类中实现了<code>info()</code>，他隐藏了基类<code>A::info()</code>的所有版本，编译器调用了派生类的<code>info()</code>，但他没有接受参数，也就会出错</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>在<code>main()</code>中使用作用域解析运算符<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">b-&gt;A::info(34);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在派生类中使用<code>using</code>关键字<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">using A::info;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>重载基类的所有info方法<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void info() &#123;    cout &lt;&lt; &quot;B: &quot; &lt;&lt; this-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; this-&gt;y &lt;&lt; endl;&#125;void info(int val) &#123;    cout &lt;&lt; &quot;B: receive &quot; &lt;&lt; val &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h2><p>公有继承派生类在继承结构层次外部可以使用基类的公有和保护成员，如<code>b-&gt;g()</code><br>私有继承则表示，基类的公有和保护成员，只能在派生类内部使用，<strong>外部无法访问</strong><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    virtual void f() &#x3D; 0;    void g() &#123; this-&gt;f(); &#125;&#125;;class B : private A &#123;public:    void f() &#123;        cout &lt;&lt; &quot;B: f(&quot; &lt;&lt; this-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; this-&gt;y &lt;&lt; &quot;)&quot; &lt;&lt; endl;    &#125;private:    int y;&#125;;int main(int argc, char const *argv[])&#123;    B* b &#x3D; new B(3, 4);    b-&gt;g();     &#x2F;&#x2F; error，私有继承不能访问基类的成员函数&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    virtual void f() &#x3D; 0;    void g() &#123; this-&gt;f(); &#125;&#125;;class B : public A &#123;public:    void f() &#123;        cout &lt;&lt; &quot;B: f(&quot; &lt;&lt; this-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; this-&gt;y &lt;&lt; &quot;)&quot; &lt;&lt; endl;    &#125;&#125;;class C : protected B &#123;    void func() &#123;        this-&gt;g();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C类想访问A类的成员方法，如果B对A是私有或保护继承，C类是无法访问A类的成员方法的<br>只有B类对A类是公有继承，C类才能访问A类的成员方法</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>如果是<code>is-a</code>关系，即属于关系，要用公有继承</li><li>如果是<code>has-a</code>关系，即拥有关系，要用私有或保护继承</li><li><code>public</code>的限制最小，可以被类成员函数、派生类成员函数、友元访问，类对象也可以访问</li><li><code>protected</code>有点限制，可以被类成员函数、派生类成员函数、友元访问，类对象不能访问</li><li><code>private</code>限制最大，可以被类成员函数、友元访问，派生类、类对象都不能访问</li></ol><h3 id="三个访问限定符的区别"><a href="#三个访问限定符的区别" class="headerlink" title="三个访问限定符的区别"></a>三个访问限定符的区别</h3><table>    <tr>        <th>类型</th>        <th>类成员函数</th>        <th>友元</th>        <th>派生类成员函数</th>        <th>类对象</th>    </tr>    <tr>        <th>public</th>        <th>yes</th>        <th>yes</th>        <th>yes</th>        <th>yes</th>    </tr>    <tr>        <th>protected</th>        <th>yes</th>        <th>yes</th>        <th>yes</th>        <th>no</th>    </tr>    <tr>        <th>privated</th>        <th>yes</th>        <th>yes</th>        <th>no</th>        <th>no</th>    </tr></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类/虚函数/虚继承</title>
      <link href="2021/04/17/C-%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>2021/04/17/C-%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="一、多态性"><a href="#一、多态性" class="headerlink" title="一、多态性"></a>一、多态性</h2><p>多态性：多态就是在同一个类或继承体系结构的基类与派生类中，用同名函数来实现各种不同的功能。</p><p><strong>静态绑定又称静态联编</strong>，是指在编译程序时就根据调用函数提供的信息，把它所对应的具体函数确定下来，即在编译时就把调用函数名与具体函数绑定在一起。 </p><p><strong>动态绑定又称动态联编</strong>，是指在编译程序时还不能确定函数调用所对应的具体函数，只有在程序运行过程中才能够确定函数调用所对应的具体函数，即在程序运行时才把调用函数名与具体函数绑定在一起。</p><p>编译时多态性：静态联编(连接)——系统在编译时就决定如何实现某一动作，即对某一消息如何处理。静态联编具有执行速度快的优点。在C++中的编译时多态性是通过函数重载和运算符重载实现的。<br>运行时多态性：动态联编(连接)——系统在运行时动态实现某一动作，即对某一消息在运行过程实现其如何响应。动态联编为系统提供了灵活和高度问题抽象的优点，在C++中的运行时多态性是通过继承和虚函数实现的。</p><h2 id="二、虚函数"><a href="#二、虚函数" class="headerlink" title="二、虚函数"></a>二、虚函数</h2><p>虚函数的意义</p><p>1、基类与派生类的赋值相容</p><ul><li>派生类对象可以赋值给基类对象。</li><li>派生类对象的地址可以赋值给指向基类对象的指针。</li><li>派生类对象可以作为基类对象的引用。</li></ul><p>赋值相容的问题：不论哪种赋值方式，都只能通过基类对象（或基类对象的指针或引用）访问到派生类对象从基类中继承到的成员， 不能借此访问派生类定义的成员。</p><p>2、虚函数使得可以通过基类对象的指针或引用访问派生类定义的成员。</p><p>3、<code>virtual</code>关键字其实质是告知编译系统，被指定为<code>virtual</code>的函数采用动态联编的形式编译。</p><p>4、虚函数的虚特征：基类指针指向派生类的对象时，通过该指针访问其虚函数将调用派生类的版本。</p><ul><li>一旦将某个成员函数声明为虚函数后，它在继承体系中就永远为虚函数了 </li><li>如果基类定义了虚函数，当通过基类指针或引用调用派生类对象时，将访问到它们实际所指对象中的虚函数版本。</li><li>只有通过基类对象的指针和引用访问派生类对象的虚函数时，才能体现虚函数的特性。</li><li>派生类中的虚函数要保持其虚特征，必须与基类虚函数的函数原型完全相同，否则就是普通的重载函数，与基类的虚函数无关。</li><li>派生类通过从基类继承的成员函数调用虚函数时，将访问到派生类中的版本。</li><li>只有类的非静态成员函数才能被定义为虚函数，类的构造函数和静态成员函数不能定义为虚函数。原因是虚函数在继承层次结构中才能够发生作用，而构造函数、静态成员是不能够被继承的。</li><li>内联函数也不能是虚函数。因为内联函数采用的是静态联编的方式，而虚函数是在程序运行时才与具体函数动态绑定的，采用的是动态联编的方式，即使虚函数在类体内被定义，C++编译器也将它视为非内联函数。</li></ul><p>5、基类析构函数几乎总是为虚析构函数。<br>假定使用<code>delete</code>和一个指向派生类的基类指针来销毁派生类对象，如果基类析构函数不为虚,就如一个普通成员函数，<code>delete</code>函数调用的就是基类析构函数。在通过基类对象的引用或指针调用派生类对象时，将致使对象析构不彻底！</p><h2 id="三、纯虚函数和抽象类"><a href="#三、纯虚函数和抽象类" class="headerlink" title="三、纯虚函数和抽象类"></a>三、纯虚函数和抽象类</h2><p>1、纯虚函数概念？</p><p>仅定义函数原型而不定义其实现的虚函数<br>实用角度：占位手段<code>place-holder</code><br>方法学：接口定义手段，抽象表达手段<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class X&#123;    virtual ret_type func_name (param) &#x3D; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br>2、抽象类概念？</p><p>包含一个或多个纯虚函数的类<br><strong>不能实例化抽象类</strong><br>但是可以定义抽象类的指针和引用</p><p>3、C++对抽象类具有以下限定</p><ul><li>抽象类中含有纯虚函数，由于纯虚函数没有实现代码，所以不能建立抽象类的对象。</li><li>抽象类只能作为其他类的基类，可以通过抽象类对象的指针或引用访问到它的派生类对象，实现运行时的多态性。</li><li>如果派生类只是简单地继承了抽象类的纯虚函数，而没有重新定义基类的纯虚函数，则派生类也是一个抽象类。</li></ul><h2 id="虚函数的用法"><a href="#虚函数的用法" class="headerlink" title="虚函数的用法"></a>虚函数的用法</h2><p>为什么要使用虚函数，因为我们希望基类指针如果指向派生类对象，调用的应该是派生类中的方法，如果不用虚函数，只用重载，那他将会调用基类的方法，所以需要虚函数<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;    virtual void info() &#123; cout &lt;&lt; &quot;A: info&quot; &lt;&lt; endl;&#125;&#125;;class B : public A &#123;public:    void info() &#123; cout &lt;&lt; &quot;B: info&quot; &lt;&lt; endl;&#125;&#125;;int main(int argc, char const *argv[])&#123;    A* b &#x3D; new B(3, 4);    b-&gt;info();    return 0;&#125;没有virtual时，调用基类方法:A: info加了virtual，调用派生类方法:B: info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>抽象类中含有虚函数，继承类中需要实现抽象类的所有虚函数<br>成员函数可以调用虚函数，构造函数和析构函数不能调用虚函数<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    virtual void f() &#x3D; 0;   &#x2F;&#x2F;纯虚函数    void g() &#123;        this-&gt;f();          &#x2F;&#x2F; 调用虚函数    &#125;&#125;;class B : public A &#123;public:    void f() &#123;      &#x2F;&#x2F; 派生类要实现虚函数        cout &lt;&lt; &quot;B: f()&quot; &lt;&lt; endl;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    A a;            &#x2F;&#x2F; error，不能创建抽象类对象    A* a &#x3D; new A;   &#x2F;&#x2F; error，不能创建抽象类指针对象    B* b &#x3D; new B;    b-&gt;g();         &#x2F;&#x2F;因为B对A是公有继承，所以可以使用A中的成员方法    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>虚函数是用虚函数表实现的，虚函数表由一系列函数指针组成，每个函数指针指向虚函数的实现<br>从下面的例子可以看出，<code>Base</code>含有2个<code>int</code>和一个虚函数(几个都一样)，<code>Derived</code>含有2个<code>int</code>，他们差了一个指针的大小(8)<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Base&#123;    int x, y;public:    virtual void doSomeThing() &#x3D; 0;&#125;;class Derived&#123;    int x, y;&#125;;int main(int argc, char const *argv[])&#123;    cout &lt;&lt; sizeof(int) &lt;&lt; endl;    cout &lt;&lt; sizeof(int*) &lt;&lt; endl;    cout &lt;&lt; sizeof(Base) &lt;&lt; endl;    cout &lt;&lt; sizeof(Derived) &lt;&lt; endl;    return 0;&#125;4   &#x2F;&#x2F; int占用4字节8   &#x2F;&#x2F; 指针占用8字节16  &#x2F;&#x2F; 2个int+1个虚函数指针8   &#x2F;&#x2F; 2个int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="抽象类构造函数"><a href="#抽象类构造函数" class="headerlink" title="抽象类构造函数"></a>抽象类构造函数</h2><p>构造函数不能是虚函数<br>可以用基类指针指向派生类对象<br><code>protected</code>允许派生类和友元类访问，但禁止在继承结构层次外部访问<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    A(int i) : x(i) &#123; cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; endl; &#125;    virtual void f() &#x3D; 0;    void g() &#123;        this-&gt;f();    &#125;protected:  &#x2F;&#x2F; 成员变量声明为protected，可以在派生类和友元类中访问    int x;&#125;;class B : public A &#123;public:    B(int i, int j) : A(i), y(j) &#123; cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; endl; &#125;    void f() &#123;        cout &lt;&lt; &quot;B: f(&quot; &lt;&lt; this-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; this-&gt;y &lt;&lt; &quot;)&quot; &lt;&lt; endl;    &#125;private:    int y;&#125;;int main(int argc, char const *argv[])&#123;    A* b &#x3D; new B(3, 4); &#x2F;&#x2F;基类指针指向派生类对象    b-&gt;g();    return 0;&#125;A constructorB constructorB: f(3, 4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>可以看到先调用了<code>A</code>的构造函数，后调用了<code>B</code>的构造函数</p><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    virtual ~A() &#123; cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; endl; &#125;&#125;;class B : public A &#123;public:    ~B() &#123; cout &lt;&lt; &quot;B destructor&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[])&#123;    A* b &#x3D; new B(3, 4);    b-&gt;g();    delete b;    return 0;&#125;析构函数没有加virtual时：A constructorB constructorB: f(3, 4)A destructor析构函数加virtual时：A constructorB constructorB: f(3, 4)B destructor    &#x2F;&#x2F; 先调用了派生类的析构函数A destructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用基类指针指向派生类对象时，如果基类的析构函数没有声明为<code>virtual</code>，销毁对象时就只会调用<strong>基类</strong>的析构函数，这样会造成内存泄漏<br>所以把基类的析构函数声明为<code>virtual</code>，销毁对象时就会先调用<strong>派生类</strong>的析构函数，再调用<strong>基类</strong>的析构函数</p><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>为了解决菱形问题，一个基类有多个派生类，这些派生类又被一个类继承<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    int x;    A() &#123; cout &lt;&lt; &quot;A: constructor&quot; &lt;&lt; endl; &#125;&#125;;class B : public A &#123;&#125;;class B1 : public A &#123;&#125;;class C : public B, public B1 &#123;public:    C() &#123; cout &lt;&lt; &quot;C: constructor&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[])&#123;    C c;    c.x &#x3D; 10;   &#x2F;&#x2F; error，发生混淆，不知道是谁的x    return 0;&#125;A: constructor  &#x2F;&#x2F; 调用了两次基类的构造函数A: constructorC: constructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>解决方法：基类的多个派生类使用<strong>虚继承</strong>，确保只有<strong>一个基类实例</strong><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    int x;    A() &#123; cout &lt;&lt; &quot;A: constructor&quot; &lt;&lt; endl; &#125;&#125;;class B : public virtual A &#123;&#125;;class B1 : public virtual A &#123;&#125;;class C : public B, public B1 &#123;public:    C() &#123; cout &lt;&lt; &quot;C: constructor&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[])&#123;    C c;    c.x &#x3D; 10;   &#x2F;&#x2F; yes    return 0;&#125;A: constructor  &#x2F;&#x2F; 只调用了一次基类的构造函数C: constructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static关键字</title>
      <link href="2021/04/17/C-static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2021/04/17/C-static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="函数中使用static"><a href="#函数中使用static" class="headerlink" title="函数中使用static"></a>函数中使用static</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; void demo() &#123;     static int count &#x3D; 0;     cout &lt;&lt; count &lt;&lt; &quot; &quot;;     count++; &#125; int main() &#123;     for (int i &#x3D; 0; i &lt; 5; i++)        demo();     return 0; &#125;0 1 2 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<code>count</code>在不断累加，<code>static</code>变量的空间只分配一次，每次调用之后不会再进行初始化</p><h2 id="类中使用static"><a href="#类中使用static" class="headerlink" title="类中使用static"></a>类中使用static</h2><ul><li>类中的<code>static</code>变量只能声明，定义要放在类外面</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Human&#123;public:    static int ip;  &#x2F;&#x2F; 类中声明static变量private:    string _name;    int _age;&#125;;int Human::ip &#x3D; 0;  &#x2F;&#x2F; 类外定义static变量int main(int argc, char const *argv[])&#123;    Human kavin(&quot;kavin&quot;, 23);    cout &lt;&lt; kavin.ip &lt;&lt; endl;    kavin.ip &#x3D; 10;    Human* jack &#x3D; new Human(&quot;jack&quot;, 12);    jack-&gt;ip &#x3D; 30;    cout &lt;&lt; kavin.ip &lt;&lt; endl;    return 0;&#125;030<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到不同对象都可以对<code>static</code>变量进行修改，他们是共享的</p><h2 id="静态变量需要初值"><a href="#静态变量需要初值" class="headerlink" title="静态变量需要初值"></a>静态变量需要初值</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;    static const int num &#x3D; 5;    或者 enum &#123; num &#x3D; 5 &#125;;    int arr[num];&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里数组必须知道大小，所以就必须在给<code>num</code>赋初值<br>也可以用<code>enum</code></p><h2 id="静态对象"><a href="#静态对象" class="headerlink" title="静态对象"></a>静态对象</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    int x &#x3D; 1;    if (x &#x3D;&#x3D; 1) &#123;        int num1 &#x3D; 100;        Human kavin(&quot;kavin&quot;, 23, num1);    &#125;    cout &lt;&lt; &quot;main function end&quot; &lt;&lt; endl;    return 0;&#125;Destructor: delete ptrmain function end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为<code>kavin</code>对象的生命周期在if语句结束之后就没了，所以就会调用析构函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    int x &#x3D; 1;    if (x &#x3D;&#x3D; 1) &#123;        int num1 &#x3D; 100;        static Human kavin(&quot;kavin&quot;, 23, num1);    &#125;    cout &lt;&lt; &quot;main function end&quot; &lt;&lt; endl;    return 0;&#125;main function endDestructor: delete ptr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静态对象的声明周期贯穿整个程序，所以在程序结束之后才会调用析构函数</p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>类中的静态成员函数只能使用类中的静态成员变量和成员函数<br>建议使用类名和范围解析运算符调用静态成员函数<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Human&#123;public:    static int ip;    static void info();&#125;;int Human::ip &#x3D; 0;void Human::info() &#123;    cout &lt;&lt; ip &lt;&lt; endl;    &#x2F;&#x2F; Introduce();    &#x2F;&#x2F;error，不能调用非静态成员函数&#125;int main(int argc, char const *argv[])&#123;    Human kavin(&quot;kavin&quot;, 23);    kavin.ip &#x3D; 10;    Human::info();    return 0;&#125;10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拷贝构造函数</title>
      <link href="2021/04/16/C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>2021/04/16/C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Human&#123;public:    Human(string name, int age, const int&amp; val);    ~Human();private:    string _name;    int _age;    int* _ptr &#x3D; nullptr;&#125;;Human::Human(string name, int age, const int&amp; val) &#123;    this-&gt;_name &#x3D; name;    this-&gt;_age &#x3D; age;    if (&amp;val !&#x3D; nullptr) &#123;        this-&gt;_ptr &#x3D; new int;        *this-&gt;_ptr &#x3D; val;    &#125;    else        this-&gt;_ptr &#x3D; nullptr;&#125;Human::~Human() &#123;    if (this-&gt;_ptr !&#x3D; nullptr) &#123;        cout &lt;&lt; &quot;delete ptr&quot; &lt;&lt; endl;        delete this-&gt;_ptr;    &#125;&#125;int main(int argc, char const *argv[])&#123;    int num1 &#x3D; 100;    Human kavin(&quot;kavin&quot;, 23, num1);    kavin.setAge(34);    kavin.Introduce();    return 0;&#125;I&#39;m kavin, and I&#39;m 34 years old.delete ptr  &#x2F;&#x2F; 调用了析构函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类成员变量里有指针，程序结束时应该要释放，所以需要重载析构函数，类里面只有一个析构函数。</p><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Human&#123;&#x2F;&#x2F; 拷贝构造函数Human::Human(const Human&amp; copySource) &#123;    this-&gt;_name &#x3D; copySource._name;    this-&gt;_age &#x3D; copySource._age;    cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl;    if (copySource._ptr !&#x3D; nullptr) &#123;        this-&gt;_ptr &#x3D; new int;        *this-&gt;_ptr &#x3D; *copySource._ptr;    &#125;    else         this-&gt;_ptr &#x3D; nullptr;&#125;void UseHuman(Human input) &#123;    input.Introduce();&#125;int main(int argc, char const *argv[])&#123;    int num1 &#x3D; 100;    Human kavin(&quot;kavin&quot;, 23, num1);    kavin.setAge(34);    kavin.Introduce();    UseHuman(kavin);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有拷贝构造函数，在<code>UseHuman</code>函数完成之后，类中的指针所指的空间就会被释放，而在<code>main</code>函数结束时，又会调用析构函数释放内存，这样就会发生错误。<br>原因在于，传递参数时是浅复制，没有对指针所指内容进行复制，导致两个指针指向同一个地方，所以拷贝构造函数就需要对指针所指内容进行复制。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类/友元</title>
      <link href="2021/04/16/C-C-%E7%B1%BB/"/>
      <url>2021/04/16/C-C-%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="一个简单的Human类"><a href="#一个简单的Human类" class="headerlink" title="一个简单的Human类"></a>一个简单的Human类</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Human&#123;public:    Human();    &#x2F;&#x2F; 默认构造函数    Human(string name, int age);    &#x2F;&#x2F; 重载构造函数    void setName(string name);    void setAge(int age);    string getName();    int getAge();    void Introduce();private:    string _name;    int _age;    string _gender;&#125;;&#x2F;&#x2F; 重载构造函数Human::Human(string name, int age) &#123;    this-&gt;_name &#x3D; name;    this-&gt;_age &#x3D; age;&#125;void Human::setName(string name) &#123;    this-&gt;_name &#x3D; name;&#125;void Human::setAge(int age) &#123;    this-&gt;_age &#x3D; age;&#125;string Human::getName() &#123;    return this-&gt;_name;&#125;int Human::getAge() &#123;    return this-&gt;_age;&#125;void Human::Introduce() &#123;    cout &lt;&lt; &quot;I&#39;m &quot; &lt;&lt; this-&gt;getName() &lt;&lt; &quot;, and I&#39;m &quot; &lt;&lt; this-&gt;getAge() &lt;&lt; &quot; years old.&quot; &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    Human kavin(&quot;kavin&quot;, 23);    kavin.setAge(34);    kavin.Introduce();    Human* jack &#x3D; new Human(&quot;jack&quot;, 12);    jack-&gt;Introduce();    return 0;&#125;I&#39;m kavin, and I&#39;m 34 years old.I&#39;m jack, and I&#39;m 12 years old.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>声明友元函数或友元类，就可以访问类里面的私有变量<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Human&#123;public:    friend void disp(const Human&amp; person);&#125;;void disp(const Human&amp; person) &#123;    cout &lt;&lt; person._age &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    Human kavin(&quot;kavin&quot;, 23);    disp(kavin);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Human&#123;public:    friend class Boys;&#125;;class Boys&#123;public:    static void dispName(const Human&amp; person) &#123;        cout &lt;&lt; person._name &lt;&lt; endl;   &#x2F;&#x2F;可以使用类里面的私有变量    &#125;&#125;;int main(int argc, char const *argv[])&#123;    Human kavin(&quot;kavin&quot;, 23);    Boys::dispName(kavin);    return 0;&#125;kavin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="一个简单的Circle类"><a href="#一个简单的Circle类" class="headerlink" title="一个简单的Circle类"></a>一个简单的Circle类</h2><p><code>pi</code>是一个常量<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Circle&#123;public:    Circle(int radius) : _radius(radius) &#123;        this-&gt;_perimeter &#x3D; 2 * this-&gt;pi * this-&gt;_radius;        this-&gt;_area &#x3D; this-&gt;pi * this-&gt;_radius * this-&gt;_radius;    &#125;    void info();private:    int _radius;    double _perimeter;    double _area;    const double pi &#x3D; 3.14159;&#125;;void Circle::info() &#123;    cout &lt;&lt; this-&gt;_perimeter &lt;&lt; endl;    cout &lt;&lt; this-&gt;_area &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    Circle first(6);    first.info();    return 0;&#125;37.6991113.097<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><p>如果要声明为<code>static</code>，要在类外面定义<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Circle&#123;    static const double pi;         &#x2F;&#x2F;类里面声明&#125;;const double Circle::pi &#x3D; 3.14159;  &#x2F;&#x2F;类外面定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake</title>
      <link href="2021/04/16/C-cmake/"/>
      <url>2021/04/16/C-cmake/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="CMake变量"><a href="#CMake变量" class="headerlink" title="CMake变量"></a>CMake变量</h2><p><strong><code>CMAKE_CURRENT_SOURCE_DIR</code></strong></p><ul><li>指的是当前处理的<code>CMakeLists.txt</code>所在的路径。</li></ul><p><strong><code>CMAKE_CURRRENT_BINARY_DIR</code></strong></p><ul><li>如果是<code>in-source</code>编译，它跟<code>CMAKE_CURRENT_SOURCE_DIR</code>一致，如果是<code>out-ofsource</code>编译，他指的是<code>target</code>编译目录。</li></ul><p><strong><code>CMAKE_CURRENT_LIST_FILE</code></strong></p><ul><li>输出调用这个变量的<code>CMakeLists.txt</code>的完整路径</li></ul><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p><img src="/2021/04/16/C-cmake/CMake.png" alt></p><h3 id="Solider目录的CMakeLists-txt"><a href="#Solider目录的CMakeLists-txt" class="headerlink" title="Solider目录的CMakeLists.txt"></a>Solider目录的CMakeLists.txt</h3><pre class="line-numbers language-py" data-language="py"><code class="language-py">aux_source_directory(. SRC_LIST)# 将此目录的源文件集合称为变量SRC_LISTmessage($&#123;SRC_LIST&#125;)include_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)# 头文件目录add_library(Solider_shared SHARED $&#123;SRC_LIST&#125;)# 库的名称，类型，源文件（动态库）add_library(Solider_static STATIC $&#123;SRC_LIST&#125;)# 静态库set_target_properties(Solider_shared PROPERTIES OUTPUT_NAME &quot;Solider&quot;)# 库的名称，库的输出名称（动态库）set_target_properties(Solider_static PROPERTIES OUTPUT_NAME &quot;Solider&quot;)# 静态库set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;lib)# 库文件输出到工作空间的lib目录下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="工作空间的CMakeLists-txt-生成库文件"><a href="#工作空间的CMakeLists-txt-生成库文件" class="headerlink" title="工作空间的CMakeLists.txt (生成库文件)"></a>工作空间的CMakeLists.txt (生成库文件)</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cmake_minimum_required(VERSION 3.0)project(MAIN)&#x2F;&#x2F; message($&#123;MAIN_BINARY_DIR&#125;)&#x2F;&#x2F; message($&#123;PROJECT_BINARY_DIR&#125;)&#x2F;&#x2F; message($&#123;CMAKE_BINARY_DIR&#125;)&#x2F;&#x2F; 如果是out-of-source编译，指的是工程编译发生的目录 &#x2F;&#x2F; &#x2F;home&#x2F;kavin&#x2F;algorithm&#x2F;VSCode&#x2F;test05&#x2F;build&#x2F;&#x2F; message($&#123;MAIN_SOURCE_DIR&#125;)&#x2F;&#x2F; message($&#123;PROJECT_SOURCE_DIR&#125;)&#x2F;&#x2F; message($&#123;CMAKE_SOURCE_DIR&#125;)&#x2F;&#x2F; 这三个变量指代的内容是一致的，是工程顶层目录 &#x2F;&#x2F; &#x2F;home&#x2F;kavin&#x2F;algorithm&#x2F;VSCode&#x2F;test05&#x2F;&#x2F; 为了生成库文件，完成之后面再把这句注释掉&#x2F;&#x2F; 会进入Solider目录执行里里面的工作空间的CMakeLists.txtadd_subdirectory(Solider)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="工作空间的CMakeLists-txt-编译源文件"><a href="#工作空间的CMakeLists-txt-编译源文件" class="headerlink" title="工作空间的CMakeLists.txt (编译源文件)"></a>工作空间的CMakeLists.txt (编译源文件)</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cmake_minimum_required(VERSION 3.0)project(MAIN)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125;&quot;)set(CMAKE_BUILD_TYPE Debug)     &#x2F;&#x2F; 要启用F5调试一定要用这一条&#x2F;&#x2F; 头文件目录include_directories($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;include)&#x2F;&#x2F; 库文件目录link_directories(lib)&#x2F;&#x2F; 生成可执行文件add_executable(main main.cpp)&#x2F;&#x2F; 链接库(静态库)target_link_libraries(main libSolider.a)&#x2F;&#x2F; 如果是动态库要记得添加环境变量 LD_LIBRARY_PATH&#x3D;lib&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++引用</title>
      <link href="2021/04/16/C-%E5%BC%95%E7%94%A8/"/>
      <url>2021/04/16/C-%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="什么叫引用"><a href="#什么叫引用" class="headerlink" title="什么叫引用"></a>什么叫引用</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[]) &#123;    int original &#x3D; 30;    cout &lt;&lt; &quot;address of original: &quot; &lt;&lt; hex &lt;&lt; &amp;original &lt;&lt; endl;        &#x2F;&#x2F; 定义一个ref引用original    int&amp; ref &#x3D; original;    cout &lt;&lt; &quot;address of ref: &quot; &lt;&lt; hex &lt;&lt; &amp;ref &lt;&lt; endl;    cout &lt;&lt; dec &lt;&lt; ref &lt;&lt; endl;    return 0;&#125;address of original: 0x7ffc14a1acfcaddress of ref: 0x7ffc14a1acfc30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<code>original</code>和<code>ref</code>的地址和数值都是一样的，所以引用就相当于起了个别名，注意与指针区别</p><h2 id="引用有什么用"><a href="#引用有什么用" class="headerlink" title="引用有什么用"></a>引用有什么用</h2><p>函数在传参数的时候，如果是按值传递，将会对变量进行复制，如果变量很大，就会消耗很多的时间和内存，所以使用引用可以对变量本身直接继续修改<br><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;void DoSomeThing(int&amp; val) &#123;    cout &lt;&lt; &quot;address of val: &quot; &lt;&lt; hex &lt;&lt; &amp;val &lt;&lt; endl;    val +&#x3D; 100; &#x2F;&#x2F; 对变量值进行增加操作&#125;int main(int argc, char const *argv[])&#123;    int original &#x3D; 30;    cout &lt;&lt; &quot;address of original: &quot; &lt;&lt; hex &lt;&lt; &amp;original &lt;&lt; endl;    int&amp; ref &#x3D; original;    cout &lt;&lt; &quot;address of ref: &quot; &lt;&lt; hex &lt;&lt; &amp;ref &lt;&lt; endl;    cout &lt;&lt; dec &lt;&lt; ref &lt;&lt; endl;    DoSomeThing(ref);    cout &lt;&lt; dec &lt;&lt; original &lt;&lt; endl;    return 0;&#125;address of original: 0x7ffc14a1acfcaddress of ref: 0x7ffc14a1acfc30address of val: 0x7ffc14a1acfc130 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>可以看到最初的变量<code>original</code>的值发生了变化，按引用传递的形参的地址还是和原来一样的</p><h2 id="加个const"><a href="#加个const" class="headerlink" title="加个const"></a>加个const</h2><p>有时候我们希望函数只能使用传递的参数，不能修改他，就需要加个<code>const</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int&amp; ref2 &#x3D; ref;int num &#x3D; 10;ref2 &#x3D; num; &#x2F;&#x2F; 报错，ref2是只读参数，不能作为左值ref2 &#x3D; 100; &#x2F;&#x2F; 报错，ref2是只读参数，不能作为左值void DoSomeThing(const int&amp; val) &#123;    cout &lt;&lt; &quot;address of val: &quot; &lt;&lt; hex &lt;&lt; &amp;val &lt;&lt; endl;    val +&#x3D; 100; &#x2F;&#x2F; 报错，ref2是只读参数，不能作为左值&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不能修改的加个<code>const</code>，需要修改的就不用加<code>const</code>，可以像下面这样写</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void DoSomeThing(const int&amp; val, int&amp; res) &#123;    res &#x3D; val * val;&#125;int main(int argc, char const *argv[])&#123;    int original &#x3D; 30;    int res &#x3D; 0;    DoSomeThing(original, res);    cout &lt;&lt; original &lt;&lt; endl;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;30  &#x2F;&#x2F;const引用的值没有被改变900 &#x2F;&#x2F;没有const的值被修改了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-两数相加</title>
      <link href="2021/04/16/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>2021/04/16/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-2-Add-Two-Numbers"><a href="#LeetCode-2-Add-Two-Numbers" class="headerlink" title="LeetCode 2. Add Two Numbers"></a>LeetCode 2. Add Two Numbers</h2><p><a href="https://leetcode.com/problems/add-two-numbers/submissions/">LeetCode</a></p><p>You are given two non-empty linked lists representing two <code>non-negative</code> integers. The digits are stored in <code>reverse order</code>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Example 1:</p><p><img src="/2021/04/16/LeetCode-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/2.jpg" alt></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Input: l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]Output: [7,0,8]Explanation: 342 + 465 &#x3D; 807.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;    ListNode dummy(0);    ListNode *head &#x3D; &amp;dummy;    int cnt &#x3D; 0;    while (l1 &amp;&amp; l2) &#123;        int tmp &#x3D; l1-&gt;val + l2-&gt;val + cnt;        cnt &#x3D; tmp &#x2F; 10;        tmp %&#x3D; 10;        head-&gt;next &#x3D; new ListNode(tmp);        head &#x3D; head-&gt;next;        l1 &#x3D; l1-&gt;next;        l2 &#x3D; l2-&gt;next;    &#125;    while (l1) &#123;    &#x2F;&#x2F; 如果l1还有数        int tmp &#x3D; l1-&gt;val + cnt;        cnt &#x3D; tmp &#x2F; 10;        tmp %&#x3D; 10;        head-&gt;next &#x3D; new ListNode(tmp);        head &#x3D; head-&gt;next;        l1 &#x3D; l1-&gt;next;    &#125;    while (l2) &#123;    &#x2F;&#x2F; 如果l2还有数        int tmp &#x3D; l2-&gt;val + cnt;        cnt &#x3D; tmp &#x2F; 10;        tmp %&#x3D; 10;        head-&gt;next &#x3D; new ListNode(tmp);        head &#x3D; head-&gt;next;        l2 &#x3D; l2-&gt;next;    &#125;    if (cnt) &#123;  &#x2F;&#x2F; 如果还有进位要加上        head-&gt;next &#x3D; new ListNode(cnt);        head &#x3D; head-&gt;next;    &#125;    return dummy.next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="可以简化一下"><a href="#可以简化一下" class="headerlink" title="可以简化一下"></a>可以简化一下</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;    ListNode *head &#x3D; new ListNode(0);    ListNode *dummy &#x3D; head;    int carry &#x3D; 0;    while (l1 || l2 || carry) &#123;        int add1 &#x3D; l1 ? l1-&gt;val : 0;        int add2 &#x3D; l2 ? l2-&gt;val : 0;        int sum &#x3D; add1 + add2 + carry;        head-&gt;next &#x3D; new ListNode(sum % 10);        carry &#x3D; sum &#x2F; 10;        head &#x3D; head-&gt;next;        if (l1) l1 &#x3D; l1-&gt;next;        if (l2) l2 &#x3D; l2-&gt;next;    &#125;    return dummy-&gt;next;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV_shadow</title>
      <link href="2021/04/13/OpenCV-OpenCV-shadow/"/>
      <url>2021/04/13/OpenCV-OpenCV-shadow/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="创建Mat"><a href="#创建Mat" class="headerlink" title="创建Mat"></a>创建Mat</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 5行3列随机值Mat img &#x3D; Mat(5, 3, CV_8UC3);randu(img, Scalar::all(0), Scalar::all(255));&#x2F;&#x2F; 2行2列固定值Mat img1(Size(2, 2), CV_8UC3, Scalar(0, 0, 255));&#x2F;&#x2F; create()函数Mat img2;img2.create(Size(4, 4), CV_8UC3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输出Mat"><a href="#输出Mat" class="headerlink" title="输出Mat"></a>输出Mat</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout &lt;&lt; img &lt;&lt; endl;cout &lt;&lt; format(img, Formatter::FMT_PYTHON) &lt;&lt; endl;cout &lt;&lt; format(img, Formatter::FMT_NUMPY) &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="获取行数和列数"><a href="#获取行数和列数" class="headerlink" title="获取行数和列数"></a>获取行数和列数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">行数: src.rows列数: src.cols<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="形态学"><a href="#形态学" class="headerlink" title="形态学"></a>形态学</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 创建核Mat kernal &#x3D; getStructuringElement(MORPH_RECT, Size(15, 15));Mat img_dilate, img_erosion;&#x2F;&#x2F; 膨胀dilate(gray, img_dilate, kernal);&#x2F;&#x2F; 腐蚀erode(img_dilate, img_erosion, kernal);&#x2F;&#x2F; 开闭运算 礼帽 黑帽morphologyEx(gray, dst_open, MORPH_TOPHAT, kernal);MORPH_OPEN: 先腐蚀后膨胀MORPH_CLOSE: 先膨胀后腐蚀MORPH_TOPHAT: 原图与开运算之差MORPH_BLACKHAT: 闭运算与原图之差<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;using namespace std;int main(int artc, char** argv) &#123;    Mat img &#x3D; Mat(5, 3, CV_8UC3);    randu(img, Scalar::all(0), Scalar::all(255));    cout &lt;&lt; img &lt;&lt; endl;    &#x2F;&#x2F; [ 91,   2,  79, 179,  52, 205, 236,   8, 181;    &#x2F;&#x2F; 239,  26, 248, 207, 218,  45, 183, 158, 101;    &#x2F;&#x2F; 102,  18, 118,  68, 210, 139, 198, 207, 211;    &#x2F;&#x2F; 181, 162, 197, 191, 196,  40,   7, 243, 230;    &#x2F;&#x2F; 45,   6,  48, 173, 242, 125, 175,  90,  63]    cout &lt;&lt; &quot;python:&quot; &lt;&lt; endl;    cout &lt;&lt; format(img, Formatter::FMT_PYTHON) &lt;&lt; endl;    &#x2F;&#x2F; python:    &#x2F;&#x2F; [[[ 91,   2,  79], [179,  52, 205], [236,   8, 181]],    &#x2F;&#x2F;  [[239,  26, 248], [207, 218,  45], [183, 158, 101]],    &#x2F;&#x2F;  [[102,  18, 118], [ 68, 210, 139], [198, 207, 211]],    &#x2F;&#x2F;  [[181, 162, 197], [191, 196,  40], [  7, 243, 230]],    &#x2F;&#x2F;  [[ 45,   6,  48], [173, 242, 125], [175,  90,  63]]]    cout &lt;&lt; &quot;numpy:&quot; &lt;&lt; endl;    cout &lt;&lt; format(img, Formatter::FMT_NUMPY) &lt;&lt; endl;    &#x2F;&#x2F; numpy:    &#x2F;&#x2F; array([[[ 91,   2,  79], [179,  52, 205], [236,   8, 181]],    &#x2F;&#x2F;        [[239,  26, 248], [207, 218,  45], [183, 158, 101]],    &#x2F;&#x2F;        [[102,  18, 118], [ 68, 210, 139], [198, 207, 211]],    &#x2F;&#x2F;        [[181, 162, 197], [191, 196,  40], [  7, 243, 230]],    &#x2F;&#x2F;        [[ 45,   6,  48], [173, 242, 125], [175,  90,  63]]], dtype&#x3D;&#39;uint8&#39;)    Mat img1(Size(2, 2), CV_8UC3, Scalar(0, 0, 255));    cout &lt;&lt; format(img1, Formatter::FMT_PYTHON) &lt;&lt; endl;    &#x2F;&#x2F; [[[  0,   0, 255], [  0,   0, 255]],    &#x2F;&#x2F;  [[  0,   0, 255], [  0,   0, 255]]]    Mat img2;    img2.create(Size(4, 4), CV_8UC3);    cout &lt;&lt; format(img2, Formatter::FMT_PYTHON) &lt;&lt; endl;    &#x2F;&#x2F; [[[  0,   0,   0], [  0,   0,   0], [  0,   0,   0], [  0,   0,   0]],    &#x2F;&#x2F;  [[  0,   0,   0], [  0,   0,   0], [  0,   0,   0], [  0,   0,   0]],    &#x2F;&#x2F;  [[  0,   0,   0], [  0,   0,   0], [  0,   0,   0], [  0,   0,   0]],    &#x2F;&#x2F;  [[  0,   0,   0], [  0,   0,   0], [  0,   0,   0], [  0,   0,   0]]]    Mat src &#x3D; imread(&quot;&#x2F;homevin&#x2F;Picturesadow.png&quot;, IMREAD_COLOR);    if (src.empty()) &#123;        cout &lt;&lt; &quot;can&#39;t find picture&quot; &lt;&lt; endl;        return -1;    &#125;    cout &lt;&lt; src.rows &lt;&lt; endl;    cout &lt;&lt; src.cols &lt;&lt; endl;    Mat gray;    cvtColor(src, gray, COLOR_BGR2GRAY);    Mat kernal &#x3D; getStructuringElement(MORPH_RECT, Size(15, 15));    Mat img_dilate, img_erosion;    &#x2F;&#x2F;Mat dst_open, dst_theshould;    &#x2F;&#x2F; erode(gray, dst, kernal);    dilate(gray, img_dilate, kernal);    erode(img_dilate, img_erosion, kernal);    Mat img_diff &#x3D; img_erosion - gray;    img_diff &#x3D; 255 - img_diff;    Mat img_norm;    normalize(img_diff, img_norm, 0, 255, NORM_MINMAX);    &#x2F;&#x2F;morphologyEx(gray, dst_open, MORPH_TOPHAT, kernal);    &#x2F;&#x2F;threshold(dst_open, dst_theshould, 110, 255, THRESH_BINARY);    &#x2F;&#x2F; namedWindow(&quot;src&quot;);    &#x2F;&#x2F; imshow(&quot;src&quot;, img_diff);    waitKey(0);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/13/OpenCV-OpenCV-shadow/init.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">原图</div></center><center><img src="/2021/04/13/OpenCV-OpenCV-shadow/shadow.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">去阴影</div></center><h2 id="Trackbar找阈值"><a href="#Trackbar找阈值" class="headerlink" title="Trackbar找阈值"></a>Trackbar找阈值</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;using namespace std;string winName &#x3D; &quot;threshould&quot;;Mat src, gray;int g_ThreshouldValue &#x3D; 100;&#x2F;&#x2F; 回调函数void on_Threshould(int ,void* )&#123;    threshold(gray, dst, g_ThreshouldValue, 255, THRESH_BINARY);    imshow(winName, dst);&#125;int main(int artc, char** argv) &#123;    src &#x3D; imread(&quot;&#x2F;home&#x2F;kavin&#x2F;Pictures&#x2F;panels&#x2F;panels_2&#x2F;dst_1.png&quot;, IMREAD_COLOR);    Mat dst &#x3D; src.clone();    if (src.empty()) &#123;        cout &lt;&lt; &quot;can&#39;t find picture&quot; &lt;&lt; endl;        return -1;    &#125;    Mat blur;    GaussianBlur(src, blur, Size(3, 3), 0, 0);    cvtColor(blur, gray, COLOR_BGR2GRAY);    namedWindow(winName, WINDOW_NORMAL);    &#x2F;&#x2F;创建trackbar，确定二值化的阈值    createTrackbar(&quot;threshould&quot;, winName, &amp;g_ThreshouldValue, 255, on_Threshould);    on_Threshould(0, 0);    while (1)    &#123;        int key;        key &#x3D; waitKey(20);        if (char(key) &#x3D;&#x3D; 27) break;    &#125;    &#x2F;&#x2F; threshold(gray, dst, 135, 255, THRESH_BINARY);    waitKey(0);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="提取矩形"><a href="#提取矩形" class="headerlink" title="提取矩形"></a>提取矩形</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;using namespace std;string winName &#x3D; &quot;threshould&quot;;Mat src, gray;int main(int artc, char** argv) &#123;    src &#x3D; imread(&quot;&#x2F;home&#x2F;kavin&#x2F;Pictures&#x2F;panels&#x2F;panels_2&#x2F;dst_1.png&quot;, IMREAD_COLOR);    Mat dst &#x3D; src.clone();    if (src.empty()) &#123;        cout &lt;&lt; &quot;can&#39;t find picture&quot; &lt;&lt; endl;        return -1;    &#125;    Mat blur;    GaussianBlur(src, blur, Size(3, 3), 0, 0);    cvtColor(blur, gray, COLOR_BGR2GRAY);    namedWindow(winName, WINDOW_NORMAL);        gray &#x3D; gray &gt; 130;    Mat kernal &#x3D; getStructuringElement(MORPH_RECT, Size(12, 12));    Mat img_dilate, img_erosion;    Mat dstImage &#x3D; Mat::zeros(src.size(), CV_8U);    dilate(gray, img_dilate, kernal);    &#x2F;&#x2F; imshow(&quot;dilate&quot;, img_dilate);    vector&lt;vector&lt;Point&gt; &gt; contours;    &#x2F;&#x2F; 存储轮廓点    vector&lt;Vec4i&gt; hierarchy;    findContours(img_dilate, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE);    vector&lt;Rect&gt; panelsRect;    &#x2F;&#x2F; drawContours(src, contours, -1, Scalar(255, 0, 255), 3);    &#x2F;&#x2F; 画出符合条件的轮廓，并生成矩形    for (int i &#x3D; 0; i &lt; contours.size(); i++) &#123;        if (arcLength(contours[i], true) &gt;&#x3D; 450 &amp;&amp; arcLength(contours[i], true) &lt;&#x3D; 500) &#123;            drawContours(src, contours, i, Scalar(255, 0, 255), 2);            Rect boundRect &#x3D; boundingRect(Mat(contours[i]));            rectangle(src, boundRect.tl(), boundRect.br(), Scalar(0, 255, 0), 2);            panelsRect.push_back(boundRect);        &#125;    &#125;    cout &lt;&lt; panelsRect.size() &lt;&lt; endl;        Mat panel;    for (int i &#x3D; 0; i &lt; 2; i++) &#123;        dst(panelsRect[i]).copyTo(panel);        imshow(&quot;panel_&quot; + to_string(i), panel);    &#125;    imshow(winName, src);    waitKey(0);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/13/OpenCV-OpenCV-shadow/panel.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">原图</div></center>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV_mask/transform</title>
      <link href="2021/04/12/OpenCV-OpenCV-mask/"/>
      <url>2021/04/12/OpenCV-OpenCV-mask/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="颜色分割"><a href="#颜色分割" class="headerlink" title="颜色分割"></a>颜色分割</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2 as cvimport numpy as npsrc &#x3D; cv.imread(&quot;.&#x2F;bird.png&quot;)blur &#x3D; cv.blur(src, (5, 5))     # 滤波blur0 &#x3D; cv.medianBlur(blur, 5)blur1 &#x3D; cv.GaussianBlur(blur0, (5, 5), 0)blur2 &#x3D; cv.bilateralFilter(blur1, 9, 75, 75)hsv &#x3D; cv.cvtColor(blur2, cv.COLOR_BGR2HSV)  # 转换颜色空间low_blue &#x3D; np.array([55, 0, 0])high_blue &#x3D; np.array([118, 255, 255])mask &#x3D; cv.inRange(hsv, low_blue, high_blue)res &#x3D; cv.bitwise_and(src, src, mask&#x3D;mask)cv.imwrite(&#39;bird_1.png&#39;, res)cv.namedWindow(&quot;input&quot;, cv.WINDOW_AUTOSIZE)cv.imshow(&quot;input&quot;, res)cv.waitKey(0)cv.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/bird.png#pic_center" width="80%" height="80%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">原始图像</div></center><center><img src="/2021/04/12/OpenCV-OpenCV-mask/bird_1.png#pic_center" width="80%" height="80%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">分割图像</div></center><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport cv2 as cvimport matplotlib.pyplot as pltimg &#x3D; cv.imread(&#39;1.png&#39;)print(img.shape)rows, cols &#x3D; img.shape[:2]print(rows)print(cols)pts1 &#x3D; np.float32([[50, 50], [200, 50], [50, 200]])pts2 &#x3D; np.float32([[100, 100], [200, 50], [100, 250]])M &#x3D; cv.getAffineTransform(pts1, pts2)dst &#x3D; cv.warpAffine(img, M, (cols, rows))fig, axes &#x3D; plt.subplots(nrows&#x3D;1, ncols&#x3D;2, figsize&#x3D;(10, 8), dpi&#x3D;100)axes[0].imshow(img[:, :, ::-1])axes[0].set_title(&#39;init&#39;)axes[1].imshow(dst[:, :, ::-1])axes[1].set_title(&#39;transform&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/affine.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">仿射变换</div></center><h2 id="透射变换"><a href="#透射变换" class="headerlink" title="透射变换"></a>透射变换</h2><p>透射变换是视角变化的结果，是指利用透视中心、像点、目标点三点共线的条件，按透视旋转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。</p><center><img src="/2021/04/12/OpenCV-OpenCV-mask/2.png#pic_center" width="80%" height="80%" alt="test"></center><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Mat M &#x3D; getPerspectiveTransform(pts, pt2);&#x2F;&#x2F; 由两幅图像的对应4个点获得变换矩阵warpPerspective(src, dst, M, Size(dst_width, dst_height));&#x2F;&#x2F; src: 源图像&#x2F;&#x2F; dst: 目标图像&#x2F;&#x2F; M: 变换矩阵&#x2F;&#x2F; Size: 变换后的图像大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;using namespace std;Mat src, mat, dst;int pts_count &#x3D; 0;Point2f pts[4];     &#x2F;&#x2F; 需要指定4个点构造矩阵int dst_width &#x3D; 800;int dst_height &#x3D; 600;&#x2F;&#x2F; 鼠标双击事件，确定需要变换的区域static void _mouse_double_click_handler(int nEvt, int x, int y, int flags, void* p) &#123;    switch (nEvt)    &#123;    case EVENT_LBUTTONDBLCLK:        if (pts_count &lt; 4) &#123;            pts[pts_count] &#x3D; Point2f(x, y);            pts_count++;            circle(mat, Point(x, y), 5, Scalar(0, 0, 255), -1, 8);            imshow(&quot;src&quot;, mat);        &#125;        break;    default:        break;    &#125;    if (pts_count &#x3D;&#x3D; 4) &#123;        Point2f pt2[4];        pt2[0] &#x3D; Point2f(0, 0);        pt2[1] &#x3D; Point2f(dst_width, 0);        pt2[2] &#x3D; Point2f(dst_width, dst_height);        pt2[3] &#x3D; Point2f(0, dst_height);        Mat M &#x3D; getPerspectiveTransform(pts, pt2);        warpPerspective(src, dst, M, Size(dst_width, dst_height));        imshow(&quot;dst&quot;, dst);        imwrite(&quot;transform.png&quot;, dst);    &#125;&#125;int main(int artc, char** argv) &#123;    src &#x3D; imread(&quot;1.png&quot;, IMREAD_COLOR);    if (src.empty()) &#123;        cout &lt;&lt; &quot;can&#39;t find picture&quot; &lt;&lt; endl;        return -1;    &#125;    namedWindow(&quot;src&quot;);    setMouseCallback(&quot;src&quot;, _mouse_double_click_handler);    mat &#x3D; src.clone();    imshow(&quot;src&quot;, mat);    waitKey(0);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/1.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">原始图像</div></center><center><img src="/2021/04/12/OpenCV-OpenCV-mask/transform.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">仿射图像</div></center><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npimport cv2 as cvimport matplotlib.pyplot as pltdst_width &#x3D; 1200dst_height &#x3D; 900img &#x3D; cv.imread(&#39;1.png&#39;)print(img.shape)rows, cols &#x3D; img.shape[:2]print(rows)print(cols)pts1 &#x3D; np.float32([[33, 74], [1238, 60], [963, 555], [318, 563]])pts2 &#x3D; np.float32([[0, 0], [dst_width, 0], [dst_width, dst_height], [0, dst_height]])M &#x3D; cv.getPerspectiveTransform(pts1, pts2)dst &#x3D; cv.warpPerspective(img, M, (dst_width, dst_height))cv.imwrite(&#39;perspective.png&#39;, dst)fig, axes &#x3D; plt.subplots(nrows&#x3D;1, ncols&#x3D;2, figsize&#x3D;(10, 8), dpi&#x3D;100)axes[0].imshow(img[:, :, ::-1])axes[0].set_title(&#39;init&#39;)axes[1].imshow(dst[:, :, ::-1])axes[1].set_title(&#39;transform&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/perspective.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">仿射变换</div></center><h2 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npimport cv2 as cvimport matplotlib.pyplot as pltsrc &#x3D; cv.imread(&#39;mask2.png&#39;)img &#x3D; cv.cvtColor(src, cv.COLOR_BGR2GRAY)kernel &#x3D; np.ones((10, 10), np.int8)kernel2 &#x3D; np.ones((25, 25), np.int8)erosion &#x3D; cv.erode(img, kernel)dilate &#x3D; cv.dilate(erosion, kernel2)plt.figure(1)plt.imshow(src[:, :, ::-1])plt.figure(2)plt.imshow(dilate, cmap&#x3D;&quot;binary&quot;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/open.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">开运算</div></center><h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npimport cv2 as cvimport matplotlib.pyplot as pltsrc &#x3D; cv.imread(&#39;open.png&#39;, cv.IMREAD_GRAYSCALE)print(src.shape)low &#x3D; 100high &#x3D; 200canny &#x3D; cv.Canny(src, low, high)fig, axes &#x3D; plt.subplots(nrows&#x3D;1, ncols&#x3D;2, figsize&#x3D;(10, 8), dpi&#x3D;100)axes[0].imshow(src, cmap&#x3D;&quot;binary&quot;)axes[0].set_title(&#39;init&#39;)axes[1].imshow(canny, cmap&#x3D;&quot;binary&quot;)axes[1].set_title(&#39;Canny&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/canny.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">边缘检测</div></center><h2 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">cv.drawContours(image, contours, contourIdx&#x3D;1, color&#x3D;(255, 0, 0), thickness&#x3D;5)# image: 在哪个图像上画# contours: 轮廓集合# contourIdx: 绘制哪个轮廓，-1表示所有# color: 颜色# thickness: 线宽<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-py" data-language="py"><code class="language-py">import cv2 as cvfrom matplotlib import pyplot as pltimport numpy as npimage &#x3D; cv.imread(&quot;images&#x2F;open.png&quot;)print(image.shape)blur &#x3D; cv.blur(image, (5, 5))gray &#x3D; cv.cvtColor(blur, cv.COLOR_BGR2GRAY)# 二值化ret, binary &#x3D; cv.threshold(gray, 20, 100, cv.THRESH_BINARY_INV)contours, hierarchy &#x3D; cv.findContours(binary, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)print(&#39;len:&#39;, len(contours))    # 2cv.drawContours(image, contours, contourIdx&#x3D;1, color&#x3D;(255, 0, 0), thickness&#x3D;5)# 选择符合要求的轮廓进行绘制# for i in range(len(contours)):#     cnt &#x3D; contours[i]#     perimeter &#x3D; cv.arcLength(cnt, True)   # 轮廓周长#     if 3000 &lt; perimeter &lt; 3300:#         cv.drawContours(image, [cnt], -1, (255, 0, 0), 5)fig, axes &#x3D; plt.subplots(nrows&#x3D;1, ncols&#x3D;2, figsize&#x3D;(10, 8), dpi&#x3D;100)axes[0].imshow(binary, cmap&#x3D;&quot;binary&quot;)axes[0].set_title(&#39;bibary&#39;)axes[1].imshow(image, cmap&#x3D;&quot;binary&quot;)axes[1].set_title(&#39;contours&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/contour.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">绘制轮廓</div></center>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV_Panel</title>
      <link href="2021/04/12/OpenCV-OpenCV-Panel/"/>
      <url>2021/04/12/OpenCV-OpenCV-Panel/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-py" data-language="py"><code class="language-py">import cv2 as cvfrom matplotlib import pyplot as pltimport numpy as npfrom numpy.linalg import inv&quot;&quot;&quot; 求两直线交点 &quot;&quot;&quot;def intersection(line1, line2):    # [x1, y1, x2, y2]    a1 &#x3D; line1[1] - line1[3]    # a &#x3D; y1 - y2    b1 &#x3D; line1[2] - line1[0]    # b &#x3D; x2 - x1    c1 &#x3D; line1[0] * line1[3] - line1[2] * line1[1]    # c &#x3D; x1 * y2 - x2 * y1    a2 &#x3D; line2[1] - line2[3]    # a &#x3D; y1 - y2    b2 &#x3D; line2[2] - line2[0]    # b &#x3D; x2 - x1    c2 &#x3D; line2[0] * line2[3] - line2[2] * line2[1]    # c &#x3D; x1 * y2 - x2 * y1    A &#x3D; np.array([[a1, b1], [a2, b2]])    B &#x3D; np.array([[c1], [c2]])    pt &#x3D; np.dot(inv(A), -B)    x &#x3D; pt[0, 0]    y &#x3D; pt[1, 0]    return [x, y]src &#x3D; cv.imread(&quot;images&#x2F;2.png&quot;)mat &#x3D; src.copy()gray &#x3D; cv.cvtColor(src, cv.COLOR_BGR2GRAY)blur &#x3D; cv.blur(gray, (5, 5))# plt.figure(1)# plt.imshow(blur, cmap&#x3D;&quot;binary&quot;)kernel &#x3D; np.ones((10, 10), np.int8)dilate &#x3D; cv.dilate(blur, kernel)&quot;&quot;&quot; 二值化 &quot;&quot;&quot;ret, binary &#x3D; cv.threshold(dilate, 100, 120, cv.THRESH_BINARY_INV)# plt.figure(2)# plt.imshow(binary, cmap&#x3D;&quot;binary&quot;)&quot;&quot;&quot; 求轮廓 &quot;&quot;&quot;contours, hierarchy &#x3D; cv.findContours(binary, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)# print(&#39;len:&#39;, len(contours))cnt &#x3D; contours[0]# cv.drawContours(src, [cnt], -1, (0, 0, 255), 2)&quot;&quot;&quot; 找到满足周长条件的轮廓 &quot;&quot;&quot;for i in range(len(contours)):    cnt &#x3D; contours[i]    perimeter &#x3D; cv.arcLength(cnt, True)    if 2500 &lt; perimeter &lt; 3500:        print(perimeter)        # cv.drawContours(src, [cnt], -1, (0, 255, 255), 2)        break# plt.figure(2)# plt.imshow(src[:, :, ::-1])&quot;&quot;&quot; 求凸包 &quot;&quot;&quot;hull &#x3D; cv.convexHull(cnt)img &#x3D; np.ones((720, 1280, 3), dtype&#x3D;np.uint8)# print(type(gray))   # &lt;class &#39;numpy.ndarray&#39;&gt;# print(gray.shape)   # (720, 1280)# print(type(img))    # &lt;class &#39;numpy.ndarray&#39;&gt;# print(img.shape)    # (720, 1280)# cv.drawContours(src, [hull], -1, (255, 0, 0), 3)# print(len(hull))&quot;&quot;&quot; 在另一张图上画出凸包 &quot;&quot;&quot;cv.drawContours(img, [hull], -1, (0, 0, 255), 2)img_gray &#x3D; cv.cvtColor(img, cv.COLOR_BGR2GRAY)&quot;&quot;&quot; 二值化 &quot;&quot;&quot;_, img_binary &#x3D; cv.threshold(img_gray, 50, 100, cv.THRESH_BINARY)plt.figure(3)plt.imshow(img_binary, cmap&#x3D;&quot;binary&quot;)#### cv.imwrite(&quot;images&#x2F;img.png&quot;, img_binary)&quot;&quot;&quot; 霍夫线检测 &quot;&quot;&quot;lines &#x3D; cv.HoughLines(img_binary, 1.0, np.pi&#x2F;180, 250)print(lines.shape)      # (8, 1, 2)lines &#x3D; np.squeeze(lines)print(lines.shape)      # (8, 2)&quot;&quot;&quot; K-means对四种线分类 &quot;&quot;&quot;criteria &#x3D; (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 10, 1.0)ret,label,center &#x3D; cv.kmeans(lines, 4, None, criteria, 10, cv.KMEANS_RANDOM_CENTERS)# print(center.shape)   # (4, 2)line_point &#x3D; []for i in range(center.shape[0]):    rho, theta &#x3D; center[i]    a &#x3D; np.cos(theta)    b &#x3D; np.sin(theta)    x0 &#x3D; rho * a    y0 &#x3D; rho * b    x1 &#x3D; int(x0 + 2000 * (-b))    y1 &#x3D; int(y0 + 2000 * a)    x2 &#x3D; int(x0 - 2000 * (-b))    y2 &#x3D; int(y0 - 2000 * a)    line_point.append([x1, y1, x2, y2])    cv.line(img, (x1, y1), (x2, y2), (255, 0, 255), 4)# print(line_point)&quot;&quot;&quot; 求4条线的4个交点 &quot;&quot;&quot;pt &#x3D; []for i in range(2):    pt.append(intersection(line_point[i], line_point[2]))    pt.append(intersection(line_point[i], line_point[3]))print(pt)points &#x3D; np.array(pt, dtype&#x3D;int)print(points.shape)     # (4, 2)print(points)# for i in range(points.shape[0]):#     cv.circle(img, (points[i, 0], points[i, 1]), 8, (0, 255, 0), -1)&quot;&quot;&quot; 画出4个交点 &quot;&quot;&quot;for pt in points:    cv.circle(img, (pt[0], pt[1]), 6, (0, 255, 0), -1)plt.figure(5)plt.imshow(img)# cv.imwrite(&quot;images&#x2F;lines.png&quot;, img)&quot;&quot;&quot; 对4个交点进行排序，因为分类的顺序是随机的 &quot;&quot;&quot;idx &#x3D; np.lexsort([points[:, 0]])tr_points &#x3D; points[idx, :]print(tr_points)&quot;&quot;&quot; 利用找到的4隔点进行透射变换 &quot;&quot;&quot;dst_width &#x3D; 800dst_height &#x3D; 600pts1 &#x3D; np.float32([tr_points[0], tr_points[3], tr_points[2], tr_points[1]])pts2 &#x3D; np.float32([[0, 0], [dst_width, 0], [dst_width, dst_height], [0, dst_height]])M &#x3D; cv.getPerspectiveTransform(pts1, pts2)dst &#x3D; cv.warpPerspective(mat, M, (dst_width, dst_height))plt.figure(6)plt.imshow(dst[:, :, ::-1])cv.imwrite(&#39;images&#x2F;dst_2.png&#39;, dst)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-Panel/1.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">1.原图</div></center><center><img src="/2021/04/12/OpenCV-OpenCV-Panel/img.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">2.凸包</div></center><center><img src="/2021/04/12/OpenCV-OpenCV-Panel/lines.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">3. 霍夫线检测与交点</div></center><center><img src="/2021/04/12/OpenCV-OpenCV-Panel/dst_1.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">4.透射变换</div></center>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV_Pix</title>
      <link href="2021/04/01/OpenCV-OpenCV-Pix/"/>
      <url>2021/04/01/OpenCV-OpenCV-Pix/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="获取并修改像素值"><a href="#获取并修改像素值" class="headerlink" title="获取并修改像素值"></a>获取并修改像素值</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;using namespace std;int main(int artc, char** argv) &#123;    Mat src &#x3D; imread(&quot;&#x2F;home&#x2F;kavin&#x2F;Pictures&#x2F;test.png&quot;, IMREAD_COLOR);    if (src.empty()) &#123;        printf(&quot;could not load image...\n&quot;);        return -1;    &#125;    for (int i &#x3D; 5; i &lt; 50; i++) &#123;          &#x2F;&#x2F; 行        for (int j &#x3D; 30; j &lt; 100; j++) &#123;    &#x2F;&#x2F; 列            src.at&lt;Vec3b&gt;(i, j)[0] &#x3D; 255;            src.at&lt;Vec3b&gt;(i, j)[1] &#x3D; 0;            src.at&lt;Vec3b&gt;(i, j)[2] &#x3D; 0;        &#125;    &#125;    namedWindow(&quot;input&quot;, WINDOW_AUTOSIZE);    imshow(&quot;input&quot;, src);    imwrite(&quot;pix.png&quot;, src);    waitKey(0);    &#x2F;&#x2F; 对应的roi区域 （左上角坐标（w,h）,width,height）    Rect rect_roi(30, 5, 70, 45);    Mat img_roi &#x3D; src(rect_roi);    imshow(&quot;roi&quot;, img_roi);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/01/OpenCV-OpenCV-Pix/pixels.png#pic_center" width="50%" height="50%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">修改像素值</div></center><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">src &#x3D; cv.imread(&quot;.&#x2F;test.png&quot;)&#x2F;&#x2F; 获取某个点的像素值px &#x3D; src[200, 250]      # [ 27  15 244]&#x2F;&#x2F; 获取某个点某个通道的像素值blue &#x3D; src[200, 250, 0] # 27&#x2F;&#x2F; 修改高度为200的所有像素值为0src[200, :] &#x3D; [0, 0, 0]cv.namedWindow(&quot;input&quot;, cv.WINDOW_AUTOSIZE)cv.imshow(&quot;input&quot;, src)cv.waitKey(0)cv.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/01/OpenCV-OpenCV-Pix/pix.png#pic_center" width="50%" height="50%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">修改像素值</div></center><h2 id="通道拆分与合并"><a href="#通道拆分与合并" class="headerlink" title="通道拆分与合并"></a>通道拆分与合并</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">b, g, r &#x3D; cv.split(src)img &#x3D; cv.merge((b, g, r))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><center><img src="/2021/04/01/OpenCV-OpenCV-Pix/b.png#pic_center" width="50%" height="50%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">B通道图像</div></center><h2 id="转换颜色空间"><a href="#转换颜色空间" class="headerlink" title="转换颜色空间"></a>转换颜色空间</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">hsv &#x3D; cv.cvtColor(src, cv.COLOR_BGR2HSV)cv.namedWindow(&quot;hsv&quot;, cv.WINDOW_AUTOSIZE)cv.imshow(&quot;hsv&quot;, hsv)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/01/OpenCV-OpenCV-Pix/hsv.png#pic_center" width="50%" height="50%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">HSV颜色空间</div></center>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV_RGB&amp;GRAY</title>
      <link href="2021/04/01/OpenCV-OpenCV-RGB-GRAY/"/>
      <url>2021/04/01/OpenCV-OpenCV-RGB-GRAY/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="读取图像"><a href="#读取图像" class="headerlink" title="读取图像"></a>读取图像</h2><h3 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">imread( const String&amp; filename, int flags &#x3D; IMREAD_COLOR )filename&#x2F;&#x2F; 图片路径flags&#x2F;&#x2F; 以彩色图或灰度图的方式进行读取    IMREAD_GRAYSCALE &#x3D; 0    &#x2F;&#x2F; 灰度图    IMREAD_COLOR     &#x3D; 1    &#x2F;&#x2F; 彩色图(默认)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">namedWindow(const String&amp; winname, int flags &#x3D; WINDOW_AUTOSIZE)winname&#x2F;&#x2F; 窗口名称flags&#x2F;&#x2F; 窗口属性WINDOW_NORMAL&#x2F;&#x2F; 可拖动改变大小WINDOW_AUTOSIZE&#x2F;&#x2F; 自动调整适应图片大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">imwrite(const String&amp; filename, InputArray img, const std::vector&lt;int&gt;&amp; params &#x3D; std::vector&lt;int&gt;())filename&#x2F;&#x2F; 文件名img&#x2F;&#x2F; 对象名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Mat src &#x3D; imread(&quot;.&#x2F;test.png&quot;, IMREAD_GRAYSCALE);namedWindow(&quot;input&quot;, WINDOW_AUTOSIZE);imshow(&quot;input&quot;, src);waitKey(0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv.imread()cv.imshow()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">import cv2 as cvsrc &#x3D; cv.imread(&quot;.&#x2F;test.png&quot;)print(type(src))&#x2F;&#x2F; &lt;class &#39;numpy.ndarray&#39;&gt;print(src.dtype)&#x2F;&#x2F; uint8print(src.shape)&#x2F;&#x2F; (610, 570, 3)cv.namedWindow(&quot;input&quot;, cv.WINDOW_AUTOSIZE)cv.imshow(&quot;input&quot;, src)cv.waitKey(0)cv.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/01/OpenCV-OpenCV-RGB-GRAY/test.png#pic_center" width="50%" height="50%" alt="test"></center><h2 id="转化为灰度图"><a href="#转化为灰度图" class="headerlink" title="转化为灰度图"></a>转化为灰度图</h2><h3 id="C-版本-1"><a href="#C-版本-1" class="headerlink" title="C++版本"></a>C++版本</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cvtColor(src, gray, COLOR_BGR2GRAY)src&#x2F;&#x2F; inputgray&#x2F;&#x2F; outputCOLOR_BGR2GRAY&#x2F;&#x2F;RGB图转为GRAY灰度图默认三个通道顺序是: B, G, R<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;opencv2&#x2F;opencv.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main(int artc, char** argv) &#123;    Mat src &#x3D; imread(&quot;.&#x2F;test.png&quot;, IMREAD_COLOR);    if (src.empty()) &#123;        printf(&quot;could not load image...\n&quot;);        return -1;    &#125;    namedWindow(&quot;input&quot;, WINDOW_AUTOSIZE);    imshow(&quot;input&quot;, src);    Mat gray;    cvtColor(src, gray, COLOR_BGR2GRAY);    imwrite(&quot;.&#x2F;gray.png&quot;, gray);    namedWindow(&quot;gray&quot;, WINDOW_AUTOSIZE);    imshow(&quot;gray&quot;, gray);    waitKey(0);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Python版本-1"><a href="#Python版本-1" class="headerlink" title="Python版本"></a>Python版本</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">src &#x3D; cv.imread(&quot;.&#x2F;test.png&quot;)cv.namedWindow(&quot;input&quot;, cv.WINDOW_AUTOSIZE)cv.imshow(&quot;input&quot;, src)gray &#x3D; cv.cvtColor(src, cv.COLOR_BGR2GRAY)cv.imwrite(&#39;gray.png&#39;, gray)cv.imshow(&quot;gray&quot;, gray)cv.waitKey(0)cv.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/01/OpenCV-OpenCV-RGB-GRAY/gray.png#pic_center" width="50%" height="50%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">灰度图</div></center>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV_draw</title>
      <link href="2021/04/01/OpenCV-OpenCV-draw/"/>
      <url>2021/04/01/OpenCV-OpenCV-draw/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a>绘制直线</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv.line(img,start,end,color,thickness)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>img</code>: 要绘制直线的图像</li><li><code>start,end</code>: 直线的起点和终点</li><li><code>color</code>: 线条的颜色</li><li><code>thickness</code>: 线条宽度</li></ul><h2 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv.circle(img,centerpoint, r, color, thickness)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>img</code>: 要绘制圆形的图像</li><li><code>centerpoint, r</code>: 圆心和半径</li><li><code>color</code>: 线条的颜色</li><li><code>thickness</code>: 线条宽度，为-1时生成闭合图案并填充颜色</li></ul><h2 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv.rectangle(img,leftupper,rightdown,color,thickness)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>img</code>: 要绘制矩形的图像</li><li><code>leftupper, rightdown</code>: 矩形的左上角和右下角坐标</li><li><code>color</code>: 线条的颜色</li><li><code>thickness</code>: 线条宽度</li></ul><h2 id="向图像中添加文字"><a href="#向图像中添加文字" class="headerlink" title="向图像中添加文字"></a>向图像中添加文字</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv.putText(img,text,station, font, fontsize,color,thickness,cv.LINE_AA)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>img</code>: 图像</li><li><code>text</code>: 要写入的文本数据</li><li><code>station</code>: 文本的放置位置</li><li><code>font</code>: 字体</li><li><code>fontsize</code>: 字体大小</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">import cv2 as cvimport numpy as npsrc &#x3D; np.zeros([512, 512, 3], np.uint8)# 创建一张512X512大小的8位3通道图像，数据类型是unsigned int# 第一个方向是width，第二个是heightcv.line(src, (0, 0), (511, 511), (0, 0, 255), 3)cv.rectangle(src, (384,0),(510,128), (0,255,0), 3)cv.circle(src, (447,63), 63, (0,0,255), -1)font &#x3D; cv.FONT_ITALICcv.putText(src, &#39;OpenCV&#39;, (10,500), font, 2, (255,255,255), 2, cv.LINE_AA)cv.namedWindow(&quot;src&quot;, cv.WINDOW_AUTOSIZE)cv.imshow(&quot;src&quot;, src)cv.waitKey(0)cv.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/04/01/OpenCV-OpenCV-draw/draw.png#pic_center" width="50%" height="50%" alt="test"></p>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS图像处理</title>
      <link href="2021/03/26/ROS-ROS-CV/"/>
      <url>2021/03/26/ROS-ROS-CV/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="OpenCV-3-3-1"><a href="#OpenCV-3-3-1" class="headerlink" title="OpenCV 3.3.1"></a>OpenCV 3.3.1</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir build &amp;&amp; cd buildmkdir installedcmake -DCMAKE_BUILD_TYPE&#x3D;RELEASE -DCMAKE_INSTALL_PREFIX&#x3D;~&#x2F;Library&#x2F;opencv-3.3.1&#x2F;build&#x2F;installed -DWITH_CUDA&#x3D;OFF -DBUILD_DOCS&#x3D;OFF -DBUILD_EXAMPLES&#x3D;OFF -DBUILD_TESTS&#x3D;OFF -DBUILD_PERF_TESTS&#x3D;OFF -DOPENCV_EXTRA_MODULES_PATH&#x3D;..&#x2F;opencv_contrib&#x2F;modules ..make -j4sudo make install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改系统默认版本"><a href="#修改系统默认版本" class="headerlink" title="修改系统默认版本"></a>修改系统默认版本</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim ~&#x2F;.bashrcexport PKG_CONFIG_PATH&#x3D;~&#x2F;Library&#x2F;opencv-3.3.1&#x2F;build&#x2F;installed&#x2F;lib&#x2F;pkgconfigexport LD_LIBRARY_PATH&#x3D;~&#x2F;Library&#x2F;opencv-3.3.1&#x2F;build&#x2F;installed&#x2F;libsource ~&#x2F;.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="版本确认"><a href="#版本确认" class="headerlink" title="版本确认"></a>版本确认</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pkg-config --modversion opencv3.3.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看头文件位置<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pkg-config --cflags opencv-I&#x2F;home&#x2F;kavin&#x2F;Library&#x2F;opencv-3.3.1&#x2F;build&#x2F;installed&#x2F;include&#x2F;opencv-I&#x2F;home&#x2F;kavin&#x2F;Library&#x2F;opencv-3.3.1&#x2F;build&#x2F;installed&#x2F;include<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p><p>查看库文件<br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pkg-config --libs opencv-L&#x2F;home&#x2F;kavin&#x2F;Library&#x2F;opencv-3.3.1&#x2F;build&#x2F;installed&#x2F;lib -lopencv_stitching -lopencv_superres -lopencv_videostab -lopencv_photo -lopencv_aruco -lopencv_bgsegm -lopencv_bioinspired -lopencv_ccalib -lopencv_dpm -lopencv_face -lopencv_freetype -lopencv_fuzzy -lopencv_hdf -lopencv_img_hash -lopencv_line_descriptor -lopencv_optflow -lopencv_reg -lopencv_rgbd -lopencv_saliency -lopencv_sfm -lopencv_stereo -lopencv_structured_light -lopencv_viz -lopencv_phase_unwrapping -lopencv_surface_matching -lopencv_tracking -lopencv_datasets -lopencv_text -lopencv_dnn -lopencv_plot -lopencv_xfeatures2d -lopencv_shape -lopencv_video -lopencv_ml -lopencv_ximgproc -lopencv_calib3d -lopencv_features2d -lopencv_highgui -lopencv_videoio -lopencv_flann -lopencv_xobjdetect -lopencv_imgcodecs -lopencv_objdetect -lopencv_xphoto -lopencv_imgproc -lopencv_core<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h3 id="CMakeLists指定版本"><a href="#CMakeLists指定版本" class="headerlink" title="CMakeLists指定版本"></a>CMakeLists指定版本</h3><p>不修改默认是在<code>/usr</code>查找</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">set(OpenCV_DIR &quot;~&#x2F;Library&#x2F;opencv-3.3.1&#x2F;build&#x2F;installed&#x2F;OpenCV&quot;)find_package(OpenCV REQUIRED)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="发布图像"><a href="#发布图像" class="headerlink" title="发布图像"></a>发布图像</h2><p>使用<code>image_transport</code>进行图像话题发布订阅</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">image_transport::ImageTransport it(nh);     &#x2F;&#x2F;用句柄初始化image_transportimage_transport::Publisher image_pub &#x3D; it.advertise(&quot;image_topic&quot;, 10);&#x2F;&#x2F;cv::Mat通过cv_bridge::CvImage转换为sensor_msgs::ImagePtrsensor_msgs::ImagePtr msg &#x3D; cv_bridge::CvImage(std_msgs::Header(), &quot;bgr8&quot;, image).toImageMsg();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &lt;ros&#x2F;ros.h&gt;# include &lt;image_transport&#x2F;image_transport.h&gt;# include &lt;opencv2&#x2F;highgui&#x2F;highgui.hpp&gt;# include &lt;opencv2&#x2F;core&#x2F;core.hpp&gt;# include &lt;cv_bridge&#x2F;cv_bridge.h&gt;# include &lt;iostream&gt;using namespace std;using namespace cv;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;image_pub_node&quot;);    ros::NodeHandle nh;    image_transport::ImageTransport it(nh);    image_transport::Publisher image_pub &#x3D; it.advertise(&quot;image_topic&quot;, 10);    Mat image &#x3D; imread(&quot;&#x2F;home&#x2F;kavin&#x2F;Pictures&#x2F;test.png&quot;, IMREAD_COLOR);    if (image.empty())    &#123;        cout &lt;&lt; &quot;can&#39;t find picture&quot; &lt;&lt; endl;        return -1;    &#125;    sensor_msgs::ImagePtr msg &#x3D; cv_bridge::CvImage(std_msgs::Header(), &quot;bgr8&quot;, image).toImageMsg();    ros::Rate loop_rate(1);    while(nh.ok())    &#123;        image_pub.publish(msg);        ROS_INFO(&quot;publish an image&quot;);        loop_rate.sleep();    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="接收图像"><a href="#接收图像" class="headerlink" title="接收图像"></a>接收图像</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">image_transport::Subscriber image_sub &#x3D; it.subscribe(&quot;&#x2F;simple_camera&#x2F;image_raw&quot;, 1, image_topic_cb);&#x2F;&#x2F;sensor_msgs话题通过cv_bridge::toCvCopy转换为cv::Mat指针cv_bridge::CvImagePtr cv_ptr &#x3D; cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);Mat colorImg &#x3D; cv_ptr-&gt;image;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;sensor_msgs&#x2F;image_encodings.h&gt;#include &lt;image_transport&#x2F;image_transport.h&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;#include &lt;cv_bridge&#x2F;cv_bridge.h&gt;#include &lt;iostream&gt;using namespace std;using namespace cv;Mat colorImg;void image_topic_cb(const sensor_msgs::ImageConstPtr&amp; msg)&#123;    try    &#123;        ROS_INFO(&quot;Receive an image successfully&quot;);        cv_bridge::CvImagePtr cv_ptr &#x3D; cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);        colorImg &#x3D; cv_ptr-&gt;image;        imshow(&quot;image&quot;, colorImg);        Mat grayImg;        cvtColor(colorImg, grayImg, COLOR_BGR2GRAY);        imshow(&quot;gray&quot;, grayImg);        &#x2F;&#x2F; cv::imshow(&quot;image&quot;, cv_bridge::toCvShare(msg, &quot;bgr8&quot;)-&gt;image);        &#x2F;&#x2F; cv::waitKey(10);    &#125; catch(cv_bridge::Exception&amp; e) &#123;        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;&#125;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;image_sub&quot;);    ros::NodeHandle nh;    image_transport::ImageTransport it(nh);    namedWindow(&quot;image&quot;, CV_WINDOW_AUTOSIZE);    namedWindow(&quot;gray&quot;, CV_WINDOW_AUTOSIZE);    startWindowThread();    image_transport::Subscriber image_sub &#x3D; it.subscribe(&quot;&#x2F;simple_camera&#x2F;image_raw&quot;, 1, image_topic_cb);    ros::spin();    destroyWindow(&quot;image&quot;);    destroyWindow(&quot;gray&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">#! &#x2F;usr&#x2F;bin&#x2F;env python# coding&#x3D;utf-8import rospyfrom sensor_msgs.msg import Imageimport cv2from cv_bridge import CvBridgerospy.init_node(&#39;py_image_sub&#39;, anonymous&#x3D;True)def colorCallBack(msg):    bridge &#x3D; CvBridge()    img &#x3D; bridge.imgmsg_to_cv2(msg, &quot;bgr8&quot;)    cv2.imshow(&quot;color&quot;, img)    cv2.waitKey(10)def listener():    rospy.Subscriber(&quot;image_topic&quot;, Image, colorCallBack)    rospy.spin()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    print(cv2.__version__)    listener()    print(&#39;done&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS action</title>
      <link href="2021/03/26/ROS-ROS-action/"/>
      <url>2021/03/26/ROS-ROS-action/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="自定义-action-文件"><a href="#自定义-action-文件" class="headerlink" title="自定义 action 文件"></a>自定义 action 文件</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">int32 input---int32 outputint32 goal_stamp---int32 feedback<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">add_action_files(  FILES  demo.action)generate_messages(DEPENDENCIES  std_msgs  std_srvs  actionlib_msgs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">></span></span>actionlib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">></span></span>actionlib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">></span></span>actionlib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;actionlib&#x2F;server&#x2F;simple_action_server.h&gt;#include &quot;ros_learning&#x2F;demoAction.h&quot;int g_count &#x3D; 0;bool g_count_failure &#x3D; false;class ExampleActionServer &#123;private:    ros::NodeHandle nh_;     actionlib::SimpleActionServer&lt;ros_learning::demoAction&gt; as_;    ros_learning::demoGoal goal_;     ros_learning::demoResult result_;     ros_learning::demoFeedback feedback_;    &#x2F;&#x2F; 每部分都有对应的类名public:    ExampleActionServer();    ~ExampleActionServer(void) &#123;&#125;    void executeCB(const actionlib::SimpleActionServer&lt;ros_learning::demoAction&gt;::GoalConstPtr&amp; goal);&#125;;ExampleActionServer::ExampleActionServer() : as_(nh_,                                                 &quot;example_action&quot;,                                                 boost::bind(&amp;ExampleActionServer::executeCB, this, _1),                                                false)&#123;    ROS_INFO(&quot;in constructor of exampleActionServer...&quot;);    as_.start(); &#x2F;&#x2F; 启动服务    &#x2F;&#x2F; 构造函数中的false是指在初始化时先不启动，调用start()函数之后再启动&#125;void ExampleActionServer::executeCB(const actionlib::SimpleActionServer&lt;ros_learning::demoAction&gt;::GoalConstPtr&amp; goal) &#123;    g_count++;    result_.output &#x3D; g_count;    result_.goal_stamp &#x3D; goal-&gt;input;        if (g_count !&#x3D; goal-&gt;input) &#123;        ROS_WARN(&quot;hey--mismatch!&quot;);        ROS_INFO(&quot;g_count &#x3D; %d; goal_stamp &#x3D; %d&quot;, g_count, result_.goal_stamp);        g_count_failure &#x3D; true;        ROS_WARN(&quot;informing client of aborted goal&quot;);        as_.setAborted();     &#125;    else &#123;        as_.setSucceeded(result_);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char** argv) &#123;    ros::init(argc, argv, &quot;action_server_node&quot;);    ROS_INFO(&quot;instantiating the demo action server: &quot;);    ExampleActionServer as_object;        ROS_INFO(&quot;going into spin&quot;);    while (!g_count_failure &amp;&amp; ros::ok()) &#123;        ros::spinOnce();    &#125;    return 0;&#125;#include &lt;ros&#x2F;ros.h&gt;#include &lt;actionlib&#x2F;client&#x2F;simple_action_client.h&gt;#include &quot;ros_learning&#x2F;demoAction.h&quot;void doneCb(const actionlib::SimpleClientGoalState&amp; state,            const ros_learning::demoResultConstPtr&amp; result) &#123;    ROS_WARN(&quot;doneCb: server responded with state [%s]&quot;, state.toString().c_str());    int diff &#x3D; result-&gt;output - result-&gt;goal_stamp;    ROS_WARN(&quot;got result output &#x3D; %d; goal_stamp &#x3D; %d; diff &#x3D; %d&quot;, result-&gt;output, result-&gt;goal_stamp, diff);&#125;int main(int argc, char** argv) &#123;    ros::init(argc, argv, &quot;action_client_node&quot;);    int g_count &#x3D; 0;    ros_learning::demoGoal goal;    actionlib::SimpleActionClient&lt;ros_learning::demoAction&gt; action_client(&quot;example_action&quot;, true);    ROS_INFO(&quot;waiting for server: &quot;);    bool server_exists &#x3D; action_client.waitForServer(ros::Duration(5.0));    &#x2F;&#x2F;bool server_exists &#x3D; action_client.waitForServer(); &#x2F;&#x2F;wait forever    if (!server_exists) &#123;        ROS_WARN(&quot;could not connect to server; halting&quot;);        return 0;    &#125;    ROS_INFO(&quot;connected to action server&quot;);    while (true)     &#123;        g_count++;        goal.input &#x3D; g_count;        action_client.sendGoal(goal, &amp;doneCb);        &#x2F;&#x2F; action_client.sendGoal(goal);         &#x2F;&#x2F; action_client.sendGoal(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb);        bool finished_before_timeout &#x3D; action_client.waitForResult(ros::Duration(5.0));        &#x2F;&#x2F; action_client.waitForResult(); &#x2F;&#x2F; wait forever...        if (!finished_before_timeout) &#123;            ROS_WARN(&quot;giving up waiting on result for goal number %d&quot;, g_count);            return 0;        &#125; else &#123;            &#x2F;&#x2F;if here, then server returned a result to us        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS find_red_pixels</title>
      <link href="2021/03/26/ROS-ROS-find-red-pixels/"/>
      <url>2021/03/26/ROS-ROS-find-red-pixels/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="ImageConverter类声明"><a href="#ImageConverter类声明" class="headerlink" title="ImageConverter类声明"></a><code>ImageConverter</code>类声明</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;image_transport&#x2F;image_transport.h&gt;#include &lt;cv_bridge&#x2F;cv_bridge.h&gt;#include &lt;sensor_msgs&#x2F;image_encodings.h&gt;#include &lt;opencv2&#x2F;imgproc&#x2F;imgproc.hpp&gt;#include &lt;opencv2&#x2F;highgui&#x2F;highgui.hpp&gt;static const std::string OPENCV_WINDOW &#x3D; &quot;OpenCV display window&quot;;using namespace std;using namespace cv;int g_redratio; &#x2F;&#x2F; 红色阈值class ImageConverter &#123;    ros::NodeHandle nh_;    image_transport::ImageTransport it_;    image_transport::Subscriber image_sub_;    image_transport::Publisher image_pub_;public:    ImageConverter(ros::NodeHandle &amp;nodehandle)    : it_(nh_) &#123;        image_sub_ &#x3D; it_.subscribe(&quot;simple_camera&#x2F;image_raw&quot;, 1,                &amp;ImageConverter::imageCb, this);        image_pub_ &#x3D; it_.advertise(&quot;&#x2F;image_converter&#x2F;output_video&quot;, 1);        namedWindow(OPENCV_WINDOW);    &#125;    ~ImageConverter() &#123;        destroyWindow(OPENCV_WINDOW);    &#125;    void imageCb(const sensor_msgs::ImageConstPtr&amp; msg);     &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="imageCb回调函数定义"><a href="#imageCb回调函数定义" class="headerlink" title="imageCb回调函数定义"></a><code>imageCb</code>回调函数定义</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void ImageConverter::imageCb(const sensor_msgs::ImageConstPtr&amp; msg)&#123;    cv_bridge::CvImagePtr cv_ptr; &#x2F;&#x2F;OpenCV data type    try &#123;        cv_ptr &#x3D; cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);    &#125; catch (cv_bridge::Exception&amp; e) &#123;        ROS_ERROR(&quot;cv_bridge exception: %s&quot;, e.what());        return;    &#125;    int npix &#x3D; 0;   &#x2F;&#x2F; 红色区域总的像素    int isum &#x3D; 0;   &#x2F;&#x2F; 红色的列数    int jsum &#x3D; 0;   &#x2F;&#x2F; 红色的行数    int redval, blueval, greenval, testval;    Vec3b rgbpix;    for (int i &#x3D; 0; i &lt; cv_ptr-&gt;image.cols; i++) &#123;        for (int j &#x3D; 0; j &lt; cv_ptr-&gt;image.rows; j++) &#123;            &#x2F;&#x2F; 提取某点像素值            rgbpix &#x3D; cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i);            redval &#x3D; rgbpix[2] + 1; &#x2F;&#x2F; +1 防止除以0            blueval &#x3D; rgbpix[0] + 1;            greenval &#x3D; rgbpix[1] + 1;            testval &#x3D; redval &#x2F; (blueval + greenval);            &#x2F;&#x2F; 如果这个点判定为红色，设为白色            if (testval &gt; g_redratio) &#123;                cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i)[0] &#x3D; 255;                cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i)[1] &#x3D; 255;                cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i)[2] &#x3D; 255;                npix++;     &#x2F;&#x2F; 红色区域总的像素                isum +&#x3D; i;  &#x2F;&#x2F; 红色的列数                jsum +&#x3D; j;  &#x2F;&#x2F; 红色的行数            &#125; else &#123; &#x2F;&#x2F; 其他点设为黑色                cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i)[0] &#x3D; 0;                cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i)[1] &#x3D; 0;                cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i)[2] &#x3D; 0;            &#125;        &#125;    &#125;    ROS_WARN(&quot;npix: %d&quot;, npix);    int half_box &#x3D; 5; &#x2F;&#x2F; 矩形大小    int i_centroid, j_centroid;    double x_centroid, y_centroid;    if (npix &gt; 0) &#123;        i_centroid &#x3D; isum &#x2F; npix;   &#x2F;&#x2F; 中间点位置        j_centroid &#x3D; jsum &#x2F; npix;        x_centroid &#x3D; ((double) isum)&#x2F;((double) npix);        y_centroid &#x3D; ((double) jsum)&#x2F;((double) npix);        ROS_INFO(&quot;u_avg: %f; v_avg: %f&quot;,x_centroid,y_centroid);        ROS_WARN(&quot;center (col, row) : (%d, %d)&quot;, i_centroid, j_centroid);        for (int i_box &#x3D; i_centroid - half_box; i_box &lt;&#x3D; i_centroid + half_box; i_box++) &#123;            for (int j_box &#x3D; j_centroid - half_box; j_box &lt;&#x3D; j_centroid + half_box; j_box++) &#123;                if ((i_box &gt;&#x3D; 0)&amp;&amp;(j_box &gt;&#x3D; 0)&amp;&amp;(i_box &lt; cv_ptr-&gt;image.cols)&amp;&amp;(j_box &lt; cv_ptr-&gt;image.rows)) &#123;                    cv_ptr-&gt;image.at&lt;Vec3b&gt;(j_box, i_box)[0] &#x3D; 255; &#x2F;&#x2F;(255,0,0) is pure blue                    cv_ptr-&gt;image.at&lt;Vec3b&gt;(j_box, i_box)[1] &#x3D; 0;                    cv_ptr-&gt;image.at&lt;Vec3b&gt;(j_box, i_box)[2] &#x3D; 0;                &#125;            &#125;        &#125;    &#125;    imshow(OPENCV_WINDOW, cv_ptr-&gt;image);   &#x2F;&#x2F; 图像显示    waitKey(3);     image_pub_.publish(cv_ptr-&gt;toImageMsg());   &#x2F;&#x2F; 将处理后的图像发布出去&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char** argv) &#123;    ros::init(argc, argv, &quot;find_red_pixels_node&quot;);    ros::NodeHandle n;        ImageConverter ic(n);   &#x2F;&#x2F; 创建类实例    g_redratio&#x3D; 10;         &#x2F;&#x2F; 红色的阈值    ros::Duration timer(0.1);    while (ros::ok()) &#123;        ros::spinOnce();        timer.sleep();    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/03/26/ROS-ROS-find-red-pixels/image.png#pic_center" width="80%" height="80%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">原始图像</div></center><center><img src="/2021/03/26/ROS-ROS-find-red-pixels/image2.png#pic_center" width="80%" height="80%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">找到红色区域中心位置</div></center><h2 id="canny函数"><a href="#canny函数" class="headerlink" title="canny函数"></a><code>canny</code>函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Mat gray_image, contours;cvtColor(cv_ptr-&gt;image, gray_image, COLOR_BGR2GRAY);Canny(gray_image, contours, 125, 350);imshow(OPENCV_WINDOW, contours);waitKey(3); sensor_msgs::ImagePtr msg_contours;try &#123;    msg_contours &#x3D; cv_bridge::CvImage(std_msgs::Header(), &quot;mono8&quot;, contours).toImageMsg();&#125; catch(cv_bridge::Exception&amp; e) &#123;    ROS_ERROR(&quot;cv_bridge exception: %s&quot;, e.what());    return;&#125;image_pub_.publish(msg_contours);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="编码参数"><a href="#编码参数" class="headerlink" title="编码参数"></a>编码参数</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php">mono8: CV_8UC1, grayscale imagemono16: CV_16UC1, 16-bit grayscale imagebgr8: CV_8UC3, color image with blue-green-red color orderrgb8: CV_8UC3, color image with red-green-blue color orderbgra8: CV_8UC4, BGR color image with an alpha channelrgba8: CV_8UC4, RGB color image with an alpha channel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/03/26/ROS-ROS-find-red-pixels/contours.png#pic_center" width="80%" height="80%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">红色边缘</div></center>]]></content>
      
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS_MAVROS</title>
      <link href="2021/03/26/ROS-ROS-mavros/"/>
      <url>2021/03/26/ROS-ROS-mavros/</url>
      
        <content type="html"><![CDATA[<!-- toc --><p><img src="/2021/03/26/ROS-ROS-mavros/mavros/mavros.png" alt></p><h2 id="常用MAVROS消息"><a href="#常用MAVROS消息" class="headerlink" title="常用MAVROS消息"></a>常用MAVROS消息</h2><h3 id="global-position-订阅-GPS-数据"><a href="#global-position-订阅-GPS-数据" class="headerlink" title="global_position 订阅 GPS 数据"></a>global_position 订阅 GPS 数据</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">消息名称: mavros&#x2F;global_position&#x2F;global类型名称: sensor_msgs::NavSatFix常用类成员变量: float64 latitude    &#x2F;&#x2F;经float64 longitude   &#x2F;&#x2F;纬float64 altitude    &#x2F;&#x2F;海拔float64[9] position_covarianceuint8 position_covariance_type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="imu-pub-订阅-IMU-原始数据"><a href="#imu-pub-订阅-IMU-原始数据" class="headerlink" title="imu_pub 订阅 IMU 原始数据"></a>imu_pub 订阅 IMU 原始数据</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">消息名称: mavros&#x2F;imu&#x2F;data(不是mavros&#x2F;imu&#x2F;data_raw, mavros&#x2F;imu&#x2F;data 为经过滤波后的数据)类型名称: sensor_msgs::Imu常用类成员变量:geometry_msgs::Quaternion orientation       &#x2F;&#x2F;旋转四元数(xyzw)float64[9] orientation_covariance           &#x2F;&#x2F;方差geometry_msgs::Vector3 angular_velocity     &#x2F;&#x2F;3 轴角速度(xyz)float64[9] angular_velocity_covariance      &#x2F;&#x2F;方差geometry_msgs::Vector3 linear_acceleration  &#x2F;&#x2F;线性加速度(xyz)float64[9] linear_acceleration_covariance   &#x2F;&#x2F;方差<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="local-position-订阅本地位置数据"><a href="#local-position-订阅本地位置数据" class="headerlink" title="local_position 订阅本地位置数据"></a>local_position 订阅本地位置数据</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">消息名称: mavros&#x2F;local_position&#x2F;pose类型名称: geometry_msgs::PoseStamped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="manual-control-订阅遥控器的值"><a href="#manual-control-订阅遥控器的值" class="headerlink" title="manual_control 订阅遥控器的值"></a>manual_control 订阅遥控器的值</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">消息名称: mavros&#x2F;manual_control&#x2F;control类型名称: mavros_msgs::ManualControl常用类成员变量:float32 xfloat32 yfloat32 zfloat32 ruint16 buttons<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sys-status-查询系统状态"><a href="#sys-status-查询系统状态" class="headerlink" title="sys_status 查询系统状态"></a>sys_status 查询系统状态</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">消息名称: mavros&#x2F;state类型名称: mavros_msgs::State常用类成员变量:bool connected  &#x2F;&#x2F;是否连接bool armed      &#x2F;&#x2F;是否解锁bool guided     &#x2F;&#x2F;是否被引导（offboard 模式）string mode     &#x2F;&#x2F;模式类型uint8 system_status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="waypoint-查询航点"><a href="#waypoint-查询航点" class="headerlink" title="waypoint 查询航点"></a>waypoint 查询航点</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">消息名称: mavros&#x2F;mission&#x2F;waypoints类型名称: mavros_msgs::WaypointList常用类成员变量:uint16 current_seq  &#x2F;&#x2F;当前航点索引mavros_msgs::Waypoint[] waypoints    uint8 frame     &#x2F;&#x2F;坐标类型    uint16 command  &#x2F;&#x2F;命令 id，16 为航点    bool is_current    bool autocontinue    float32 param1    float32 param2    float32 param3    float32 param4    float64 x_lat   &#x2F;&#x2F;经度或者 x 坐标    float64 y_long  &#x2F;&#x2F;维度或者 y 坐标    float64 z_alt   &#x2F;&#x2F;海拔或者 z 坐标<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p><code>px4</code>使用的坐标系为<code>NED</code>（北东地）坐标系或者<code>FRD</code>（前右下）坐标系。<br><code>mavros</code>中常使用的是<code>ENU</code>（东北天）坐标系或者<code>body</code>系，<code>mavros</code>会自动将输入的<code>ENU</code>坐标值或者<code>body</code>系坐标值转换到<code>NED</code>坐标系中，再通过<code>mavlink</code>发送给飞控。</p><p>mavros的话题中常见的坐标系有<code>global</code>系、<code>local</code>系、<code>body</code>系</p><ul><li><p><code>global</code>系是gps坐标系，经纬度。</p></li><li><p><code>local</code>系指当地坐标系，一般是<code>ENU</code>坐标系，坐标原点一般在起飞点。如果有offset的话坐标原点在飞机上，这时其实是导航坐标系。</p></li><li><p><code>body</code>系在melodic版本中，改成了FLU（前左上）坐标系。</p></li></ul><h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><ul><li><code>coordinate_frame=1</code>虽然代表向px4发送<code>NED</code>坐标值，但是发送到这个话题的坐标系应该用<code>ENU</code>，<code>mavros</code>会自动完成这个坐标系的转换</li><li><code>ROS</code>程序发布的给定姿态<code>topic</code>为<code>/mavros/setpoint_raw/attitude</code>，而非<code>/mavros/setpoint_attitude/attitude</code></li><li><code>ROS</code>发布的速度指令<code>topic</code>为<code>/mavros/setpoint_velocity/cmd_vel_unstamped</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php">topic: &quot;mavros&#x2F;setpoint_raw&#x2F;local&quot;rosmsg show marvros_msg&#x2F;PositionTarget    uint8 coordinate_frame    uint8 FRAME_LOCAL_NED &#x3D; 1    uint8 FRAME_LOCAL_OFFSET_NED &#x3D; 7    uint8 FRAME_BODY_NED &#x3D; 8    uint8 FRAME_BODY_OFFSET_NED &#x3D; 9    uint16 type_mask    uint16 IGNORE_PX &#x3D; 1    # Position ignore flags    uint16 IGNORE_PY &#x3D; 2    uint16 IGNORE_PZ &#x3D; 4    uint16 IGNORE_VX &#x3D; 8    # Velocity vector ignore flags    uint16 IGNORE_VY &#x3D; 16    uint16 IGNORE_VZ &#x3D; 32    uint16 IGNORE_AFX &#x3D; 64  # Acceleration&#x2F;Force vector ignore flags    uint16 IGNORE_AFY &#x3D; 128    uint16 IGNORE_AFZ &#x3D; 256    uint16 FORCE &#x3D; 512      # Force in af vector flag    uint16 IGNORE_YAW &#x3D; 1024    uint16 IGNORE_YAW_RATE &#x3D; 2048    geometry_msgs&#x2F;Point position    geometry_msgs&#x2F;Vector3 velocity    geometry_msgs&#x2F;Vector3 acceleration_or_force    float32 yaw    float32 yaw_rate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS参数服务器</title>
      <link href="2021/03/26/ROS-ROS-param/"/>
      <url>2021/03/26/ROS-ROS-param/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="YAML文件"><a href="#YAML文件" class="headerlink" title="YAML文件"></a>YAML文件</h2><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">joint1_gains: &#123;p: 7.0, i: 8.0, d: 9.0&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;read_param_node&quot;);    ros::NodeHandle n;    double P_gain, D_gain, I_gain;    ROS_WARN(&quot;rosparam start&quot;);    if (n.getParam(&quot;&#x2F;gains&#x2F;p&quot;, P_gain)) &#123;        ROS_WARN(&quot;proportional gain set to %f&quot;, P_gain);    &#125;    else &#123;        ROS_WARN(&quot;Can&#39;t load param of P&quot;);    &#125;    ros::spin()    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="launch文件"><a href="#launch文件" class="headerlink" title="launch文件"></a><code>launch</code>文件</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>launch<span class="token operator">></span>    <span class="token operator">&lt;</span>rosparam command<span class="token operator">=</span><span class="token string">"load"</span> file<span class="token operator">=</span><span class="token string">"$(find ros_learning)/param/gains.yaml"</span><span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>node name<span class="token operator">=</span><span class="token string">"read_param_node"</span> pkg<span class="token operator">=</span><span class="token string">"ros_learning"</span> type<span class="token operator">=</span><span class="token string">"read_param_node"</span> output<span class="token operator">=</span><span class="token string">"screen"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>launch<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS控制器</title>
      <link href="2021/03/26/ROS-ROS%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>2021/03/26/ROS-ROS%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="Minimal-Simulator"><a href="#Minimal-Simulator" class="headerlink" title="Minimal Simulator"></a>Minimal Simulator</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;ros&#x2F;ros.h&gt; #include&lt;std_msgs&#x2F;Float64.h&gt; std_msgs::Float64 g_velocity;std_msgs::Float64 g_force;void myCallback(const std_msgs::Float64&amp; message_holder) &#123;    ROS_INFO(&quot;received force value is: %f&quot;, message_holder.data);    g_force.data &#x3D; message_holder.data; &#125;int main(int argc, char **argv) &#123;    ros::init(argc, argv, &quot;minimal_simulator&quot;);    ros::NodeHandle nh;     ros::Subscriber my_subscriber_object &#x3D; nh.subscribe(&quot;force_cmd&quot;, 1, myCallback);    ros::Publisher my_publisher_object &#x3D; nh.advertise&lt;std_msgs::Float64&gt;(&quot;velocity&quot;, 1);    &#x2F;&#x2F; 订阅力控制话题，通过积分发布速度话题    double mass &#x3D; 1.0;    double dt &#x3D; 0.01;   &#x2F;&#x2F;10ms 积分时间    double sample_rate &#x3D; 1.0 &#x2F; dt;     ros::Rate naptime(sample_rate);    g_velocity.data &#x3D; 0.0;      g_force.data &#x3D; 0.0;     while (ros::ok()) &#123;        g_velocity.data &#x3D; g_velocity.data + (g_force.data &#x2F; mass) * dt;         my_publisher_object.publish(g_velocity);         ROS_INFO(&quot;velocity &#x3D; %f&quot;, g_velocity.data);        ros::spinOnce();        naptime.sleep();     &#125;    return 0;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Minimal-Controller"><a href="#Minimal-Controller" class="headerlink" title="Minimal Controller"></a>Minimal Controller</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;std_msgs&#x2F;Float64.h&gt;std_msgs::Float64 g_vel;std_msgs::Float64 g_vel_cmd;std_msgs::Float64 g_force;void vel_cb(const std_msgs::Float64::ConstPtr &amp;velocity)&#123;    ROS_WARN(&quot;Receive velocity: %f m&#x2F;s&quot;, velocity-&gt;data);    g_vel.data &#x3D; velocity-&gt;data;&#125;void vel_cmd_cb(const std_msgs::Float64::ConstPtr &amp;vel_cmd)&#123;    ROS_WARN(&quot;Receive desired velocity: %f m&#x2F;s&quot;, vel_cmd-&gt;data);    g_vel_cmd.data &#x3D; vel_cmd-&gt;data;&#125;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;controller&quot;);    ros::NodeHandle nh;    &#x2F;&#x2F; 订阅当前速度和期望速度    ros::Subscriber vel_sub &#x3D; nh.subscribe(&quot;velocity&quot;, 1, vel_cb);    ros::Subscriber vel_cmd_sub &#x3D; nh.subscribe(&quot;vel_cmd&quot;, 1, vel_cmd_cb);    &#x2F;&#x2F; 输出期望控制力    ros::Publisher force_pub &#x3D; nh.advertise&lt;std_msgs::Float64&gt;(&quot;force_cmd&quot;, 10);    double Kv &#x3D; 1.0;    &#x2F;&#x2F; 比例控制器    double dt &#x3D; 0.01;     double sample_rate &#x3D; 1.0 &#x2F; dt;     ros::Rate naptime(sample_rate);    g_vel.data &#x3D; 0.0;     g_vel_cmd.data &#x3D; 0.0;     g_force.data &#x3D; 0.0;    double vel_err &#x3D; 0.0;    while(ros::ok())    &#123;        vel_err &#x3D; g_vel_cmd.data - g_vel.data;        g_force.data &#x3D; Kv * vel_err;        force_pub.publish(g_force);        ROS_INFO(&quot;force command &#x3D; %f N&quot;, g_force.data);        ros::spinOnce();        naptime.sleep();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="launch文件"><a href="#launch文件" class="headerlink" title="launch文件"></a><code>launch</code>文件</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;launch&gt;    &lt;node name&#x3D;&quot;simulator&quot; pkg&#x3D;&quot;ros_learning&quot; type&#x3D;&quot;simulator_node&quot;&#x2F;&gt;    &lt;node name&#x3D;&quot;controller&quot; pkg&#x3D;&quot;ros_learning&quot; type&#x3D;&quot;controller_node&quot;&#x2F;&gt;&lt;&#x2F;launch&gt;# name: 节点名# pkg: 包名# type: 可执行文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="rqt-plot-画曲线"><a href="#rqt-plot-画曲线" class="headerlink" title="rqt_plot 画曲线"></a><code>rqt_plot</code> 画曲线</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">rostopic pub -r 10 vel_cmd std_msgs&#x2F;Float64 0.5rqt_plot velocity&#x2F;data, vel_cmd&#x2F;data, force_cmd&#x2F;data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><center><img src="/2021/03/26/ROS-ROS%E6%8E%A7%E5%88%B6%E5%99%A8/profiles.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">profiles</div></center>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS自定义msg</title>
      <link href="2021/03/26/ROS-ROS%E8%87%AA%E5%AE%9A%E4%B9%89msg/"/>
      <url>2021/03/26/ROS-ROS%E8%87%AA%E5%AE%9A%E4%B9%89msg/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="自定义msg消息"><a href="#自定义msg消息" class="headerlink" title="自定义msg消息"></a>自定义<code>msg</code>消息</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Header headerint32 numfloat64[] data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="修改CMakeLists-txt"><a href="#修改CMakeLists-txt" class="headerlink" title="修改CMakeLists.txt"></a>修改<code>CMakeLists.txt</code></h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">find_package(catkin REQUIRED COMPONENTS  roscpp  rospy  std_msgs  message_generation)&#x2F;&#x2F; 添加自定义的msg文件add_message_files(  FILES  test.msg)&#x2F;&#x2F; 自定义的msg使用了哪些包generate_messages(  DEPENDENCIES  std_msgs)catkin_package( CATKIN_DEPENDS roscpp rospy std_msgs message_runtime)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改package-xml"><a href="#修改package-xml" class="headerlink" title="修改package.xml"></a>修改<code>package.xml</code></h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;build_depend&gt;message_generation&lt;&#x2F;build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;&#x2F;exec_depend&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;iostream&gt;#include &quot;ros_learning&#x2F;test.h&quot;using namespace std;using namespace Eigen;using namespace cv;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;talker&quot;);    ros::NodeHandle n;    ros::Publisher pub &#x3D; n.advertise&lt;ros_learning::test&gt;(&quot;chatting&quot;, 10);    ros::Rate loop_rate(10);    double arr[3] &#x3D; &#123;14, 15, 16&#125;;    std::vector&lt;double&gt; vi(arr, arr+3);    ros_learning::test input_msg;    input_msg.header.stamp &#x3D; ros::Time::now();    input_msg.header.seq &#x3D; 0;    input_msg.header.frame_id &#x3D; &quot;base_frame&quot;;    input_msg.num &#x3D; 0;    input_msg.data &#x3D; vi;    while(ros::ok())    &#123;        input_msg.header.seq++;        input_msg.header.stamp &#x3D; ros::Time::now();        for (auto &amp; i : input_msg.data)            std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;        std::cout &lt;&lt; std::endl;        pub.publish(input_msg);        loop_rate.sleep();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="是否使用仿真时间"><a href="#是否使用仿真时间" class="headerlink" title="是否使用仿真时间"></a>是否使用仿真时间</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ rosparam get use_sim_timetrue$ rosparam set use_sim_time false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS自定义srv</title>
      <link href="2021/03/26/ROS-ROS%E8%87%AA%E5%AE%9A%E4%B9%89srv/"/>
      <url>2021/03/26/ROS-ROS%E8%87%AA%E5%AE%9A%E4%B9%89srv/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义-srv-消息"><a href="#自定义-srv-消息" class="headerlink" title="自定义 srv 消息"></a>自定义 srv 消息</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string name---int32 agebool sex<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改-CMakeLists-txt"><a href="#修改-CMakeLists-txt" class="headerlink" title="修改 CMakeLists.txt"></a>修改 CMakeLists.txt</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">add_service_files(  FILES  stu.srv)generate_messages(  DEPENDENCIES  std_msgs  std_srvs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;ros_learning&#x2F;stu.h&quot;using namespace std;&#x2F;&#x2F; 注意回调函数的参数写法bool stu_cb(ros_learning::stu::Request &amp;request, ros_learning::stu::Response &amp;response)&#123;    string input_name(request.name);    cout &lt;&lt; input_name &lt;&lt; endl;    response.age &#x3D; 20;    response.sex &#x3D; true;    return true;&#125;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;service&quot;);    ros::NodeHandle nh;    ros::ServiceServer service &#x3D; nh.advertiseService(&quot;look_up_stu&quot;, stu_cb);    ros::spin();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;ros_learning&#x2F;stu.h&quot;using namespace std;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;client&quot;);    ros::NodeHandle n;    ros::ServiceClient client &#x3D; n.serviceClient&lt;ros_learning::stu&gt;(&quot;look_up_stu&quot;);    ros_learning::stu srv;    string inputName;    while(ros::ok())    &#123;        cin &gt;&gt; inputName;        srv.request.name &#x3D; inputName;        if (!inputName.compare(&quot;exit&quot;))            return 0;         if (client.call(srv))        &#123;            cout &lt;&lt; &quot;name: &quot; &lt;&lt; srv.request.name &lt;&lt; endl;            cout &lt;&lt; &quot;age: &quot; &lt;&lt; srv.response.age &lt;&lt; endl;            cout &lt;&lt; &quot;sex: &quot; &lt;&lt; srv.response.sex &lt;&lt; endl;        &#125;                &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS自定义类</title>
      <link href="2021/03/26/ROS-ROS%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB/"/>
      <url>2021/03/26/ROS-ROS%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#ifndef EXAMPLE_H_#define EXAMPLE_H_#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;ros&#x2F;ros.h&gt; #include &lt;std_msgs&#x2F;Bool.h&gt;#include &lt;std_msgs&#x2F;Float32.h&gt;#include &lt;std_srvs&#x2F;Trigger.h&gt; &#x2F;&#x2F; rossrv show std_msgs&#x2F;Trigger&#x2F;&#x2F; bool success&#x2F;&#x2F; string messageclass Example&#123;public:    Example(ros::NodeHandle* nodehandle);   &#x2F;&#x2F; 构造函数，传句柄地址private:    ros::NodeHandle nh_;     ros::Subscriber minimal_subscriber_;    ros::ServiceServer minimal_service_;    ros::Publisher  minimal_publisher_;        double val_from_subscriber_;     double val_to_remember_;         void initializeSubscribers();   &#x2F;&#x2F; 初始化订阅者成员函数    void initializePublishers();    &#x2F;&#x2F; 初始化发布者成员函数    void initializeServices();      &#x2F;&#x2F; 初始化服务端成员函数        &#x2F;&#x2F; 回调函数    void subscriberCallback(const std_msgs::Float32 &amp;msg);     bool serviceCallback(std_srvs::Trigger::Request &amp;request, std_srvs::Trigger::Response &amp;response);&#125;;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;Example.h&quot;Example::Example(ros::NodeHandle* nodehandle) : nh_(*nodehandle)&#123;    ROS_INFO(&quot;in class constructor of Example&quot;);    initializeSubscribers();     initializePublishers();    initializeServices();&#125;void Example::initializeSubscribers()&#123;    ROS_INFO(&quot;Initializing Subscribers&quot;);    minimal_subscriber_ &#x3D; nh_.subscribe(&quot;input_topic&quot;, 1, &amp;Example::subscriberCallback, this);    &#x2F;&#x2F;函数指针和this指针&#125;void Example::initializePublishers()&#123;    ROS_INFO(&quot;Initializing Publishers&quot;);    minimal_publisher_ &#x3D; nh_.advertise&lt;std_msgs::Float32&gt;(&quot;output_topic&quot;, 1, true);&#125;void Example::initializeServices()&#123;    ROS_INFO(&quot;Initializing Services&quot;);    minimal_service_ &#x3D; nh_.advertiseService(&quot;service&quot;, &amp;Example::serviceCallback, this);&#125;void Example::subscriberCallback(const std_msgs::Float32 &amp;msg)&#123;    val_from_subscriber_ &#x3D; msg.data;    ROS_INFO(&quot;Receive message: %f&quot;, msg.data);       val_to_remember_ +&#x3D; val_from_subscriber_;    std_msgs::Float32 output_msg;    output_msg.data &#x3D; val_to_remember_;    minimal_publisher_.publish(output_msg);&#125;bool Example::serviceCallback(std_srvs::Trigger::Request &amp;request, std_srvs::Trigger::Response &amp;response)&#123;    ROS_INFO(&quot;service callback&quot;);    response.success &#x3D; true;    response.message &#x3D; &quot;response message&quot;;&#125;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;Example&quot;);    ros::NodeHandle nh;    Example example(&amp;nh);   &#x2F;&#x2F; 构造函数的参数是句柄地址    ros::spin();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="生成库文件"><a href="#生成库文件" class="headerlink" title="生成库文件"></a>生成库文件</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">add_libraries(Example src&#x2F;Example.cpp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="可执行文件链接库"><a href="#可执行文件链接库" class="headerlink" title="可执行文件链接库"></a>可执行文件链接库</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">add_executable(test_node src&#x2F;test.cpp)target_link_libraries(test_node Example)    &#x2F;&#x2F; 添加自定义库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS话题通信</title>
      <link href="2021/03/26/ROS-ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/"/>
      <url>2021/03/26/ROS-ROS%E8%AF%9D%E9%A2%98%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="容易出错的地方"><a href="#容易出错的地方" class="headerlink" title="容易出错的地方"></a>容易出错的地方</h2><h3 id="链接catkin的库"><a href="#链接catkin的库" class="headerlink" title="链接catkin的库"></a>链接catkin的库</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">target_link_libraries(main $&#123;catkin_LIBRARIES&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="使用自定义头文件，前面加包名"><a href="#使用自定义头文件，前面加包名" class="headerlink" title="使用自定义头文件，前面加包名"></a>使用自定义头文件，前面加包名</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;package_name&#x2F;xxx.h&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h3><p>如果有自定义类，需要包含头文件和链接库</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 头文件位置include_libraries(include)&#x2F;&#x2F; 添加库文件add_libraries(Student STATIC src&#x2F;Student.cpp)&#x2F;&#x2F; 链接target_link_libraries(main Student)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="std-msgs的数据类型"><a href="#std-msgs的数据类型" class="headerlink" title="std_msgs的数据类型"></a>std_msgs的数据类型</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;std_msgs&#x2F;Float64.h&gt;float64 data#include &lt;std_msgs&#x2F;Float64MultiArray.h&gt;float64[] data  &#x2F;&#x2F; 这种可变数组就相当于vector<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="发布者-talker"><a href="#发布者-talker" class="headerlink" title="发布者 talker"></a>发布者 talker</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;talker&quot;);    &#x2F;&#x2F; 节点名    ros::NodeHandle n;                  &#x2F;&#x2F; 句柄    ros::Publisher pub &#x3D; n.advertise&lt;std_msgs::Float64&gt;(&quot;chatting&quot;, 10);    &#x2F;&#x2F; 往chatting话题上发消息，数据类型是std_msgs::Float64    std_msgs::Float64 input;    input.data &#x3D; 0.0;    ros::Rate loop_rate(1);     &#x2F;&#x2F; 1s发一次    while(ros::ok())    &#123;        input.data +&#x3D; 0.1;        pub.publish(input);        loop_rate.sleep();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不同数据类型<code>std_msgs::Float64MultiArray</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;talker&quot;);    ros::NodeHandle n;    ros::Publisher pub &#x3D; n.advertise&lt;std_msgs::Float64MultiArray&gt;(&quot;chatting&quot;, 10);    ros::Rate loop_rate(1);    double arr[3] &#x3D; &#123;14, 15, 16&#125;;    std::vector&lt;double&gt; vi(arr, arr+3);     &#x2F;&#x2F; float64就是double    std_msgs::Float64MultiArray input_float;    input_float.data &#x3D; vi;    while(ros::ok())    &#123;        for (auto&amp; i : input_float.data)            std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;        std::cout &lt;&lt; std::endl;        pub.publish(input_float);        loop_rate.sleep();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="订阅者-listener"><a href="#订阅者-listener" class="headerlink" title="订阅者 listener"></a>订阅者 listener</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void chatting_cb(const std_msgs::Float64::ConstPtr&amp; message)&#123;    ROS_INFO(&quot;I receive the number: %f&quot;, message-&gt;data);&#125;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;listener&quot;);    ros::NodeHandle n;    ros::Subscribe sub &#x3D; n.subscribe(&quot;chatting&quot;, 1, chatting_cb);    ros::spin();    &#x2F;&#x2F; 阻塞&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CMakeLists-txt-1"><a href="#CMakeLists-txt-1" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cmake_minimum_required(VERSION 3.0.2)project(learning_communication)find_package(catkin REQUIRED COMPONENTS  roscpp  rospy  std_msgs)catkin_package()include_directories(  include  $&#123;catkin_INCLUDE_DIRS&#125;)add_executable(talker src&#x2F;talker.cpp)target_link_libraries(talker $&#123;catkin_LIBRARIES&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="发布者"><a href="#发布者" class="headerlink" title="发布者"></a>发布者</h3><pre class="line-numbers language-py" data-language="py"><code class="language-py">#! &#x2F;usr&#x2F;bin&#x2F;env python# -*- coding: utf-8 -*-import rospyfrom std_msgs.msg import Stringfrom test_msgs.msg import Positiondef talker():    rospy.init_node(&#39;py_talker&#39;, anonymous&#x3D;True)    Pos_pub &#x3D; rospy.Publisher(&#39;&#x2F;test&#x2F;Position&#39;, Position, queue_size&#x3D;10)    rate &#x3D; rospy.Rate(10)    pos &#x3D; Position()    pos.x &#x3D; 10    pos.y &#x3D; 20    while not rospy.is_shutdown():        pos.x +&#x3D; 1        pos.y +&#x3D; 2        rospy.loginfo(pos)        Pos_pub.publish(pos)        rate.sleep()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    try:        talker()    except rospy.ROSInterruptException:pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="订阅者"><a href="#订阅者" class="headerlink" title="订阅者"></a>订阅者</h3><pre class="line-numbers language-py" data-language="py"><code class="language-py">#! &#x2F;usr&#x2F;bin&#x2F;env python# -*- coding: utf-8 -*-import rospyfrom test_msgs.msg import Positiondef callback(msg):    rospy.loginfo(&#39;Receive: %f, %f&#39;, msg.x, msg.y)def listener():    rospy.init_node(&#39;py_listener&#39;, anonymous&#x3D;True)    rospy.Subscriber(&#39;&#x2F;test&#x2F;Position&#39;, Position, callback)    rospy.spin()if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    try:        listener()    except rospy.ROSInitException:pass<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4</title>
      <link href="2021/03/26/%E5%A4%9A%E6%97%8B%E7%BF%BC-PX4/"/>
      <url>2021/03/26/%E5%A4%9A%E6%97%8B%E7%BF%BC-PX4/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><h2 id="关于PX4的一些基本概念"><a href="#关于PX4的一些基本概念" class="headerlink" title="关于PX4的一些基本概念"></a>关于PX4的一些基本概念</h2><ul><li><code>PX4</code>是一套开源的飞控套件，许多无人机的飞控系统都是基于<code>PX4</code>构建的</li><li><code>MAVLink</code>是一种常用的通信协议，常用于无人机于地面站<code>(Ground Control Station)</code>或无人机之间的通讯</li><li><code>OFFBOARD</code>控制：<code>PX4</code>仅仅执行飞行姿态等与飞行相关的控制，初次之外的其他控制(如视觉导航)由外部程序进行</li></ul><h2 id="ROS、PX4和它们之间的关系"><a href="#ROS、PX4和它们之间的关系" class="headerlink" title="ROS、PX4和它们之间的关系"></a>ROS、PX4和它们之间的关系</h2><ul><li><code>SITL</code>即<code>Software In The Loop</code>，指的是使用软件飞控进行模拟飞行——<code>PX4</code>飞控运行在<code>PC</code>上</li><li>与之对应的是<code>HITL</code>，<code>Hardware In The Loop</code>，即使用单独的飞控硬件执行模拟</li><li>无人机可以使用专业的飞行遥控器进行控制，也可以使用软件在<code>PC</code>或手机上进行控制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多旋翼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4_pos_estimator</title>
      <link href="2021/03/26/%E5%A4%9A%E6%97%8B%E7%BF%BC-PX4-pos-estimator/"/>
      <url>2021/03/26/%E5%A4%9A%E6%97%8B%E7%BF%BC-PX4-pos-estimator/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int input_source;float rate_hz;Eigen::Vector3f pos_offset;float yaw_offset;string object_name;ros::Time last_timestamp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="laser定位相关"><a href="#laser定位相关" class="headerlink" title="laser定位相关"></a>laser定位相关</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen::Vector3d pos_drone_laser; &#x2F;&#x2F;无人机当前位置 (laser)Eigen::Quaterniond q_laser;Eigen::Vector3d Euler_laser; &#x2F;&#x2F;无人机当前姿态(laser)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="T265"><a href="#T265" class="headerlink" title="T265"></a>T265</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen::Vector3d pos_drone_t265;Eigen::Quaterniond q_t265;Eigen::Vector3d Euler_t265;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="gazebo真值相关"><a href="#gazebo真值相关" class="headerlink" title="gazebo真值相关"></a>gazebo真值相关</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen::Vector3d pos_drone_gazebo;Eigen::Quaterniond q_gazebo;Eigen::Vector3d Euler_gazebo;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="SLAM相关"><a href="#SLAM相关" class="headerlink" title="SLAM相关"></a>SLAM相关</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen::Vector3d pos_drone_slam;Eigen::Quaterniond q_slam;Eigen::Vector3d Euler_slam;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="发布相关变量"><a href="#发布相关变量" class="headerlink" title="发布相关变量"></a>发布相关变量</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">geometry_msgs::TransformStamped laser; &#x2F;&#x2F;当前时刻cartorgrapher发布的数据ros::Publisher vision_pub;ros::Publisher drone_state_pub;ros::Publisher message_pub;ros::Publisher odom_pub;ros::Publisher trajectory_pub;prometheus_msgs::Message message;prometheus_msgs::DroneState Drone_State;nav_msgs::Odometry Drone_odom;std::vector&lt;geometry_msgs::PoseStamped&gt; posehistory_vector_;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::init(argc, argv, &quot;px4_pos_estimator&quot;);ros::NodeHandle nh(&quot;~&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="读取参数表中的参数"><a href="#读取参数表中的参数" class="headerlink" title="读取参数表中的参数"></a>读取参数表中的参数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;读取参数表中的参数&#x2F;&#x2F; 定位数据输入源 0 for vicon， 1 for 激光SLAM, 2 for gazebo ground truth, 3 for T265 ,  9 for outdoor nh.param&lt;int&gt;(&quot;input_source&quot;, input_source, 0);&#x2F;&#x2F;　程序执行频率nh.param&lt;float&gt;(&quot;rate_hz&quot;, rate_hz, 20);&#x2F;&#x2F;　定位设备偏移量nh.param&lt;float&gt;(&quot;offset_x&quot;, pos_offset[0], 0);nh.param&lt;float&gt;(&quot;offset_y&quot;, pos_offset[1], 0);nh.param&lt;float&gt;(&quot;offset_z&quot;, pos_offset[2], 0);nh.param&lt;float&gt;(&quot;offset_yaw&quot;, yaw_offset, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 【订阅】cartographer估计位置ros::Subscriber laser_sub &#x3D; nh.subscribe&lt;tf2_msgs::TFMessage&gt;(&quot;&#x2F;tf&quot;, 100, laser_cb);&#x2F;&#x2F; 【订阅】t265估计位置ros::Subscriber t265_sub &#x3D; nh.subscribe&lt;nav_msgs::Odometry&gt;(&quot;&#x2F;t265&#x2F;odom&#x2F;sample&quot;, 100, t265_cb);&#x2F;&#x2F; 【订阅】gazebo仿真真值ros::Subscriber gazebo_sub &#x3D; nh.subscribe&lt;nav_msgs::Odometry&gt;(&quot;&#x2F;prometheus&#x2F;ground_truth&#x2F;p300_basic&quot;, 100, gazebo_cb);&#x2F;&#x2F; 【订阅】SLAM估计位姿ros::Subscriber slam_sub &#x3D; nh.subscribe&lt;geometry_msgs::PoseStamped&gt;(&quot;&#x2F;slam&#x2F;pose&quot;, 100, slam_cb);&#x2F;&#x2F; 10秒定时打印，以确保程序在正确运行ros::Timer timer &#x3D; nh.createTimer(ros::Duration(10.0), timerCallback);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><h4 id="laser-cb"><a href="#laser-cb" class="headerlink" title="laser_cb"></a>laser_cb</h4><h4 id="gazebo-cb"><a href="#gazebo-cb" class="headerlink" title="gazebo_cb"></a>gazebo_cb</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pos_drone_gazebo &#x3D; Eigen::Vector3d(msg-&gt;pose.pose.position.x, msg-&gt;pose.pose.position.y, msg-&gt;pose.pose.position.z);q_gazebo &#x3D; Eigen::Quaterniond(msg-&gt;pose.pose.oriention.w, msg-&gt;pose.pose.oriention.x, msg-&gt;pose.pose.oriention.y, msg-&gt;pose.pose.oriention.z);Euler_gazebo &#x3D; quaterniond_to_euler(q_gazebo);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="slam-cb"><a href="#slam-cb" class="headerlink" title="slam_cb"></a>slam_cb</h4><h4 id="t265-cb"><a href="#t265-cb" class="headerlink" title="t265_cb"></a>t265_cb</h4><h4 id="timerCallback"><a href="#timerCallback" class="headerlink" title="timerCallback"></a>timerCallback</h4><h3 id="用于与mavros通讯的类，通过mavros接收来至飞控的消息【飞控-gt-mavros-gt-本程序】"><a href="#用于与mavros通讯的类，通过mavros接收来至飞控的消息【飞控-gt-mavros-gt-本程序】" class="headerlink" title="用于与mavros通讯的类，通过mavros接收来至飞控的消息【飞控-&gt;mavros-&gt;本程序】"></a>用于与mavros通讯的类，通过mavros接收来至飞控的消息【飞控-&gt;mavros-&gt;本程序】</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">state_from_mavros _state_from_mavros;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="state-from-mavros订阅的话题"><a href="#state-from-mavros订阅的话题" class="headerlink" title="state_from_mavros订阅的话题"></a>state_from_mavros订阅的话题</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 【订阅】无人机当前状态 - 来自飞控state_sub &#x3D; state_nh.subscribe&lt;mavros_msgs::State&gt;(uav_name + &quot;&#x2F;mavros&#x2F;state&quot;, 10, &amp;state_from_mavros::state_cb,this);&#x2F;&#x2F; 【订阅】无人机当前状态 - 来自飞控extended_state_sub &#x3D; state_nh.subscribe&lt;mavros_msgs::ExtendedState&gt;(uav_name + &quot;&#x2F;mavros&#x2F;extended_state&quot;, 10, &amp;state_from_mavros::extended_state_cb,this);&#x2F;&#x2F; 【订阅】无人机当前位置 坐标系:ENU系 （此处注意，所有状态量在飞控中均为NED系，但在ros中mavros将其转换为ENU系处理。所以，在ROS中，所有和mavros交互的量都为ENU系）position_sub &#x3D; state_nh.subscribe&lt;geometry_msgs::PoseStamped&gt;(uav_name + &quot;&#x2F;mavros&#x2F;local_position&#x2F;pose&quot;, 10, &amp;state_from_mavros::pos_cb,this);&#x2F;&#x2F; 【订阅】无人机当前速度 坐标系:ENU系velocity_sub &#x3D; state_nh.subscribe&lt;geometry_msgs::TwistStamped&gt;(uav_name + &quot;&#x2F;mavros&#x2F;local_position&#x2F;velocity_local&quot;, 10, &amp;state_from_mavros::vel_cb,this);&#x2F;&#x2F; 【订阅】无人机当前欧拉角 坐标系:ENU系attitude_sub &#x3D; state_nh.subscribe&lt;sensor_msgs::Imu&gt;(uav_name + &quot;&#x2F;mavros&#x2F;imu&#x2F;data&quot;, 10, &amp;state_from_mavros::att_cb,this); &#x2F;&#x2F; 【订阅】无人机相对高度 此订阅仅针对户外实验alt_sub &#x3D; state_nh.subscribe&lt;std_msgs::Float64&gt;(uav_name + &quot;&#x2F;mavros&#x2F;global_position&#x2F;rel_alt&quot;, 10, &amp;state_from_mavros::alt_cb,this);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h3><h4 id="send-to-fcu"><a href="#send-to-fcu" class="headerlink" title="send_to_fcu();"></a><code>send_to_fcu();</code></h4><ul><li>将采集的机载设备的定位信息及偏航角信息发送至飞控，根据参数<code>input_source</code>选择定位信息来源</li></ul><h4 id="pub-to-nodes-state-from-mavros-DroneState"><a href="#pub-to-nodes-state-from-mavros-DroneState" class="headerlink" title="pub_to_nodes(_state_from_mavros._DroneState);"></a><code>pub_to_nodes(_state_from_mavros._DroneState);</code></h4><ul><li>发布无人机状态至其他节点  </li><li>发布无人机当前<code>odometry</code>,用于导航及<code>rviz</code>显示</li><li>发布无人机运动轨迹，用于<code>rviz</code>显示<center><img src="/2021/03/26/%E5%A4%9A%E6%97%8B%E7%BF%BC-PX4-pos-estimator/PX4.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">rqt_graph</div></center></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多旋翼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4_sender</title>
      <link href="2021/03/26/%E5%A4%9A%E6%97%8B%E7%BF%BC-PX4-sender/"/>
      <url>2021/03/26/%E5%A4%9A%E6%97%8B%E7%BF%BC-PX4-sender/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">float cur_time;         &#x2F;&#x2F;程序运行时间float Takeoff_height;   &#x2F;&#x2F;默认起飞高度float Disarm_height;    &#x2F;&#x2F;自动上锁高度float Land_speed;       &#x2F;&#x2F;降落速度int Land_mode;          &#x2F;&#x2F;降落策略选择Eigen::Vector2f geo_fence_x;        &#x2F;&#x2F;地理围栏Eigen::Vector2f geo_fence_y;Eigen::Vector2f geo_fence_z;Eigen::Vector3d Takeoff_position;   &#x2F;&#x2F; 起飞位置prometheus_msgs::DroneState _DroneState;    &#x2F;&#x2F;无人机状态量prometheus_msgs::ControlCommand Command_Now;    &#x2F;&#x2F;无人机当前执行命令prometheus_msgs::ControlCommand Command_Last;   &#x2F;&#x2F;无人机上一条执行命令Eigen::Vector3d state_sp(0,0,0);Eigen::Vector3d state_sp_extra(0,0,0);double yaw_sp;double yaw_rate_sp;prometheus_msgs::Message message;prometheus_msgs::LogMessageControl LogMessage;&#x2F;&#x2F;RVIZ显示：期望位置geometry_msgs::PoseStamped ref_pose_rviz;float dt &#x3D; 0;ros::Publisher rivz_ref_pose_pub;ros::Publisher message_pub;ros::Publisher log_message_pub;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 【订阅】为任务模块生成的控制指令(来自terminal_control.cpp)ros::Subscriber Command_sub &#x3D; nh.subscribe&lt;prometheus_msgs::ControlCommand&gt;(&quot;&#x2F;prometheus&#x2F;control_command&quot;, 10, Command_cb);&#x2F;&#x2F; 本话题为Prometheus地面站发送的控制指令ros::Subscriber station_command_sub &#x3D; nh.subscribe&lt;prometheus_msgs::ControlCommand&gt;(&quot;&#x2F;prometheus&#x2F;control_command_station&quot;, 10, station_command_cb);&#x2F;&#x2F;【订阅】无人机状态(来自px4_pos_estimator.cpp)ros::Subscriber drone_state_sub &#x3D; nh.subscribe&lt;prometheus_msgs::DroneState&gt;(&quot;&#x2F;prometheus&#x2F;drone_state&quot;, 10, drone_state_cb);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 【发布】参考位姿 RVIZ显示用rivz_ref_pose_pub &#x3D; nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;&#x2F;prometheus&#x2F;control&#x2F;ref_pose_rviz&quot;, 10);&#x2F;&#x2F; 【发布】用于地面站显示的提示消息message_pub &#x3D; nh.advertise&lt;prometheus_msgs::Message&gt;(&quot;&#x2F;prometheus&#x2F;message&#x2F;main&quot;, 10);&#x2F;&#x2F; 【发布】用于log的消息log_message_pub &#x3D; nh.advertise&lt;prometheus_msgs::LogMessageControl&gt;(&quot;&#x2F;prometheus&#x2F;log&#x2F;control&quot;, 10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 参数读取nh.param&lt;float&gt;(&quot;Takeoff_height&quot;, Takeoff_height, 1.0);nh.param&lt;float&gt;(&quot;Disarm_height&quot;, Disarm_height, 0.15);nh.param&lt;float&gt;(&quot;Land_speed&quot;, Land_speed, 0.2);nh.param&lt;int&gt;(&quot;Land_mode&quot;,Land_mode,0);nh.param&lt;float&gt;(&quot;geo_fence&#x2F;x_min&quot;, geo_fence_x[0], -100.0);nh.param&lt;float&gt;(&quot;geo_fence&#x2F;x_max&quot;, geo_fence_x[1], 100.0);nh.param&lt;float&gt;(&quot;geo_fence&#x2F;y_min&quot;, geo_fence_y[0], -100.0);nh.param&lt;float&gt;(&quot;geo_fence&#x2F;y_max&quot;, geo_fence_y[1], 100.0);nh.param&lt;float&gt;(&quot;geo_fence&#x2F;z_min&quot;, geo_fence_z[0], -100.0);nh.param&lt;float&gt;(&quot;geo_fence&#x2F;z_max&quot;, geo_fence_z[1], 100.0);&#x2F;&#x2F; 设定起飞位置Takeoff_position[0] &#x3D; 0.0;Takeoff_position[1] &#x3D; 0.0;Takeoff_position[2] &#x3D; 0.15;&#x2F;&#x2F; 建议控制频率: 10 - 50Hz, 控制频率取决于控制形式，若控制方式为速度或加速度应适当提高频率ros::Rate rate(20.0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="用于与mavros通讯的类，通过mavros发送控制指令至飞控【本程序-gt-mavros-gt-飞控】"><a href="#用于与mavros通讯的类，通过mavros发送控制指令至飞控【本程序-gt-mavros-gt-飞控】" class="headerlink" title="用于与mavros通讯的类，通过mavros发送控制指令至飞控【本程序-&gt;mavros-&gt;飞控】"></a>用于与mavros通讯的类，通过mavros发送控制指令至飞控【本程序-&gt;mavros-&gt;飞控】</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">command_to_mavros _command_to_mavros;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 【订阅】无人机期望位置&#x2F;速度&#x2F;加速度 坐标系:ENU系 本话题来自飞控position_target_sub &#x3D; command_nh.subscribe&lt;mavros_msgs::PositionTarget&gt;(uav_name + &quot;&#x2F;mavros&#x2F;setpoint_raw&#x2F;target_local&quot;, 10, &amp;command_to_mavros::pos_target_cb,this);&#x2F;&#x2F; 【订阅】无人机期望角度&#x2F;角速度 坐标系:ENU系 本话题来自飞控attitude_target_sub &#x3D; command_nh.subscribe&lt;mavros_msgs::AttitudeTarget&gt;(uav_name + &quot;&#x2F;mavros&#x2F;setpoint_raw&#x2F;target_attitude&quot;, 10, &amp;command_to_mavros::att_target_cb,this);&#x2F;&#x2F; 【发布】位置&#x2F;速度&#x2F;加速度期望值至飞控 坐标系 ENU系advertise&lt;mavros_msgs::PositionTarget&gt;(uav_name + &quot;&#x2F;mavros&#x2F;setpoint_raw&#x2F;local&quot;, 10);&#x2F;&#x2F; 【发布】角度&#x2F;角速度期望值至飞控 坐标系 ENU系setpoint_raw_attitude_pub &#x3D; command_nh.advertise&lt;mavros_msgs::AttitudeTarget&gt;(uav_name + &quot;&#x2F;mavros&#x2F;setpoint_raw&#x2F;attitude&quot;, 10);&#x2F;&#x2F; 【发布】底层控制量（Mx My Mz 及 F） [0][1][2][3]分别对应 roll pitch yaw控制量及油门推力注意这里是NED系的！！actuator_setpoint_pub &#x3D; command_nh.advertise&lt;mavros_msgs::ActuatorControl&gt;(uav_name + &quot;&#x2F;mavros&#x2F;actuator_control&quot;, 10);&#x2F;&#x2F; 【发布】本话题要发送至飞控(通过Mavros_extra功能包 &#x2F;plugins&#x2F;mount_control.cpp发送)mount_control_pub &#x3D; command_nh.advertise&lt;mavros_msgs::MountControl&gt;(uav_name + &quot;&#x2F;mavros&#x2F;mount_control&#x2F;command&quot;, 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h2><ul><li><p>Idle</p></li><li><p>Takeoff</p></li><li><p>Hold</p></li><li><p>Land</p></li><li><p>Move</p></li><li><p>Disarm</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 多旋翼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus</title>
      <link href="2021/03/26/%E5%A4%9A%E6%97%8B%E7%BF%BC-Prometheus/"/>
      <url>2021/03/26/%E5%A4%9A%E6%97%8B%E7%BF%BC-Prometheus/</url>
      
        <content type="html"><![CDATA[<h2 id="Control模块"><a href="#Control模块" class="headerlink" title="Control模块"></a>Control模块</h2><ul><li><code>Idle</code>：怠速；意思就是飞机会进入offboard模式，但是在该模式下，没有对飞机进行任何指令的发送。飞机也不会有任何动作。这个指令一般也可以不用。</li><li><code>Takeoff</code>：起飞；起飞点为当前点，起飞高度通过 yaml参数设置，单位是米，默认起飞高度是0.5m</li><li><code>Hold</code>：悬停；飞机正在飞行过程中如果接受到 2 指令，会在当前时刻进入悬停状态。</li><li><code>Land</code>：降落；降落速度通过 yaml参数设置，单位是m/s ，默认降落速度为0.2m/s 。还有一个 上锁高度 到达上锁高度之后飞机会进入飞控的本身降落模式进而缓缓着地，上锁高度通过 yaml 参数进行设置，单位是米，默认是 0.18m，即认为离地不到20cm的时候进入飞控本身的降落飞行模式。</li><li><code>Move</code>模式；该模式就包含我们所称的指点飞行功能，在此模式下，又有5种子模式，</li><li><code>XYZ_POS</code>, 空间位置控制</li><li><code>XY_POS_Z_VEL</code>, 水平面位置控制高度速度控制</li><li><code>XY_VEL_Z_POS</code>, 水平面速度控制高度定高控制</li><li><code>XYZ_VEL</code>, 空间速度控制</li><li><code>TRAJECTORY</code>, 轨迹跟踪控制</li></ul><h2 id="Common模块"><a href="#Common模块" class="headerlink" title="Common模块"></a>Common模块</h2><p>公用模块中比较核心的就是自定义的<code>msg</code>消息</p><ul><li><code>ControlCommand.msg</code>：控制无人机指令的msg格式，掌握API首先掌握msg定义</li><li><code>DetectionInfo.msg</code>：目标检测模块的输出结果</li><li><code>DroneState.msg</code>：无人机当下各个状态信息（与板载计算机是否通信连接，解锁或者上锁，当前飞行模式，当前的状态量位置速度加速度及姿态）</li><li><code>LogMessageControl.msg</code>：控制端的日志打印信息记录</li></ul>]]></content>
      
      
      <categories>
          
          <category> 多旋翼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus_msgs</title>
      <link href="2021/03/26/%E5%A4%9A%E6%97%8B%E7%BF%BC-Prometheus-msg/"/>
      <url>2021/03/26/%E5%A4%9A%E6%97%8B%E7%BF%BC-Prometheus-msg/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="prometheus-msgs-DroneState"><a href="#prometheus-msgs-DroneState" class="headerlink" title="prometheus_msgs/DroneState"></a>prometheus_msgs/DroneState</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ rosmsg show prometheus_msgs&#x2F;DroneState std_msgs&#x2F;Header header  uint32 seq  time stamp  string frame_idstring mode     &#x2F;&#x2F; 模式选择，来自&quot;&#x2F;mavros&#x2F;state&quot;话题，类型是mavros_msgs::Statebool connected  &#x2F;&#x2F; 是否连接，来自&quot;&#x2F;mavros&#x2F;state&quot;话题，类型是mavros_msgs::Statebool armed      &#x2F;&#x2F; 是否解锁，来自&quot;&#x2F;mavros&#x2F;state&quot;话题，类型是mavros_msgs::Statebool landed     &#x2F;&#x2F; 是否降落，来自&quot;&#x2F;mavros&#x2F;extended_state&quot;，类型是mavros_msgs::ExtendedStatefloat32 time_from_startfloat32[3] position &#x2F;&#x2F; 位置，来自&quot;&#x2F;mavros&#x2F;local_position&#x2F;pose&quot;，类型是geometry_msgs::PoseStampedfloat32 rel_altfloat32[3] velocity &#x2F;&#x2F; 速度，来自&quot;&#x2F;mavros&#x2F;local_position&#x2F;velocity_local&quot;，类型是geometry_msgs::TwistStampedfloat32[3] attitude &#x2F;&#x2F; 姿态欧拉角，来自&quot;&#x2F;mavros&#x2F;Imu&#x2F;data&quot;，由四元数转换而来geometry_msgs&#x2F;Quaternion attitude_q &#x2F;&#x2F;姿态四元数，来自&quot;&#x2F;mavros&#x2F;Imu&#x2F;data&quot;，类型是sensor_msgs::Imu里面的orientation  float64 x  float64 y  float64 z  float64 wfloat32[3] attitude_rate    &#x2F;&#x2F; 角速度，来自&quot;&#x2F;mavros&#x2F;Imu&#x2F;data&quot;，类型是sensor_msgs::Imu里面的angular_velocity<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="prometheus-msgs-Message"><a href="#prometheus-msgs-Message" class="headerlink" title="prometheus_msgs/Message"></a>prometheus_msgs/Message</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ rosmsg show prometheus_msgs&#x2F;Message std_msgs&#x2F;Header header  uint32 seq  time stamp  string frame_iduint8 message_type          &#x2F;&#x2F; 节点回传地面站的消息uint8 NORMAL&#x3D;0              &#x2F;&#x2F; enum message_typeuint8 WARN&#x3D;1uint8 ERROR&#x3D;2string source_nodestring content$ rosmsg show nav_msgs&#x2F;Odometry std_msgs&#x2F;Header header  uint32 seq  time stamp  string frame_idstring child_frame_idgeometry_msgs&#x2F;PoseWithCovariance pose  geometry_msgs&#x2F;Pose pose    geometry_msgs&#x2F;Point position      float64 x      float64 y      float64 z    geometry_msgs&#x2F;Quaternion orientation      float64 x      float64 y      float64 z      float64 w  float64[36] covariancegeometry_msgs&#x2F;TwistWithCovariance twist  geometry_msgs&#x2F;Twist twist    geometry_msgs&#x2F;Vector3 linear      float64 x      float64 y      float64 z    geometry_msgs&#x2F;Vector3 angular      float64 x      float64 y      float64 z  float64[36] covariance<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="prometheus-msgs-ControlCommand"><a href="#prometheus-msgs-ControlCommand" class="headerlink" title="prometheus_msgs/ControlCommand"></a>prometheus_msgs/ControlCommand</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ rosmsg show prometheus_msgs&#x2F;ControlCommand uint8 Idle&#x3D;0uint8 Takeoff&#x3D;1uint8 Hold&#x3D;2uint8 Land&#x3D;3uint8 Move&#x3D;4uint8 Disarm&#x3D;5uint8 User_Mode1&#x3D;6uint8 User_Mode2&#x3D;7std_msgs&#x2F;Header header  uint32 seq  time stamp  string frame_iduint32 Command_IDstring sourceuint8 Modeprometheus_msgs&#x2F;PositionReference Reference_State  uint8 XYZ_POS&#x3D;0  uint8 XY_POS_Z_VEL&#x3D;1  uint8 XY_VEL_Z_POS&#x3D;2  uint8 XYZ_VEL&#x3D;3  uint8 XYZ_ACC&#x3D;4  uint8 TRAJECTORY&#x3D;5  uint8 ENU_FRAME&#x3D;0  uint8 BODY_FRAME&#x3D;1  uint8 MIX_FRAME&#x3D;2  std_msgs&#x2F;Header header    uint32 seq    time stamp    string frame_id  uint8 Move_mode  uint8 Move_frame  float32 time_from_start  float32[3] position_ref  float32[3] velocity_ref  float32[3] acceleration_ref  bool Yaw_Rate_Mode  float32 yaw_ref  float32 yaw_rate_ref<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="prometheus-msgs-PositionReference"><a href="#prometheus-msgs-PositionReference" class="headerlink" title="prometheus_msgs/PositionReference"></a>prometheus_msgs/PositionReference</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ rosmsg show prometheus_msgs&#x2F;PositionReferenceuint8 XYZ_POS&#x3D;0uint8 XY_POS_Z_VEL&#x3D;1uint8 XY_VEL_Z_POS&#x3D;2uint8 XYZ_VEL&#x3D;3uint8 XYZ_ACC&#x3D;4uint8 TRAJECTORY&#x3D;5uint8 ENU_FRAME&#x3D;0uint8 BODY_FRAME&#x3D;1uint8 MIX_FRAME&#x3D;2std_msgs&#x2F;Header header  uint32 seq  time stamp  string frame_iduint8 Move_modeuint8 Move_framefloat32 time_from_startfloat32[3] position_reffloat32[3] velocity_reffloat32[3] acceleration_refbool Yaw_Rate_Modefloat32 yaw_reffloat32 yaw_rate_ref<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 多旋翼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多旋翼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针</title>
      <link href="2021/03/25/C-C-%E6%8C%87%E9%92%88/"/>
      <url>2021/03/25/C-C-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="指针大小"><a href="#指针大小" class="headerlink" title="指针大小"></a>指针大小</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    cout &lt;&lt; sizeof(int) &lt;&lt; endl;    cout &lt;&lt; sizeof(char) &lt;&lt; endl;        cout &lt;&lt; sizeof(int*) &lt;&lt; endl;    cout &lt;&lt; sizeof(char*) &lt;&lt; endl;    return 0;&#125;4188<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见不管是什么类型的指针，大小都是<strong>8个字节</strong></p><h2 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h2><h3 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h3><ol><li><code>const</code>修饰的是<code>int</code>，说明<code>int</code>是常量不可修改，不能通过指针修改他的值，但可以指向别处</li><li>指针指向的对象可以不是<code>const</code>，但是还是不能用指针去修改他，可以用其他方法修改</li><li>必须用<code>const void*</code>才能指向<code>const</code>对象</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int* pInteger;    &#x2F;&#x2F; int const* pInteger;int num &#x3D; 10;           &#x2F;&#x2F; 不是constpInteger &#x3D; &amp;num;&#x2F;&#x2F; *pInteger &#x3D; 100;&#x2F;&#x2F; error, 不能用指针修改常量num &#x3D; 20;               &#x2F;&#x2F; yes，可以用其他方法修改int another &#x3D; 100;pInteger &#x3D; &amp;another;    &#x2F;&#x2F; yes，可以改变指针指向<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const char ch &#x3D; &#39;a&#39;;&#x2F;&#x2F; void* p &#x3D; &amp;ch;   &#x2F;&#x2F;errorconst void* p &#x3D; &amp;ch;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="常指针、const指针"><a href="#常指针、const指针" class="headerlink" title="常指针、const指针"></a>常指针、const指针</h3><ol><li><code>const</code>修饰的是指针，说明指针是常数，所以他存储的地址不能变，也就是不能改变指向，可以通过指针改变指向对象的值</li><li>常指针必须进行初始化</li><li>常指针不能指向<code>const</code>变量</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int num &#x3D; 10;&#x2F;&#x2F; const int num &#x3D; 10;  &#x2F;&#x2F; error，const int* -&gt; int*int* const pInt &#x3D; &amp;num; int another &#x3D; 100;&#x2F;&#x2F; pInt &#x3D; &amp;another;     &#x2F;&#x2F; error, 常指针不能修改指向*pInt &#x3D; 100;            &#x2F;&#x2F; yes，变量不是const，可以改变他的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指向常量的常指针"><a href="#指向常量的常指针" class="headerlink" title="指向常量的常指针"></a>指向常量的常指针</h2><ul><li>只能指向<code>const</code>变量</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int num &#x3D; 10;const int* const ptr &#x3D; &amp;num;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMakeForOpenCV</title>
      <link href="2021/03/21/OpenCV-CMakeForOpenCV/"/>
      <url>2021/03/21/OpenCV-CMakeForOpenCV/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="g-编译-OpenCV"><a href="#g-编译-OpenCV" class="headerlink" title="g++ 编译 OpenCV"></a>g++ 编译 OpenCV</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ main.cpp -I D:&#x2F;software&#x2F;opencv&#x2F;opencv&#x2F;build&#x2F;x64&#x2F;mingw&#x2F;install&#x2F;include -L D:&#x2F;software&#x2F;opencv&#x2F;opencv&#x2F;build&#x2F;x64&#x2F;mingw&#x2F;install&#x2F;x64&#x2F;mingw&#x2F;lib -l libopencv_calib3d450 -l libopencv_core450 -l libopencv_dnn450 -l libopencv_features2d450 -l libopencv_flann450 -l libopencv_gapi450 -l libopencv_highgui450 -l libopencv_imgcodecs450 -l libopencv_imgproc450 -l libopencv_ml450 -l libopencv_objdetect450 -l libopencv_photo450 -l libopencv_stitching450 -l libopencv_video450 -l libopencv_videoio450 -l libopencv_world450 -o main.exe <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Ubuntu可以用-pkg-config"><a href="#Ubuntu可以用-pkg-config" class="headerlink" title="Ubuntu可以用 pkg_config"></a>Ubuntu可以用 pkg_config</h2><p><strong>查看OpenCV路径和库</strong><br><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pkg-config --cflags --libs opencv -I&#x2F;usr&#x2F;local&#x2F;include&#x2F;opencv -I&#x2F;usr&#x2F;local&#x2F;include -L&#x2F;usr&#x2F;local&#x2F;lib -lopencv_dnn -lopencv_ml -lopencv_objdetect -lopencv_shape -lopencv_stitching -lopencv_superres -lopencv_videostab -lopencv_calib3d -lopencv_features2d -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs -lopencv_video -lopencv_photo -lopencv_imgproc -lopencv_flann -lopencv_viz -lopencv_coreg++ main.cpp -o main &#96;pkg-config --cflags --libs opencv&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><h2 id="CMake-编译-OpenCV"><a href="#CMake-编译-OpenCV" class="headerlink" title="CMake 编译 OpenCV"></a>CMake 编译 OpenCV</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">find_package(OpenCV REQUIRED)message(&quot;$&#123;OpenCV_INCLUDE_DIRS&#125;&quot;)# &#x2F;usr&#x2F;local&#x2F;includemessage(&quot;$&#123;OpenCV_LIBRARY_DIRS&#125;&quot;)# &#x2F;usr&#x2F;local&#x2F;include&#x2F;opencvmessage(&quot;$&#123;OpenCV_LIBS&#125;&quot;)# opencv_calib3d;opencv_core;...set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125;&quot;)set(CMAKE_BUILD_TYPE Debug)# 头文件目录include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)# 库文件目录link_directories($&#123;OpenCV_LIBRARY_DIRS&#125;)add_executable(main main.cpp)#链接target_link_libraries(main $&#123;OpenCV_LIBS&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_1</title>
      <link href="2021/03/21/Eigen-Eigen-1/"/>
      <url>2021/03/21/Eigen-Eigen-1/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>(1) 矩阵类型</p><p><mark><strong>MatrixSizeType</strong></mark> where Size can be 2,3,4 for fixed size square matrices or X for dynamic size, and where Type can be i for integer, f for float, d for double, cf for complex float, cd for complex double.</p><p><code>Matrix3d</code>: <em>double</em> 3X3 方阵<br><code>MatrixXf</code>: <em>float</em> 动态大小</p><p>(2) 向量类型<br><mark><strong>VectorSizeType</strong></mark>: 列向量<br><mark><strong>RowVectorSizeType</strong></mark>: 行向量<br><code>Vector4f</code>: <em>float</em> 4行的列向量</p><h2 id="零矩阵"><a href="#零矩阵" class="headerlink" title="零矩阵"></a>零矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">MatrixXd::Zero(rows,cols)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="随机矩阵"><a href="#随机矩阵" class="headerlink" title="随机矩阵"></a>随机矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">MatrixXd::Random(rows,cols)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="常数矩阵"><a href="#常数矩阵" class="headerlink" title="常数矩阵"></a>常数矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">MatrixXd::Constant(rows,cols,constant)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">MatrixXd::Identity(rows,cols)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;Eigen&#x2F;Dense&gt;using namespace Eigen;using namespace std;int main() &#123;    Eigen::MatrixXd q &#x3D; Eigen::MatrixXd::Zero(2,2);    cout &lt;&lt; q &lt;&lt; endl;    # 0 0    # 0 0        q.resize(4,4);    &#x2F;&#x2F; 仅限于0矩阵，其他会出大问题    cout &lt;&lt; q.rows() &lt;&lt; endl;    &#x2F;&#x2F; 4    cout &lt;&lt; q.cols() &lt;&lt; endl;    &#x2F;&#x2F; 4    cout &lt;&lt; q &lt;&lt; endl;    # 0 0 0 0    # 0 0 0 0    # 0 0 0 0    # 0 0 0 0    MatrixXd m2 &#x3D; MatrixXd::Random(3, 3);    cout &lt;&lt; m2 &lt;&lt; endl;    # 0.680375 0.59688 -0.329554    # -0.211234 0.823295 0.536459    # 0.566198 -0.604897 -0.444451    MatrixXd m3 &#x3D; MatrixXd::Constant(3, 3, 1.2);    cout &lt;&lt; m3 &lt;&lt; endl;    # 1.2 1.2 1.2    # 1.2 1.2 1.2    # 1.2 1.2 1.2        VectorXd v(2);    v &lt;&lt; 1, 2;    cout &lt;&lt; v &lt;&lt; endl;    # 1    # 2        cout &lt;&lt; m*v &lt;&lt; endl;    &#x2F;&#x2F; 矩阵和向量相乘    # 5    # 11    MatrixXd m4 &#x3D; MatrixXd::Identity(3, 4);    &#x2F;&#x2F; 1 0 0 0    &#x2F;&#x2F; 0 1 0 0    &#x2F;&#x2F; 0 0 1 0    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_2</title>
      <link href="2021/03/21/Eigen-Eigen-2/"/>
      <url>2021/03/21/Eigen-Eigen-2/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix.transpose()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="共轭矩阵"><a href="#共轭矩阵" class="headerlink" title="共轭矩阵"></a>共轭矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix.conjugate()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="伴随矩阵-共轭转置"><a href="#伴随矩阵-共轭转置" class="headerlink" title="伴随矩阵(共轭转置)"></a>伴随矩阵(共轭转置)</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix.adjoint()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix.inverse()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix.block(i,j,p,q)&#x2F;&#x2F; 起始于(i,j),提取块大小为(p,q)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix.determinant()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;Eigen&#x2F;Dense&gt;using namespace Eigen;using namespace std;int main() &#123;    MatrixXd p(3, 3);    p &lt;&lt; 1, 2, 3,         4, 1, 6,         7, 8, 1;    cout &lt;&lt; p.transpose() &lt;&lt; endl;    &#x2F;&#x2F; 1 4 7    &#x2F;&#x2F; 2 1 8    &#x2F;&#x2F; 3 6 1    cout &lt;&lt; p.inverse() &lt;&lt; endl;    &#x2F;&#x2F; -0.451923   0.211538  0.0865385    &#x2F;&#x2F; 0.365385  -0.192308  0.0576923    &#x2F;&#x2F; 0.240385  0.0576923 -0.0673077    cout &lt;&lt; p.conjugate() &lt;&lt; endl;    &#x2F;&#x2F; 1 2 3    共轭矩阵，实数的共轭就是本身    &#x2F;&#x2F; 4 1 6    &#x2F;&#x2F; 7 8 1    cout &lt;&lt; p.adjoint() &lt;&lt; endl;    &#x2F;&#x2F; 1 4 7    伴随矩阵，转置+共轭    &#x2F;&#x2F; 2 1 8    &#x2F;&#x2F; 3 6 1    cout &lt;&lt; p.block(1,0,2,1) &lt;&lt; endl;    cout &lt;&lt; p.block&lt;2,1&gt;(1,0) &lt;&lt; endl;    &#x2F;&#x2F; 4    &#x2F;&#x2F; 7    cout &lt;&lt; p.determinant() &lt;&lt; endl;    &#x2F;&#x2F; 104    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_Quaternion</title>
      <link href="2021/03/21/Eigen-Eigen-Quaternion/"/>
      <url>2021/03/21/Eigen-Eigen-Quaternion/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="旋转向量到旋转矩阵"><a href="#旋转向量到旋转矩阵" class="headerlink" title="旋转向量到旋转矩阵"></a>旋转向量到旋转矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">double alpha &#x3D; M_PI &#x2F; 3;AngleAxisd rotation_vector(alpha, Vector3d(1, 0, 0));&#x2F;&#x2F; x轴: 1 0 0&#x2F;&#x2F; y轴: 0 1 0&#x2F;&#x2F; z轴: 0 0 1MatrixXd rotation_matrix;rotation_matrix &#x3D; rotation_vector.matrix();&#x2F;&#x2F; rotation_matrix &#x3D; rotation_vector.toRotationMatrix();cout &lt;&lt; rotation_matrix &lt;&lt; endl;&#x2F;&#x2F; 1         0         0&#x2F;&#x2F; 0       0.5 -0.866025&#x2F;&#x2F; 0  0.866025       0.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="旋转向量到欧拉角"><a href="#旋转向量到欧拉角" class="headerlink" title="旋转向量到欧拉角"></a>旋转向量到欧拉角</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3d eulerAngle &#x3D; rotation_vector.matrix().eulerAngles(2, 1, 0);&#x2F;&#x2F; ZYX: 2, 1, 0cout &lt;&lt; eulerAngle &lt;&lt; endl;&#x2F;&#x2F;      0&#x2F;&#x2F;     -0&#x2F;&#x2F; 1.0472<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="旋转向量到四元数"><a href="#旋转向量到四元数" class="headerlink" title="旋转向量到四元数"></a>旋转向量到四元数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Quaterniond quaternion(rotation_vector);cout &lt;&lt; quaternion.coeffs() &lt;&lt; endl;&#x2F;&#x2F;      0.5&#x2F;&#x2F;        0&#x2F;&#x2F;        0&#x2F;&#x2F; 0.866025cout &lt;&lt; quaternion.x() &lt;&lt; endl;cout &lt;&lt; quaternion.y() &lt;&lt; endl;cout &lt;&lt; quaternion.z() &lt;&lt; endl;cout &lt;&lt; quaternion.w() &lt;&lt; endl;&#x2F;&#x2F; 0.5&#x2F;&#x2F; 0&#x2F;&#x2F; 0&#x2F;&#x2F; 0.866025Quaterniond quaternion2;quaternion2 &#x3D; rotation_vector;  &#x2F;&#x2F; 重载了&#39;&#x3D;&#39;cout &lt;&lt; quaternion2.coeffs() &lt;&lt; endl;&#x2F;&#x2F;      0.5&#x2F;&#x2F;        0&#x2F;&#x2F;        0&#x2F;&#x2F; 0.866025&#x2F;&#x2F; 四元数的初始化Quaterniond quaternion(w, x, y, z);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_向量</title>
      <link href="2021/03/21/Eigen-Eigen-%E5%90%91%E9%87%8F/"/>
      <url>2021/03/21/Eigen-Eigen-%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">head(i)&#x2F;&#x2F; 头i个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="部分"><a href="#部分" class="headerlink" title="部分"></a>部分</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">segment(i, n)&#x2F;&#x2F; 取向量从i开始,长度为n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="尾部"><a href="#尾部" class="headerlink" title="尾部"></a>尾部</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">tail(i)&#x2F;&#x2F; 后i个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;Eigen&#x2F;Dense&gt;using namespace std;using namespace Eigen;int main(int argc, char const *argv[])&#123;    VectorXd x(6);    VectorXd a(2);    a &lt;&lt; 1,2;    cout &lt;&lt; a &lt;&lt; endl;    &#x2F;&#x2F; 1    &#x2F;&#x2F; 2    x.head(2) &#x3D; a;    cout &lt;&lt; x &lt;&lt; endl;    &#x2F;&#x2F; 1    &#x2F;&#x2F; 2    &#x2F;&#x2F; 0    &#x2F;&#x2F; 0    &#x2F;&#x2F; 0    &#x2F;&#x2F; 0    VectorXd b(2);    b &lt;&lt; 3,4;    x.segment(2,2) &#x3D; b;    cout &lt;&lt; x &lt;&lt; endl;    &#x2F;&#x2F; 1    &#x2F;&#x2F; 2    &#x2F;&#x2F; 3    &#x2F;&#x2F; 4    &#x2F;&#x2F; 0    &#x2F;&#x2F; 0        VectorXd c(2);    c &lt;&lt; 5,6;    x.tail(2) &#x3D; c;    cout &lt;&lt; x &lt;&lt; endl;    &#x2F;&#x2F; 1    &#x2F;&#x2F; 2    &#x2F;&#x2F; 3    &#x2F;&#x2F; 4    &#x2F;&#x2F; 5    &#x2F;&#x2F; 6    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_求秩</title>
      <link href="2021/03/21/Eigen-Eigen-%E6%B1%82%E7%A7%A9/"/>
      <url>2021/03/21/Eigen-Eigen-%E6%B1%82%E7%A7%A9/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="rank-基本用法"><a href="#rank-基本用法" class="headerlink" title="rank()基本用法"></a><code>rank()</code>基本用法</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">JacobiSVD&lt;MatrixXd&gt; svd(m);svd.rank()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &quot;Eigen&#x2F;Dense&quot;using namespace std;using namespace Eigen;int main()&#123;    MatrixXd a(3, 3);    a &lt;&lt; 1,  2, 0,         3, -1, 1,         0,  2, 0;    MatrixXd b(3, 1);    b &lt;&lt; 2,        1,        1;    MatrixXd m &#x3D; MatrixXd::Zero(3, 3);    m.col(0) &#x3D; b;    m.col(1) &#x3D; a * b;    m.col(2) &#x3D; a * a * b;    cout &lt;&lt; m &lt;&lt; endl;    JacobiSVD&lt;MatrixXd&gt; svd(m);    cout &lt;&lt; svd.rank() &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_矩阵属性</title>
      <link href="2021/03/21/Eigen-Eigen-%E7%9F%A9%E9%98%B5%E5%B1%9E%E6%80%A7/"/>
      <url>2021/03/21/Eigen-Eigen-%E7%9F%A9%E9%98%B5%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="元素累加累乘"><a href="#元素累加累乘" class="headerlink" title="元素累加累乘"></a>元素累加累乘</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mat.sum()mat.prod()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mat.mean()  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mat.minCoeff()mat.maxCoeff()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="迹"><a href="#迹" class="headerlink" title="迹"></a>迹</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mat.trace()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="对角元素"><a href="#对角元素" class="headerlink" title="对角元素"></a>对角元素</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mat.diagonal()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">EigenSolver&lt;Matrix3d&gt; eigen_solver(mat);eigen_solver.pseudoEigenvalueMatrix()&#x2F;&#x2F; 特征值排成矩阵形式eigen_solver.pseudoEigenvectors()&#x2F;&#x2F; 每一列是一个特征向量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &quot;Eigen&#x2F;Dense&quot;using namespace std;using namespace Eigen;int main()&#123;    Matrix2d mat;    mat &lt;&lt; 1, 2,    3, 4;    cout &lt;&lt; &quot;Here is mat.sum():       &quot; &lt;&lt; mat.sum()       &lt;&lt; endl;    cout &lt;&lt; &quot;Here is mat.prod():      &quot; &lt;&lt; mat.prod()      &lt;&lt; endl;    cout &lt;&lt; &quot;Here is mat.mean():      &quot; &lt;&lt; mat.mean()      &lt;&lt; endl;    cout &lt;&lt; &quot;Here is mat.minCoeff():  &quot; &lt;&lt; mat.minCoeff()  &lt;&lt; endl;    cout &lt;&lt; &quot;Here is mat.maxCoeff():  &quot; &lt;&lt; mat.maxCoeff()  &lt;&lt; endl;    cout &lt;&lt; &quot;Here is mat.trace():     &quot; &lt;&lt; mat.trace()     &lt;&lt; endl;    &#x2F;&#x2F; Here is mat.sum():       10    &#x2F;&#x2F; Here is mat.prod():      24    &#x2F;&#x2F; Here is mat.mean():      2.5    &#x2F;&#x2F; Here is mat.minCoeff():  1    &#x2F;&#x2F; Here is mat.maxCoeff():  4    &#x2F;&#x2F; Here is mat.trace():     5    Matrix3d mat;mat &lt;&lt; 1, 2, 4,           3, 4, 5,           9, 8, 7;cout &lt;&lt; mat.diagonal() &lt;&lt; endl;    &#x2F;&#x2F; 1    &#x2F;&#x2F; 4    &#x2F;&#x2F; 7    cout &lt;&lt; mat.eigenvalues() &lt;&lt; endl;    &#x2F;&#x2F; (14.8426,0)    &#x2F;&#x2F; (-3.10313,0)    &#x2F;&#x2F; (0.260538,0)EigenSolver&lt;Matrix3d&gt; eigen_solver(mat);MatrixXd eig_value &#x3D; eigen_solver.pseudoEigenvalueMatrix();cout &lt;&lt; &quot;matrix values &#x3D; \n&quot; &lt;&lt; eig_value &lt;&lt; endl;    &#x2F;&#x2F; matrix values &#x3D;    &#x2F;&#x2F; 14.8426        0        0    &#x2F;&#x2F;     0   -3.10313        0    &#x2F;&#x2F;     0        0   0.260538MatrixXd eig_vector &#x3D; eigen_solver.pseudoEigenvectors();cout &lt;&lt; &quot;matrix vectors &#x3D; \n&quot; &lt;&lt; eig_vector &lt;&lt; endl;    &#x2F;&#x2F; matrix vectors &#x3D;    &#x2F;&#x2F; -0.307083 -0.629353  0.493782    &#x2F;&#x2F; -0.467283 -0.291072 -0.826916    &#x2F;&#x2F; -0.829064  0.791116  0.322174&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_运算符</title>
      <link href="2021/03/21/Eigen-Eigen-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2021/03/21/Eigen-Eigen-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="向量内积"><a href="#向量内积" class="headerlink" title="向量内积"></a>向量内积</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector2d m(1, 2);Vector2d n(4, 5);cout &lt;&lt; m.dot(n) &lt;&lt; endl;    &#x2F;&#x2F; 向量内积：14cout &lt;&lt; m.adjoint() * n &lt;&lt; endl;cout &lt;&lt; (m.adjoint() * n).value() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="转置与伴随矩阵"><a href="#转置与伴随矩阵" class="headerlink" title="转置与伴随矩阵"></a>转置与伴随矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Matrix2d m, n;m &lt;&lt; 1, 2,     3, 4;n &#x3D; m.transpose();&#x2F;&#x2F; m.transposeInPlace();    &#x2F;&#x2F;m变成自己的转置矩阵n &#x3D; m.adjoint();    &#x2F;&#x2F;伴随矩阵，实数的伴随矩阵等于转置矩阵&#x2F;&#x2F; 1 3&#x2F;&#x2F; 2 4m.adjointInPlace();    &#x2F;&#x2F;m变成自己的伴随矩阵Matrix2cf m &#x3D; Matrix2cf::Random(); &#x2F;&#x2F;复数的伴随矩阵，除了转置，复数域要变号cout &lt;&lt; &quot;Here is the 2x2 complex matrix m:&quot; &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;cout &lt;&lt; &quot;Here is the adjoint of m:&quot; &lt;&lt; endl &lt;&lt; m.adjoint() &lt;&lt; endl;Here is the 2x2 complex matrix m:(0.127171,-0.997497) (-0.0402539,0.170019)(0.617481,-0.613392)  (0.791925,-0.299417)Here is the adjoint of m:(0.127171,0.997497)    (0.617481,0.613392)(-0.0402539,-0.170019)    (0.791925,0.299417)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="范数与单位化"><a href="#范数与单位化" class="headerlink" title="范数与单位化"></a>范数与单位化</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector2d vec1(3, 4);Vector2d vec2;double scalar &#x3D; vec1.norm();    &#x2F;&#x2F; 二阶范数 5    scalar &#x3D; vec1.squaredNorm();    &#x2F;&#x2F; 范数平方 25vec2 &#x3D; vec1.normalized();    &#x2F;&#x2F; 单位化 0.6; 0.8vec1.normalize();    &#x2F;&#x2F; inplace 自己变成自己的单位化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3d vec1(1, 2, 3);Vector3d vec2(3, 4, 5);cout &lt;&lt; &quot;cross: &quot; &lt;&lt; endl &lt;&lt; vec1.cross(vec2) &lt;&lt; endl; &#x2F;&#x2F; 叉积只适用于三维向量cross:     -2      4     -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
