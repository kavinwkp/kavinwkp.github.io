<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>53-I-缺失的数字</title>
      <link href="2021/05/25/%E5%89%91%E6%8C%87Offer-53-I-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>2021/05/25/%E5%89%91%E6%8C%87Offer-53-I-%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int missingNumber(vector&lt;int&gt;&amp; nums) &#123;    int l &#x3D; 0, r &#x3D; nums.size();    while (l &lt; r) &#123;        int mid &#x3D; l + r &gt;&gt; 1;        if (nums[mid] !&#x3D; mid) r &#x3D; mid;        else l &#x3D; mid + 1;    &#125;    return r;&#125;int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi&#123;0, 1, 2, 3, 4, 5, 6, 7, 9&#125;;    for (auto v : vi)        cout &lt;&lt; v &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    cout &lt;&lt; missingNumber(vi) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24-反转链表</title>
      <link href="2021/05/25/%E5%89%91%E6%8C%87Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>2021/05/25/%E5%89%91%E6%8C%87Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;struct ListNode&#123;    int val;    ListNode *next;    ListNode(int x) : val(x), next(NULL) &#123;&#125;    ListNode(int x, ListNode *n) : val(x), next(n) &#123;&#125;&#125;;void disp(ListNode *p) &#123;    while (p) &#123;        cout &lt;&lt; p-&gt;val &lt;&lt; &quot; &quot;;        p &#x3D; p-&gt;next;    &#125;    cout &lt;&lt; endl;&#125;ListNode* reverseList(ListNode* head) &#123;    ListNode *pre &#x3D; NULL, *cur &#x3D; head;    if (!cur) return head;    while (cur) &#123;        ListNode *temp &#x3D; cur-&gt;next;        cur-&gt;next &#x3D; pre;        pre &#x3D; cur;        cur &#x3D; temp;    &#125;    return pre;&#125;int main(int argc, char const *argv[])&#123;    ListNode *node5 &#x3D; new ListNode(5, NULL);    ListNode *node4 &#x3D; new ListNode(4, node5);    ListNode *node3 &#x3D; new ListNode(3, node4);    ListNode *node2 &#x3D; new ListNode(2, node3);    ListNode *node1 &#x3D; new ListNode(1, node2);    ListNode *head &#x3D; node1;    disp(head);    head &#x3D; reverseList(head);    disp(head);    return 0;&#125;1 2 3 4 55 4 3 2 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>69-x的平方根</title>
      <link href="2021/05/24/LeetCode-69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/"/>
      <url>2021/05/24/LeetCode-69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-69-x-的平方根"><a href="#LeetCode-69-x-的平方根" class="headerlink" title="LeetCode 69. x 的平方根"></a>LeetCode 69. x 的平方根</h2><p>实现 <code>int sqrt(int x)</code> 函数。</p><p>计算并返回 <code>x</code> 的平方根，其中 <code>x</code> 是非负整数。</p><p>由于返回类型是整数，结果只<strong>保留整数</strong>的部分，小数部分将被舍去。</p><p>示例 1:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: 4输出: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>模板二：满足条件的最大数<br><code>r</code>和<code>l</code>相加可能超过<code>int</code>，所以用<code>long long</code><br>两个<code>mid</code>相乘也可能越界，把一个除到另一边去</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;int mySqrt(int x) &#123;    long long l &#x3D; 0, r &#x3D; x;    while (l &lt; r) &#123;        long long mid &#x3D; l + r + 1 &gt;&gt; 1; &#x2F;&#x2F; 左移一位就相当于除以2        if (mid &lt;&#x3D; x &#x2F; mid) l &#x3D; mid;    &#x2F;&#x2F; 把乘移到另一边        else r &#x3D; mid - 1;    &#125;    return l;&#125;int main() &#123;    cout &lt;&lt; mySqrt(2147395599) &lt;&lt; endl;    return 0;&#125;46339<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>65-不用加减乘除做加法</title>
      <link href="2021/05/24/%E5%89%91%E6%8C%87Offer-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
      <url>2021/05/24/%E5%89%91%E6%8C%87Offer-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-65-不用加减乘除做加法"><a href="#剑指-Offer-65-不用加减乘除做加法" class="headerlink" title="剑指 Offer 65. 不用加减乘除做加法"></a>剑指 Offer 65. 不用加减乘除做加法</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用四则运算符号。</p><p>求异或<br>求进位：相与再左移一位</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;int add(int a, int b) &#123;    while (b) &#123;        int temp &#x3D; a ^ b;        b &#x3D; (unsigned)(a &amp; b) &lt;&lt; 1;        a &#x3D; temp;    &#125;    return a;&#125;int main(int argc, char const *argv[])&#123;    cout &lt;&lt; add(-1, 2) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指Offer </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>64-求1到n的和</title>
      <link href="2021/05/24/%E5%89%91%E6%8C%87Offer-64-%E6%B1%821%E5%88%B0n%E7%9A%84%E5%92%8C/"/>
      <url>2021/05/24/%E5%89%91%E6%8C%87Offer-64-%E6%B1%821%E5%88%B0n%E7%9A%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-64-求1-2-…-n"><a href="#剑指-Offer-64-求1-2-…-n" class="headerlink" title="剑指 Offer 64. 求1+2+…+n"></a>剑指 Offer 64. 求1+2+…+n</h2><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p>用递归</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;int sumNums(int n) &#123;    if (n &#x3D;&#x3D; 1) return 1;    else return n + sumNums(n-1);&#125;int main(int argc, char const *argv[])&#123;    cout &lt;&lt; sumNums(10) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指Offer </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39-数组中出现次数超过一半的数字</title>
      <link href="2021/05/23/%E5%89%91%E6%8C%87Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>2021/05/23/%E5%89%91%E6%8C%87Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-39-数组中出现次数超过一半的数字"><a href="#剑指-Offer-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指 Offer 39. 数组中出现次数超过一半的数字"></a>剑指 Offer 39. 数组中出现次数超过一半的数字</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>示例 1:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]输出: 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用<code>map</code>保存每个数字出现的次数，超过一半就返回</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;int majorityElement(vector&lt;int&gt;&amp; nums) &#123;    int count &#x3D; nums.size() &#x2F; 2 + 1;    map&lt;int, int&gt; m;    for (auto elem : nums) &#123;        m[elem]++;        if (m[elem] &gt;&#x3D; count) return elem;    &#125;    return -1;&#125;int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi &#x3D; &#123;1, 2, 3, 2, 2, 2, 5, 4, 2&#125;;    for (auto v : vi)         cout &lt;&lt; v &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    cout &lt;&lt; majorityElement(vi) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-数据信息表示方法</title>
      <link href="2021/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/"/>
      <url>2021/05/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="符号数表示"><a href="#符号数表示" class="headerlink" title="符号数表示"></a>符号数表示</h2><p>原码：最高位为符号，其余二进制真值<br>补码：最高位符号</p><ul><li>正：与原码相同</li><li>负：取反加1</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">-69原码：1100 0101补码：1011 1011<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>补码可表示范围比原码多1<br>n位数：**-2^n^ ~ 2^n^-1**</p><p><strong>tips:</strong><br>因为计算机中以补码形式存储数据，所以<code>32</code>位的有符号数的<code>int</code>的范围是：**-2^31^ ~ 2^31^-1**，即 <strong>-2147483648 ~ 2147483647</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main() &#123;    int a &#x3D; 2147483647;    cout &lt;&lt; a+1 &lt;&lt; endl;    return 0;&#125;-2147483648<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反码</p><ul><li>正数：与补码相同</li><li>负数：原码符号不变，其余取反</li></ul><p>移码：补码符号位取反</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vim基本操作</title>
      <link href="2021/05/22/Linux-vim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>2021/05/22/Linux-vim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<ul><li><p>vim ~/.vimrc可以编辑配置文件</p></li><li><p>syntax on 语法高亮</p></li><li><p>set number 行号</p></li><li><p>q! 强制退出</p></li><li><p>w(word) 移动到下一个单词，b移动到上一个单词</p></li><li><p>page up/down上下翻页 也可以用ctrl+f(forward)/b(back)</p></li><li><p>行号+gg快速定位，直接gg回到开头，G调到末尾</p></li><li><p>/+内容，可以用来查找。n选择下一个，shift+n上一个</p></li><li><p>cc剪切进入编辑，cnc剪切第n行</p></li><li><p>u撤销 </p></li><li><p>yy复制，p粘贴</p></li><li><p>v 进入visual模式，可以选择多行，按c删除</p></li><li><p>starti 可以从第一条指令开始执行程序</p></li><li><p>layout asm 可以更方便地查看汇编</p></li><li><p>info register 可以查看寄存器</p></li></ul><h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>.c文件 -&gt; 预处理(preprocess) -&gt; .i文件 -&gt; 编译(compile) -&gt; .s文件 -&gt; 汇编(assembly) -&gt; .o文件 -&gt; 链接(link) -&gt; a.out</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>40-最小的k个数</title>
      <link href="2021/05/21/%E5%89%91%E6%8C%87Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
      <url>2021/05/21/%E5%89%91%E6%8C%87Offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a>剑指 Offer 40. 最小的k个数</h2><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p>示例 1：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：arr &#x3D; [3,2,1], k &#x3D; 2输出：[1,2] 或者 [2,1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>示例 2：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：arr &#x3D; [0,1,2,1], k &#x3D; 1输出：[0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>限制：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">0 &lt;&#x3D; k &lt;&#x3D; arr.length &lt;&#x3D; 100000 &lt;&#x3D; arr[i] &lt;&#x3D; 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>用优先队列维护一个长度为k的大根堆<br>如果后面的数比堆里最大的数小，就要替换掉堆中的数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;public:    vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123;        vector&lt;int&gt; res;        if (k &#x3D;&#x3D; 0) return res;         &#x2F;&#x2F; 返回空        priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;        for (int i &#x3D; 0; i &lt; arr.size(); i++) &#123;            if (i &lt; k) q.push(arr[i]);  &#x2F;&#x2F; 先放入k个数            else if (arr[i] &lt; q.top()) &#123;                    q.pop();                    q.push(arr[i]);                &#125;        &#125;                while (!q.empty()) &#123;            &#x2F;&#x2F; 把堆里的数据搬到vector            int elem &#x3D; q.top();            q.pop();            res.push_back(elem);        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指Offer </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>48-最长不含重复字符的子字符串</title>
      <link href="2021/05/20/%E5%89%91%E6%8C%87Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2021/05/20/%E5%89%91%E6%8C%87Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-48-最长不含重复字符的子字符串"><a href="#剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="剑指 Offer 48. 最长不含重复字符的子字符串"></a>剑指 Offer 48. 最长不含重复字符的子字符串</h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p><p>示例 1:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>用<code>[l, r-1]</code>维护一个不含重复元素的子串<br>利用<code>set</code>集合不含重复元素的特性<br>如果r所指的元素集合中已经存在，就把l所指的元素删除掉，再看r所指元素是否已经存在</p><center><img src="/2021/05/20/%E5%89%91%E6%8C%87Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/222.png#pic_center" width="40%" height="40%"></center><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;public:    int lengthOfLongestSubstring(string s) &#123;        set&lt;char&gt; st;        unsigned l &#x3D; 0, r &#x3D; 0;        unsigned res &#x3D; 0;        while (r &lt; s.size() &amp;&amp; l &lt;&#x3D; r) &#123;            if (st.find(s[r]) &#x3D;&#x3D; st.end()) &#123;    &#x2F;&#x2F; 如果r所指元素不在集合中                st.insert(s[r]);                r++;                res &#x3D; max(res, r - l);      &#x2F;&#x2F; 串长度为(r-1)-l+1&#x3D;r-l            &#125;            else &#123;                st.erase(s[l]);     &#x2F;&#x2F; 删掉l所指的元素                l++;            &#125;        &#125;        return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-数组中重复的数字</title>
      <link href="2021/05/19/%E5%89%91%E6%8C%87Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>2021/05/19/%E5%89%91%E6%8C%87Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a>剑指 Offer 03. 数组中重复的数字</h2><p>在一个长度为 <code>n</code> 的数组 <code>nums</code> 里的所有数字都在 <code>0~n-1</code> 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> </p><p>限制：</p><p><code>2 &lt;= n &lt;= 100000</code></p><p>思路：因为限制时间复杂度为<code>O(n)</code>，所以不能用排序<br>对于这种元素是<code>[0, n-1]</code>的数组，可以把元素放回自己的index，如果要放回的位置已经有元素了，并且是没错的，就说明重复了</p><center><img src="/2021/05/19/%E5%89%91%E6%8C%87Offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/03.png#pic_center" width="20%" height="20%"></center><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;public:    void swap(vector&lt;int&gt; &amp;vi, int i, int j) &#123;        int temp &#x3D; vi[i];        vi[i] &#x3D; vi[j];        vi[j] &#x3D; temp;    &#125;    int findRepeatNumber(vector&lt;int&gt;&amp; num) &#123;        for (int i &#x3D; 0; i &lt; num.size(); i++) &#123;  &#x2F;&#x2F; 遍历数组            while (i !&#x3D; num[i]) &#123;               &#x2F;&#x2F; 发现和index对不上                if (num[i] &#x3D;&#x3D; num[num[i]])      &#x2F;&#x2F; 如果那个位置已经正确                    return num[i];              &#x2F;&#x2F; 就说明重复了                swap(num, i, num[i]);           &#x2F;&#x2F; 否则交换两个数            &#125;        &#125;        return -1;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 剑指Offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指Offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.2-标准库类型string</title>
      <link href="2021/05/19/C-Primer-3-2-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/"/>
      <url>2021/05/19/C-Primer-3-2-%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring/</url>
      
        <content type="html"><![CDATA[<h2 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string::size_type类型"></a>string::size_type类型</h2><p><code>str.size()</code>的返回类型是无符号数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto len &#x3D; str.size();cout &lt;&lt; len &lt;&lt; endl;int x &#x3D; -1;cout &lt;&lt; x * len &lt;&lt; endl;输出：18446744073709551615<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>str.size()</code>的返回结果是<code>size_type</code>类型，貌似是<code>unsigned long long</code>，反正就是无符号数，注意不要和有符号数混用</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1-基本内置类型</title>
      <link href="2021/05/19/C-Primer-2-1-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>2021/05/19/C-Primer-2-1-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="切勿混用带符号类型和无符号类型"><a href="#切勿混用带符号类型和无符号类型" class="headerlink" title="切勿混用带符号类型和无符号类型"></a>切勿混用带符号类型和无符号类型</h2><p>因为<strong>带符号类型</strong>会自动转换为<strong>无符号数</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">unsigned int x &#x3D; -1;cout &lt;&lt; x &lt;&lt; endl;输出：4294967295<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>危</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int x &#x3D; -1;unsigned y &#x3D; 1;cout &lt;&lt; x * y &lt;&lt; endl;输出：4294967295<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>带符号类型的x会被转换为无符号类型的4294967295</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组复制</title>
      <link href="2021/05/17/Python-%E6%95%B0%E7%BB%84-%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6/"/>
      <url>2021/05/17/Python-%E6%95%B0%E7%BB%84-%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><p>如果只用赋值运算符，实现的是浅复制，类似于两个指针指向同一块内存区域，对一个的修改会影响到另一个</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">a &#x3D; [1, 2, 3]b &#x3D; aa[0] &#x3D; 100print(b)[100, 2, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="list-的解决方法"><a href="#list-的解决方法" class="headerlink" title="list()的解决方法"></a>list()的解决方法</h2><p>改成<code>b=a[:]</code>就可以了</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">a &#x3D; [1, 2, 3]b &#x3D; a[:]a[0] &#x3D; 100print(b)[1, 2, 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="np-array-的解决方法"><a href="#np-array-的解决方法" class="headerlink" title="np.array()的解决方法"></a>np.array()的解决方法</h2><p>但是，这对<code>list</code>有用，对<code>np.array</code>没用</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">a &#x3D; np.array([1, 2, 3])b &#x3D; a[:]a[0] &#x3D; 100print(b)[100   2   3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="copy-函数实现深复制"><a href="#copy-函数实现深复制" class="headerlink" title="copy()函数实现深复制"></a>copy()函数实现深复制</h2><p>需要用<code>copy()</code>函数</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">a &#x3D; np.array([1, 2, 3])b &#x3D; a.copy()a[0] &#x3D; 100print(b)[1 2 3]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.9-重载、类型转换与运算符</title>
      <link href="2021/05/15/C-Primer-14-9-%E9%87%8D%E8%BD%BD%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2021/05/15/C-Primer-14-9-%E9%87%8D%E8%BD%BD%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="Conversion-Function-转换函数"><a href="#Conversion-Function-转换函数" class="headerlink" title="Conversion Function 转换函数"></a>Conversion Function 转换函数</h2><p>必要时对class类型进行转换</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Fraction &#123;public:    &#x2F;&#x2F; non-explicit-one-argument ctor    Fraction(int num, int den&#x3D;1) : m_num(num), m_den(den) &#123;&#125;    &#x2F;&#x2F; 将Fraction转为double    operator double() const &#123;        return (double)m_num &#x2F; m_den;    &#125;private:    int m_num;    int m_den;&#125;;int main(int argc, char const *argv[])&#123;    Fraction f1(3, 4);    cout &lt;&lt; 1 + f1 &lt;&lt; endl;    return 0;&#125;1.75<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要实现下面的功能</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Fraction f2 &#x3D; f1 + 4;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只需要重载<code>+</code>运算符，编译器会调用<code>non-explicit-one-argument</code>构造函数，即隐式的一个参数的构造函数，将<code>4</code>这个<code>int</code>型变量转换为<code>Fraction(4, 1)</code>类型，再进行相加。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Fraction operator + (const Fraction&amp; f) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>但是</strong>，如果有转换函数，又有<code>non-explicit-one-argument ctor</code>，编译器就会陷入矛盾，不知道是该把<code>Fraction</code>转为<code>double</code>，还是把<code>int</code>转为<code>Fraction</code></p><p>解决办法，把构造函数声明为<code>explicit</code>，这样就不能隐式地把<code>int</code>转为<code>Fraction</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="2021/05/15/C-exercise-String/"/>
      <url>2021/05/15/C-exercise-String/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class String &#123;public:    String(const char* cstr &#x3D; 0);    String(const String&amp; str);    String&amp; operator &#x3D; (const String&amp; str);    ~String();    char* get_c_str() const &#123; return m_data; &#125;private:    char* m_data;&#125;;inline String::String(const char* cstr) &#123;    if (cstr) &#123;        m_data &#x3D; new char[strlen(cstr) + 1];        strcpy(m_data, cstr);    &#125;    else &#123;        m_data &#x3D; new char[1];        *m_data &#x3D; &#39;\0&#39;;    &#125;&#125;inline String::~String() &#123;    delete[] m_data;&#125;inline String::String(const String&amp; str) &#123;    m_data &#x3D; new char[strlen(str.m_data) + 1];    strcpy(m_data, str.m_data);&#125;&#x2F;&#x2F; 赋值前必须检查是否是自我赋值inline String&amp; String::operator &#x3D; (const String&amp; str) &#123;    if (this &#x3D;&#x3D; &amp;str)         return *this;    delete[] m_data;    m_data &#x3D; new char[strlen(str.m_data) + 1];    strcpy(m_data, str.m_data);    return *this;&#125;&#x2F;* 重载流输出运算符 * 必须放在类外面，或者声明为友元函数 *&#x2F;inline ostream&amp; operator &lt;&lt; (ostream&amp; os, const String&amp; str) &#123;    return os &lt;&lt; str.get_c_str();&#125;int main(int argc, char const *argv[])&#123;    const char* ptr &#x3D; &quot;hello&quot;;    String s1(ptr);    cout &lt;&lt; s1 &lt;&lt; endl;    String s2(s1);    cout &lt;&lt; s2 &lt;&lt; endl;    String s3;    s3 &#x3D; s1;    cout &lt;&lt; s3 &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>条形图</title>
      <link href="2021/05/12/Python-%E7%94%BB%E5%9B%BE-%E6%9D%A1%E5%BD%A2%E5%9B%BE/"/>
      <url>2021/05/12/Python-%E7%94%BB%E5%9B%BE-%E6%9D%A1%E5%BD%A2%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>不同y轴的图例表示方法</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.pyplot import MultipleLocatorfrom matplotlib import rcnum_list1 &#x3D; [152.8,122.23,101.9,87.31,76.4,68,61.15,55.6,52.41]# print(num_list1)num_list2 &#x3D; [23393.3,17956.2,14406,11938.7,10180.5,8899.45,7917.17,7178.32,6832.4]for i in range(len(num_list2)):    num_list2[i] &#x2F;&#x3D; 1000fig &#x3D; plt.figure()ax &#x3D; fig.add_subplot(111)x &#x3D; range(4, 13)ax.bar(x&#x3D;x, height&#x3D;num_list1, width&#x3D;0.4, alpha&#x3D;0.8, color&#x3D;&#39;#00a6ac&#39;, label&#x3D;&#39;time(s)&#39;)ax2 &#x3D; ax.twinx()ax2.bar(x&#x3D;[i + 0.4 for i in x], height&#x3D;num_list2, width&#x3D;0.4, color&#x3D;&#39;#d71345&#39;, label&#x3D;&#39;Energy Consumption(kJ)&#39;)fig.legend(loc&#x3D;1, bbox_to_anchor&#x3D;(1,1), bbox_transform&#x3D;ax.transAxes)font &#x3D; &#123;&#39;family&#39;: &#39;Arial&#39;, &#39;weight&#39;: &#39;normal&#39;, &#39;size&#39;: 20&#125;ax.set_xlabel(&quot;Maximal Speed(m&#x2F;s)&quot;, font)ax.set_ylabel(&#39;Time(s)&#39;, font)x_locator &#x3D; MultipleLocator(1)ax.xaxis.set_major_locator(x_locator)ax.spines[&#39;top&#39;].set_linewidth(2)ax.spines[&#39;bottom&#39;].set_linewidth(2)ax.spines[&#39;left&#39;].set_linewidth(2)ax.spines[&#39;right&#39;].set_linewidth(2)font2 &#x3D; &#123;&#39;family&#39;: &#39;Arial&#39;, &#39;weight&#39;: &#39;normal&#39;, &#39;size&#39;: 20, &#39;color&#39;:&#39;#d71345&#39;&#125;ax2.set_ylabel(&#39;Energy Consumption(kJ)&#39;, font2)plt.tick_params(axis&#x3D;&#39;y&#39;, colors&#x3D;&#39;#d71345&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/05/12/Python-%E7%94%BB%E5%9B%BE-%E6%9D%A1%E5%BD%A2%E5%9B%BE/1.png#pic_center" width="80%" height="80%" alt="test"></center>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三维图</title>
      <link href="2021/05/12/Python-%E7%94%BB%E5%9B%BE-%E4%B8%89%E7%BB%B4%E5%9B%BE/"/>
      <url>2021/05/12/Python-%E7%94%BB%E5%9B%BE-%E4%B8%89%E7%BB%B4%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="np-arange"><a href="#np-arange" class="headerlink" title="np.arange()"></a>np.arange()</h2><p>函数返回一个有<strong>起点</strong>和<strong>终点</strong>的<strong>固定步长</strong>的排列，如<code>[1,2,3,4,5]</code>，起点是1，终点是6，步长为1</p><ul><li>只有一个参数时表示<code>[0, n)</code>，默认步长为1</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">np.arange(3)[0 1 2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>有两个参数表示起点到终点，默认步长为1</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">np.arange(5, 10)[5 6 7 8 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>三个参数表示起点、终点、步长</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">np.arange(1, 10, 2)[1 3 5 7 9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>支持小数步长</li></ul><pre class="line-numbers language-py" data-language="py"><code class="language-py">np.arange(1, 5, 0.5)[1.  1.5 2.  2.5 3.  3.5 4.  4.5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="np-linspace"><a href="#np-linspace" class="headerlink" title="np.linspace()"></a>np.linspace()</h2><p>返回<code>start</code>到<code>stop</code>之间<strong>等间隔</strong>的<code>num</code>个点</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">numpy.linspace(start, stop, num&#x3D;50, endpoint&#x3D;True, retstep&#x3D;False, dtype&#x3D;None, axis&#x3D;0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-py" data-language="py"><code class="language-py">np.linspace(2.0, 3.0, num&#x3D;5)[2.   2.25 2.5  2.75 3.  ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">x &#x3D; np.arange(-10, 10, 0.2)y &#x3D; np.arange(-10, 10, 0.2)f_x_y &#x3D; np.power(x, 2) + np.power(y, 2)plt.figure()ax &#x3D; plt.gca(projection&#x3D;&#39;3d&#39;)ax.plot(x, y, f_x_y)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/05/12/Python-%E7%94%BB%E5%9B%BE-%E4%B8%89%E7%BB%B4%E5%9B%BE/1.png#pic_center" width="80%" height="80%" alt="test"></center>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04_初始化</title>
      <link href="2021/05/01/C-Effective-04-%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>2021/05/01/C-Effective-04-%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="确定对象被使用前已经初始化"><a href="#确定对象被使用前已经初始化" class="headerlink" title="确定对象被使用前已经初始化"></a>确定对象被使用前已经初始化</h2><p>不同编译单元内定之<code>non-local static</code>对象的初始化次序是不确定的</p><p>广义的<code>static</code>对象包括：</p><ul><li><code>global</code>对象</li><li>定义于<code>namespace</code>作用域内的对象</li><li>在<code>class</code>内、函数内、<code>file</code>作用域内声明为<code>static</code>的对象</li></ul><p><code>local static</code>：定义在函数内的<code>static</code>对象</p><p>比如我有两个类<code>FileSystem</code>和<code>Directory</code></p><ol><li><code>FileSystem</code>的声明和定义</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;class FileSystem&#123;public:    FileSystem(int a) : num(a) &#123;&#125;    std::size_t getNum() const;private:    int num;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;FileSystem.h&quot;std::size_t FileSystem::getNum() const &#123;    return num;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><code>Directory</code>的声明和定义</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;FileSystem.h&quot;class Directory &#123;public:    Directory();    int display();private:    int val;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;Directory.h&quot;extern FileSystem tfs;  &#x2F;&#x2F; 这里声明了一个FileSystem对象，因为Directory的初始化要用到Directory::Directory() &#123;    std::size_t disks &#x3D; tfs.getNum();    val &#x3D; disks;&#125;int Directory::display() &#123;    return val;&#125;Directory tempDir;  &#x2F;&#x2F; 定义一个Directory对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><code>tfs</code>的定义</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;FileSystem.h&quot;FileSystem tfs(10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li><code>main</code>函数</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;Directory.h&quot;#include &lt;iostream&gt;using namespace std;extern Directory tempDir;int main(int argc, char const *argv[])&#123;    cout &lt;&lt; tempDir.display() &lt;&lt; endl;    return 0;&#125;0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>发现输出不是我们预期的<code>10</code>，原因在于定义<code>dir</code>时调用了<code>Directory</code>的构造函数，用到了<code>FileSystem</code>的对象<code>tfs</code>，但这个<code>tfs</code>此时未必已经初始化了，因为编译器对文件的编译顺序没有严格的要求，所以会出现问题</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>不要把<code>tfs</code>声明为全局变量，即<code>non-local static</code>变量，而要声明为<code>local static</code>，就是函数里面的<code>static</code>变量</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;Directory.h&quot;extern FileSystem&amp; tfs();Directory::Directory() &#123;    std::size_t disks &#x3D; tfs().getNum();    val &#x3D; disks;&#125;int Directory::display() &#123;    return val;&#125;&#x2F;&#x2F; Directory dir;   &#x2F;&#x2F; dir也声明为non-local staticDirectory&amp; dir() &#123;    static Directory tempDir;    return tempDir;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;FileSystem.h&quot;&#x2F;&#x2F; FileSystem tfs(10);FileSystem&amp; tfs() &#123;    static FileSystem fs(10);   &#x2F;&#x2F; 在函数里面定义，就是local static    return fs;                  &#x2F;&#x2F; 返回引用&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;Directory.h&quot;#include &lt;iostream&gt;using namespace std;extern Directory&amp; dir();int main(int argc, char const *argv[])&#123;    cout &lt;&lt; dir().display() &lt;&lt; endl;    return 0;&#125;10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就符合我们的预期了<br><code>tfs()</code>函数内部实现了<code>FileSystem</code>对象的初始化，调用该函数之后，就可以确保对象一定会被初始化了<br>所以用调用函数替换直接使用<code>non-local static</code>对象，就可以得到对象初始化保证</p>]]></content>
      
      
      
        <tags>
            
            <tag> Effective_C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inline关键字</title>
      <link href="2021/04/30/C-inline%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2021/04/30/C-inline%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-类中内联"><a href="#1-类中内联" class="headerlink" title="1.类中内联"></a>1.类中内联</h2><p>头文件中声明方法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;public:    void f1(int x);    &#x2F;**     * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。     * @param x     * @param y     *&#x2F;    void Foo(int x,int y) &#123;&#125;; &#x2F;&#x2F; 定义即隐式内联函数！    void f1(int x); &#x2F;&#x2F; 声明后，要想成为内联函数，必须在定义处加inline&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现文件中定义内联函数：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &quot;inline.h&quot;using namespace std; &#x2F;** * @brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字” * * @param x * @param y * * @return  *&#x2F;int Foo(int x,int y);  &#x2F;&#x2F; 函数声明inline int Foo(int x,int y) &#x2F;&#x2F; 函数定义&#123;    return x + y;&#125;&#x2F;&#x2F; 定义处加inline关键字，推荐这种写法！inline void A::f1(int x) &#123;&#125;int main() &#123;    cout&lt;&lt;Foo(1,2)&lt;&lt;endl;&#125;&#x2F;** * 编译器对 inline 函数的处理步骤 * 将 inline 函数体复制到 inline 函数调用点处； * 为所用 inline 函数中的局部变量分配内存空间； * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。 *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>内联能提高函数效率，但并不是所有的函数都定义成内联函数！内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。</p><ul><li><p>如果执行函数体内代码的时间相比于函数调用的开销较大，那么效率的收获会更少！</p></li><li><p>另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p></li></ul><p>以下情况不宜用内联：</p><p>（1）如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高。</p><p>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</p><h2 id="2-虚函数（virtual）可以是内联函数（inline）吗？"><a href="#2-虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="2.虚函数（virtual）可以是内联函数（inline）吗？"></a>2.虚函数（virtual）可以是内联函数（inline）吗？</h2><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;  using namespace std;class Base &#123;public:    inline virtual void info() &#123;        cout &lt;&lt; &quot;I am Base&quot; &lt;&lt; endl;    &#125;    virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123;public:    inline void info()  &#x2F;&#x2F; 不写inline时隐式内联    &#123;        cout &lt;&lt; &quot;I am Derived&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    &#x2F;&#x2F; 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。     Base b;    b.info();    &#x2F;&#x2F; 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。      Base *ptr &#x3D; new Derived();    ptr-&gt;info();    &#x2F;&#x2F; 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。    delete ptr;    ptr &#x3D; nullptr;    return 0;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03_const代替#defind</title>
      <link href="2021/04/29/C-Effective-03-const/"/>
      <url>2021/04/29/C-Effective-03-const/</url>
      
        <content type="html"><![CDATA[<h2 id="尽可能使用const代替-define"><a href="#尽可能使用const代替-define" class="headerlink" title="尽可能使用const代替#define"></a>尽可能使用const代替#define</h2><p>有时候需要重载<code>const</code>版本与非<code>const</code>版本的成员函数，但他们的代码又很多重复<br>所以可以直接用非<code>const</code>函数调用<code>const</code>函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Text &#123;private:    string text;public:    Text(string input): text(input) &#123;&#125;    const char&amp; operator [] (size_t pos) const &#123;        cout &lt;&lt; &quot;const operator: &quot;;        return text[pos];    &#125;    char&amp; operator [] (size_t pos) &#123;        cout &lt;&lt; &quot;non-const operator: &quot;;        &#x2F;&#x2F; return text[pos];        return const_cast&lt;char&amp;&gt;(static_cast&lt;const Text&amp;&gt;(*this)[pos]);    &#125;&#125;;int main(int argc, char const *argv[])&#123;    Text t(&quot;hello&quot;);    cout &lt;&lt; t[0] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>static_cast</code>将<code>this</code>指针转换为<code>const</code>指针，这样就可以调用<code>const operator[]</code><br><code>const_cast</code>将返回值解除<code>const</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Effective_C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mutable</title>
      <link href="2021/04/29/C-mutable%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2021/04/29/C-mutable%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p><code>const</code>成员函数不能修改成员变量，如果一定要修改，可以将变量声明为<code>mutable</code>类型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;private:    mutable int x;public:    A(int _x): x(_x) &#123;&#125;    void func() const &#123;x &#x3D; 10;&#125; &#x2F;&#x2F; 在const成员函数里面修改成员变量&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>错题1</title>
      <link href="2021/04/29/NowCoder-%E9%94%99%E9%A2%981/"/>
      <url>2021/04/29/NowCoder-%E9%94%99%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<ol><li><p>运算符优先级<br>算术运算符&gt;关系运算符&gt;逻辑运算符&gt;赋值运算符</p></li><li><p>(p++)-&gt;num<br>会先执行<code>p-&gt;num</code>，然后再<code>p++</code></p></li><li><p><code>getline()</code>读取一行字符</p></li><li><p>派生类的成员函数是虚函数，基类不是，就会执行基类的成员函数</p></li><li><p>除了类属关系运算符<code>&quot;.&quot;</code>、成员指针运算符<code>&quot;.*&quot;</code>、作用域运算符<code>&quot;::&quot;</code>、<code>sizeof</code>运算符和三目运算符<code>&quot;?:&quot;</code>以外，C++中的所有运算符都可以重载</p></li><li><p>重载</p></li></ol><ul><li>函数名相同</li><li>参数必须不同（个数或类型或顺序）</li><li>返回值类型可以相同也可以不同</li></ul><ol start="7"><li><code>malloc</code>对应<code>free</code><br><code>new</code>对应<code>delete</code></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>构造函数</title>
      <link href="2021/04/29/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>2021/04/29/C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="一、类对象成员的构造"><a href="#一、类对象成员的构造" class="headerlink" title="一、类对象成员的构造"></a>一、类对象成员的构造</h2><p>先构造成员<br>再构造自身（调用构造函数）</p><h2 id="二、派生类构造函数"><a href="#二、派生类构造函数" class="headerlink" title="二、派生类构造函数"></a>二、派生类构造函数</h2><p>派生类可能有多个基类，也可能包括多个成员对象，在创建派生类对象时，派生类的构造函数除了要负责本类成员的初始化外，还要调用基类和成员对象的构造函数，并向它们传递参数，以完成基类子对象和成员对象的建立和初始化。</p><p><strong>派生类只能采用构造函数初始化列表的方式向基类或成员对象的构造函数传递参数</strong>，形式如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">派生类构造函数名(参数表): 基类构造函数名(参数表), 成员对象名1(参数表) &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、构造函数和析构函数调用次序"><a href="#三、构造函数和析构函数调用次序" class="headerlink" title="三、构造函数和析构函数调用次序"></a>三、构造函数和析构函数调用次序</h2><p><strong>派生类对象的构造</strong></p><ul><li>先构造基类</li><li>再构造成员</li><li>最后构造自身（调用构造函数）</li></ul><p>基类构造顺序由派生层次决定：<strong>最远的基类最先构造</strong><br>成员构造顺序和定义顺序相同<br>析构函数的析构顺序与构造相反</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class A&#123;    int x;public:    A(int i &#x3D; 0) &#123;        x &#x3D; i;        cout &lt;&lt; &quot;A constructor: &quot; &lt;&lt; x &lt;&lt; endl;     &#125;&#125;;class B&#123;    int y;public:    B(int i) &#123;        y &#x3D; i;        cout &lt;&lt; &quot;B constructor: &quot; &lt;&lt; y &lt;&lt; endl;     &#125;&#125;;class C&#123;    int z;public:    C(int i) &#123;        z &#x3D; i;        cout &lt;&lt; &quot;C constructor: &quot; &lt;&lt; z &lt;&lt; endl;     &#125;&#125;;class D: public B&#123;public:    C c1;    A* a1 &#x3D; new A(10);    A a0, a4;    D(): a4(4), c1(1), B(1) &#123;        cout &lt;&lt; &quot;D constructor&quot; &lt;&lt; endl;    &#125;    &#125;;int main(int argc, char const *argv[])&#123;    D d;    return 0;&#125;B constructor: 1    &#x2F;&#x2F; 先调用基类构造函数C constructor: 1    &#x2F;&#x2F; 按照声明的顺序调用成员对象的构造函数，c1A constructor: 10   &#x2F;&#x2F; a1A constructor: 0    &#x2F;&#x2F; a0A constructor: 4    &#x2F;&#x2F; a4D constructor       &#x2F;&#x2F; 最后才是自身<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    int x;    A(int x) &#123;this-&gt;x &#x3D; x;&#125;    A(const A &amp;a) &#123;this-&gt;x &#x3D; a.x;&#125;&#125;;int main() &#123;    A a1(5);        &#x2F;&#x2F; 显示调用初始化函数    A a2 &#x3D; 9;       &#x2F;&#x2F; 隐式调用初始化函数    A a3(a1);       &#x2F;&#x2F; 显示调用拷贝构造函数    A a4 &#x3D; a1       &#x2F;&#x2F; 隐式调用拷贝构造函数    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没加<code>explicit</code>时显示调用和隐式调用都可以<br>加了<code>explicit</code>就相当于禁用隐式调用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    int x;    explicit A(int x) &#123;this-&gt;x &#x3D; x;&#125;    explicit A(const A &amp;a) &#123;this-&gt;x &#x3D; a.x;&#125;&#125;;int main() &#123;    A a1(5);        &#x2F;&#x2F; 显示调用初始化函数    &#x2F;&#x2F; A a2 &#x3D; 9;       &#x2F;&#x2F; error    A a3(a1);       &#x2F;&#x2F; 显示调用拷贝构造函数    &#x2F;&#x2F; A a4 &#x3D; a1       &#x2F;&#x2F; error    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C基础</title>
      <link href="2021/04/29/C-C%E5%9F%BA%E7%A1%80/"/>
      <url>2021/04/29/C-C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><ul><li>算术运算符(+(正) -(负) * / % + -)</li><li>关系运算符(&lt; &gt; &lt;= &gt;=)</li><li>关系运算符(== !=)</li><li>逻辑运算符(&amp;&amp; || )</li><li>复制运算符(=)</li></ul><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p><code>new</code>出来的对象存储在堆里面</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>可以用函数指针指向一个函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int Add(int x, int y) &#123;    return x + y;&#125;int main(int argc, char const *argv[])&#123;    int (*func)(int x, int y);    func &#x3D; &amp;Add;    cout &lt;&lt; (*func)(1, 2) &lt;&lt; endl;  &#x2F;&#x2F; 可以对函数指针取值再调用    cout &lt;&lt; func(1, 2) &lt;&lt; endl;     &#x2F;&#x2F; 也可以直接调用    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件操作</title>
      <link href="2021/04/29/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>2021/04/29/C-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="创建文本文件并写入"><a href="#创建文本文件并写入" class="headerlink" title="创建文本文件并写入"></a>创建文本文件并写入</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main(int argc, char const *argv[])&#123;    myFile.open(&quot;test.txt&quot;, ios_base::out);    if (myFile.is_open()) &#123;        cout &lt;&lt; &quot;open file&quot; &lt;&lt; endl;        myFile &lt;&lt; &quot;hello world&quot;;        myFile.close();    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ios_base::out</code>表示以只写模式打开文件，用<code>is_open</code>检查是否成功打开文件</p><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    ifstream myFile;    myFile.open(&quot;test.txt&quot;, ios_base::in);    if (myFile.is_open()) &#123;        cout &lt;&lt; &quot;Open File&quot; &lt;&lt; endl;        string fileContent;        while (myFile.good()) &#123;            getline(myFile, fileContent);            cout &lt;&lt; fileContent &lt;&lt; endl;        &#125;        myFile.close();    &#125;    return 0;&#125;Open Filehello world &#x2F;&#x2F; 输出文件内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>ios_base::in</code>以只读方式打开文件，循环读取文件里的所有字符，保存在<code>string</code>类型的<code>fileContent</code>里面</p><h2 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h2><p>可以用<code>stringstream</code>把其他类型的数据转换为<code>string</code>类型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main() &#123;    int input &#x3D; 34;    stringstream str;    str &lt;&lt; input;        string strInput;    str &gt;&gt; strInput;    cout &lt;&lt; strInput &lt;&lt; endl;&#125;34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试_1</title>
      <link href="2021/04/28/%E9%9D%A2%E8%AF%95-1/"/>
      <url>2021/04/28/%E9%9D%A2%E8%AF%95-1/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="变量的声明和定义有声明区别"><a href="#变量的声明和定义有声明区别" class="headerlink" title="变量的声明和定义有声明区别"></a>变量的声明和定义有声明区别</h2><p>变量的定义是为变量分配地址和存储空间，变量的声明不分配地址。<br>一个变量可以在多个地方声明，但是只在一个地方定义。<br>加入<code>extern</code>修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分定义。<br><strong>说明</strong>：很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main() &#123;    extern int A;    &#x2F;&#x2F; 这是声明不是定义，声明A是一个外部变量    &#x2F;&#x2F; 注意：声明外部变量时可以把变量类型去掉，如：extern A;&#125;int A;  &#x2F;&#x2F; 定义，定义了A为整形的外部变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="简述-ifdef、-else、-endif和-ifndef的作用"><a href="#简述-ifdef、-else、-endif和-ifndef的作用" class="headerlink" title="简述#ifdef、#else、#endif和#ifndef的作用"></a>简述#ifdef、#else、#endif和#ifndef的作用</h2><p>利用<code>#ifdef</code>、<code>#endif</code>将某程序功能模块包括进去，以向特定用户提供该功能<br>在不需要时用户可轻易将其屏蔽。 </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#ifdef __MATH__ #include &quot;math.c&quot; #endif <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在子程序前加上标记，以便于追踪和调试。 </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#ifdef DEBUGprintf (&quot;In debugging......!&quot;);#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应对硬件的限制。由于一些具体应用环境的硬件不一样，限于条件，本地缺乏这种设备，只能绕过硬件，直接写出预期结果。<br><strong>注意</strong>：虽然不用条件编译命令而直接用<code>if</code>语句也能达到要求，但那样做目标程序长（因为所有语句都编译），运行时间长因为在程序运行时间对<code>if</code>语句进行测试）。<br>而采用条件编译，可以减少被编译的语句，从而减少目标程序的长度，减少运行时间</p><h2 id="写出int-bool-float-指针变量与“零值”比较的if语句"><a href="#写出int-bool-float-指针变量与“零值”比较的if语句" class="headerlink" title="写出int/bool/float/指针变量与“零值”比较的if语句"></a>写出int/bool/float/指针变量与“零值”比较的if语句</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; int与零值比较if (n &#x3D;&#x3D; 0)if (n !&#x3D; 0)&#x2F;&#x2F; bool与零值比较 if (flag)     &#x2F;&#x2F; 表示flag为真 if (!flag)    &#x2F;&#x2F; 表示flag为假 &#x2F;&#x2F; float与零值比较 const float EPSINON &#x3D; 0.00001;if ((x &gt;&#x3D; -EPSINON) &amp;&amp; (x &lt;&#x3D; EPSINON)) &#x2F;&#x2F;其中EPSINON是允许的误差（即精度） &#x2F;&#x2F; 指针变量与零值比较 if (p &#x3D;&#x3D; NULL)if (p !&#x3D; NULL)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构体可以直接赋值吗"><a href="#结构体可以直接赋值吗" class="headerlink" title="结构体可以直接赋值吗"></a>结构体可以直接赋值吗</h2><p>声明时可以直接初始化，同一结构体的不同对象之间也可以直接赋值，但是当结构体中含有指针成员时一定要小心。<br><strong>注意</strong>：当有多个指针指向同一段内存时，某个指针释放这段内存可能会导致其他指针的非法操作，因此在释放前一定要确保其他指针不再使用这段内存空间</p><h2 id="sizeof-和strlen-的区别"><a href="#sizeof-和strlen-的区别" class="headerlink" title="sizeof 和strlen 的区别"></a>sizeof 和strlen 的区别</h2><ul><li><code>sizeof</code>是一个操作符，<code>strlen</code>是库函数。</li><li><code>sizeof</code>的参数可以是数据的类型，也可以是变量，而<code>strlen</code>只能以结尾为<code>&#39;\0&#39;</code>的字符串作参数。</li><li>编译器在编译时就计算出了sizeof的结果，而<code>strlen</code>函数必须在运行时才能计算出来。并且<code>sizeof</code>计算的是数据类型占内存的大小，而<code>strlen</code>计算的是字符串实际的长度。</li><li>数组做<code>sizeof</code>的参数不退化，传递给<code>strlen</code>就退化为指针了</li></ul><h2 id="C-语言的关键字-static-和-C-的关键字-static-有什么区别"><a href="#C-语言的关键字-static-和-C-的关键字-static-有什么区别" class="headerlink" title="C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"></a>C 语言的关键字 static 和 C++ 的关键字 static 有什么区别</h2><p>在<code>C</code>中<code>static</code>用来修饰局部静态变量和外部静态变量、函数。而<code>C++</code>中除了上述功能外，还用来定义类的成员变量和函数，即静态成员和静态成员函数<br><strong>注意</strong>：编程时，<code>static</code>的记忆性和全局性的特点可以让在不同时期调用的函数进行通信，而<code>C++</code>的静态成员则可以在多个对象实例间进行通信</p><h2 id="C-语言的-malloc-和-C-中的-new-有什么区别"><a href="#C-语言的-malloc-和-C-中的-new-有什么区别" class="headerlink" title="C 语言的 malloc 和 C++ 中的 new 有什么区别"></a>C 语言的 malloc 和 C++ 中的 new 有什么区别</h2><ul><li><code>new</code>和<code>delete</code>是操作符，可以重载，只能在<code>C++</code>中使用。</li><li><code>malloc</code>和<code>free</code>是函数，可以覆盖，<code>C/C++</code>中都可以使用。</li><li><code>new</code>可以调用对象的构造函数，对应的<code>delete</code>调用相应的析构函数。</li><li><code>malloc</code>仅仅分配内存，<code>free</code>仅仅回收内存，并不执行构造和析构函数</li><li><code>new</code>和<code>delete</code>返回的是某种数据类型指针，<code>malloc</code>和<code>free</code>返回的是<code>void</code>指针。<br>注意：<code>malloc</code>申请的内存空间要用<code>free</code>释放，而<code>new</code>申请的内存空间要用<code>delete</code>释放，不要混用</li></ul><h2 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h2><p><code>size_t</code> 是<code>cstddef</code>头文件定义的一种与机器实现有关的无符号整数类型，他的空间足够大，能够表示任意数的大小</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26/80_removeDuplicates</title>
      <link href="2021/04/27/LeetCode-26-removeDuplicates/"/>
      <url>2021/04/27/LeetCode-26-removeDuplicates/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="LeetCode-26-删除有序数组中的重复项"><a href="#LeetCode-26-删除有序数组中的重复项" class="headerlink" title="LeetCode 26. 删除有序数组中的重复项"></a>LeetCode 26. 删除有序数组中的重复项</h2><p>给你一个有序数组nums，请你<strong>原地</strong>删除重复出现的元素，使每个元素<strong>只出现一次</strong>，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组 并在使用<code>O(1)</code>额外空间的条件下完成。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：nums &#x3D; [1,1,2]输出：2, nums &#x3D; [1,2]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="解法一：用STL提供的算法unique和erase"><a href="#解法一：用STL提供的算法unique和erase" class="headerlink" title="解法一：用STL提供的算法unique和erase"></a>解法一：用STL提供的算法unique和erase</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;        auto it &#x3D; unique(nums.begin(), nums.end());        nums.erase(it, nums.end());        return nums.size();    &#125;&#125;;执行用时: 4 ms内存消耗: 13.4 MB&#x2F;&#x2F; 因为他要的是vector的长度，所以直接返回有用部分的长度就可以了class Solution &#123;public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;        auto it &#x3D; unique(nums.begin(), nums.end());        return distance(nums.begin(), it);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解法二：用快慢指针思想"><a href="#解法二：用快慢指针思想" class="headerlink" title="解法二：用快慢指针思想"></a>解法二：用快慢指针思想</h2><p>慢指针指向需要被覆盖的地方，如果相同，快指针一直走就是了，慢指针不动。<br>不同的话，慢指针加1，再用快指针的值覆盖慢指针的值。<br>时间复杂度<code>O(n)</code><br>空间复杂度<code>O(1)</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;        if (nums.empty()) return 0;        int index &#x3D; 0;        for (int i &#x3D; 1; i &lt; nums.size(); i++) &#123;            if (nums[i] !&#x3D; nums[index - 1]) &#123;                nums[index] &#x3D; nums[i];                index++;            &#125;        return index;    &#125;&#125;;执行用时: 12 ms内存消耗: 13.2 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="80-删除有序数组中的重复项-II"><a href="#80-删除有序数组中的重复项-II" class="headerlink" title="80. 删除有序数组中的重复项 II"></a>80. 删除有序数组中的重复项 II</h2><p>慢指针指向需要被覆盖的地方，如果相同，快指针一直走就是了，慢指针不动。<br>不同的话，慢指针加1，再用快指针的值覆盖慢指针的值。<br>时间复杂度<code>O(n)</code><br>空间复杂度<code>O(1)</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;        if (nums.size() &lt;&#x3D; 2) return nums.size();        int index &#x3D; 2;        for (int i &#x3D; 2; i &lt; nums.size(); i++) &#123;            if (nums[i] !&#x3D; nums[index - 2]) &#123;                nums[index] &#x3D; nums[i];                index++;            &#125;        &#125;        return index;    &#125;&#125;;执行用时: 4 ms内存消耗: 10.7 MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果是允许<code>N</code>个元素重复 </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;        if (nums.size() &lt;&#x3D; N) return nums.size();        int index &#x3D; N;        for (int i &#x3D; N; i &lt; nums.size(); i++) &#123;            if (nums[i] !&#x3D; nums[index - N]) &#123;                nums[index] &#x3D; nums[i];                index++;            &#125;        &#125;        return index;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-bitset</title>
      <link href="2021/04/27/C-STL-STL-bitset/"/>
      <url>2021/04/27/C-STL-STL-bitset/</url>
      
        <content type="html"><![CDATA[<p>位标志只能在初始化时指定大小，后面不能再改</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;bitset&gt;using namespace std;int main(int argc, char const *argv[]) &#123;    bitset&lt;4&gt; fourbit(&quot;1011&quot;);    cout &lt;&lt; fourbit &lt;&lt; endl;    cout &lt;&lt; &quot;Num of 1: &quot; &lt;&lt; fourbit.count() &lt;&lt; endl;    bitset&lt;4&gt; fourbit2(~fourbit);    cout &lt;&lt; fourbit2 &lt;&lt; endl;    bitset&lt;4&gt; fourbit3 &#x3D; fourbit.flip();    cout &lt;&lt; fourbit3 &lt;&lt; endl;    bitset&lt;8&gt; eightbit(255);    cout &lt;&lt; eightbit &lt;&lt; endl;    return 0;&#125;1011Num of 1: 30100010011111111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="2021/04/27/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>2021/04/27/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p><code>unique_ptr</code>禁止对指针进行复制和赋值</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Fish &#123;  public:    Fish() &#123;cout &lt;&lt; &quot;constructor&quot; &lt;&lt; endl;&#125;    ~Fish() &#123;cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl;&#125;    void Swim() &#123;        cout &lt;&lt; &quot;Fish swim in water&quot; &lt;&lt; endl;    &#125;&#125;;void MakeFishSwim(const unique_ptr&lt;Fish&gt;&amp; ptr) &#123;    ptr-&gt;Swim();&#125;int main(int argc, char const *argv[]) &#123;    unique_ptr&lt;Fish&gt; pFish(new Fish);    pFish-&gt;Swim();    MakeFishSwim(pFish);    return 0;&#125;constructorFish swim in waterFish swim in waterdestructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="2021/04/27/C-STL-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>2021/04/27/C-STL-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;int main(int argc, char const *argv[]) &#123;    stack&lt;int&gt; st;    st.push(12);    st.push(34);    st.push(56);    while (!st.empty()) &#123;        cout &lt;&lt; st.top() &lt;&lt; &quot; &quot;;        st.pop();    &#125;    cout &lt;&lt; endl;    queue&lt;int&gt; q;    q.push(14);    q.push(25);    q.push(36);    while (!q.empty()) &#123;        cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;;        q.pop();    &#125;    cout &lt;&lt; endl;    return 0;&#125;56 34 12 &#x2F;&#x2F; 先进后出14 25 36 &#x2F;&#x2F; 先进先出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">priority_queue&lt;int&gt; q;q.push(14);q.push(25);q.push(36);while (!q.empty()) &#123;    cout &lt;&lt; q.top() &lt;&lt; &quot; &quot;;    q.pop();&#125;cout &lt;&lt; endl;36 25 14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>lamda表达式</title>
      <link href="2021/04/26/C-lamda/"/>
      <url>2021/04/26/C-lamda/</url>
      
        <content type="html"><![CDATA[<h2 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h2><p>以<code>[]</code>开头，后面是参数列表，比函数对象更简洁</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Print&#123;public:    void operator () (const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;for_each(vi.begin(), vi.end(), Print());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以简写为</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">for_each(vi.begin(), vi.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>[]</code>内可以接受参数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Greater&#123;public:    bool operator () (const int&amp; val) &#123;return (val &gt; 5);&#125;&#125;;auto it &#x3D; find_if(vi.begin(), vi.end(), Greater());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以简写为</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int num &#x3D; 5;auto it &#x3D; find_if(vi.begin(), vi.end(), [num](const int&amp; val) &#123;return (val &gt; num);&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>添加关键字multable可以在lamda表达式内部修改通过[]传入的参数，离开lamda表达式之后就无效了，要在外部有效，需要按引用传递<br>可以用<code>-&gt;</code>指定返回类型</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">[State1, State2](Type var1, Type var2) -&gt; ReturnType&#123; return (value or expression); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="二元lamda表达式"><a href="#二元lamda表达式" class="headerlink" title="二元lamda表达式"></a>二元lamda表达式</h2><p>两个<code>vector</code>中的元素对应相乘</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">transform(vi.begin(), vi.end(), multiple.begin(), result.begin(), [](int&amp; a, int&amp; b) &#123;return a * b;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi;    for (int i &#x3D; 0; i &lt; 10; i++) &#123;        vi.push_back(i);    &#125;    for_each(vi.begin(), vi.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);    cout &lt;&lt; endl;    vector&lt;int&gt; multiple;    for (int i &#x3D; 10; i &lt; 20; i++) &#123;        multiple.push_back(i);    &#125;    for_each(multiple.begin(), multiple.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);    cout &lt;&lt; endl;    vector&lt;int&gt; result;    result.resize(vi.size());    transform(vi.begin(), vi.end(), multiple.begin(), result.begin(), [](int&amp; a, int&amp; b) &#123;return a * b;&#125;);    for_each(result.begin(), result.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);    cout &lt;&lt; endl;    return 0;&#125;0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 0 11 24 39 56 75 96 119 144 171 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通过lamda表达式自定义sort"><a href="#通过lamda表达式自定义sort" class="headerlink" title="通过lamda表达式自定义sort"></a>通过lamda表达式自定义sort</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">for_each(result.begin(), result.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);sort(result.begin(), result.end(), [](int&amp; a, int&amp; b) &#123;return a &gt; b;&#125;);for_each(result.begin(), result.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);0 11 24 39 56 75 96 119 144 171 171 144 119 96 75 56 39 24 11 0     &#x2F;&#x2F; 自定义从大到小排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出满足条件的元素个数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 输出偶数个数cout &lt;&lt; count_if(vi.begin(), vi.end(), [](const int&amp; val) &#123;return !(val % 2);&#125;) &lt;&lt; endl;0 1 2 3 4 5 6 7 8 9 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL常用算法</title>
      <link href="2021/04/24/C-STL-STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>2021/04/24/C-STL-STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="遍历每个元素-for-each"><a href="#遍历每个元素-for-each" class="headerlink" title="遍历每个元素 for_each"></a>遍历每个元素 for_each</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">for_each(vi.begin(), vi.end(), Print());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="查找某个元素-find-find-if"><a href="#查找某个元素-find-find-if" class="headerlink" title="查找某个元素 find/find_if"></a>查找某个元素 find/find_if</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto it &#x3D; find(vi.begin(), vi.end(), 5);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct IsMultiple &#123;    int Divisor;    IsMultiple(int x &#x3D; 0) : Divisor(x) &#123;&#125;    bool operator () (const int&amp; input) &#123;return !(input % Divisor);&#125;&#125;;int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi;    for (size_t i &#x3D; 23; i &lt; 32; i++) &#123;        vi.push_back(i);    &#125;    int Divisor &#x3D; 7;    auto iElement &#x3D; find_if(vi.begin(), vi.end(), IsMultiple(Divisor));    if (iElement !&#x3D; vi.end()) &#123;        cout &lt;&lt; &quot;First element divisible by &quot; &lt;&lt; Divisor;        cout &lt;&lt; &quot;: &quot; &lt;&lt; *iElement &lt;&lt; endl;    &#125;    return 0;&#125;First element divisible by 7: 28<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用了<code>find_if</code>方法<br>对<code>vi</code>里的每个元素调用一元谓词<code>IsMultiple(Divisor)</code>函数对象，找到第一个整除<code>Divisor</code>的数</p><h2 id="转换-transform"><a href="#转换-transform" class="headerlink" title="转换 transform"></a>转换 transform</h2><p>字符串大小写转换</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string str &#x3D; &quot;hello&quot;;string copy;copy.resize(str.size());transform(str.begin(), str.end(), copy.begin(), ::toupper);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>从一个<code>vector</code>转换到另一个<code>vector</code>，进行一些变换</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template&lt;typename T&gt;class Add &#123;public:    T operator () (const T&amp; val) &#123;return (val + 100);&#125;&#125;;transform(vi.begin(), vi.end(), target.begin(), Add&lt;int&gt;());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="计数-count-count-if"><a href="#计数-count-count-if" class="headerlink" title="计数 count/count_if"></a>计数 count/count_if</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">count(vi.begin(), vi.end(), 6)  返回等于6的数量count_if(vi.begin(), vi.end(), Greater())   返回满足条件的数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="复制-copy-copy-if"><a href="#复制-copy-copy-if" class="headerlink" title="复制 copy/copy_if"></a>复制 copy/copy_if</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; copyVec(vi.size() * 2);auto it2 &#x3D; copy(vi.begin(), vi.end(), copyVec.begin());for_each(copyVec.begin(), copyVec.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);cout &lt;&lt; endl;copy_if(vi.begin(), vi.end(), it2, [](int&amp; val) &#123;return (val % 2);&#125;);for_each(copyVec.begin(), copyVec.end(), [](const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;);cout &lt;&lt; endl;0 1 2 3 4 5 6 7 8 9                         &#x2F;&#x2F; vi0 1 2 3 4 5 6 7 8 9 0 0 0 0 0 0 0 0 0 0     &#x2F;&#x2F; 复制了vi的全部元素0 1 2 3 4 5 6 7 8 9 1 3 5 7 9 0 0 0 0 0     &#x2F;&#x2F; 从返回的迭代器位置开始复制vi的奇数元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="搜索-binary-search"><a href="#搜索-binary-search" class="headerlink" title="搜索 binary_search"></a>搜索 binary_search</h2><p>二分查找只能用于已排序的容器，返回<code>true/false</code></p><h2 id="删除-remove-remove-if"><a href="#删除-remove-remove-if" class="headerlink" title="删除 remove/remove_if"></a>删除 remove/remove_if</h2><p><code>remove_if</code>要配合<code>erase</code>使用，因为返回的是无用的部分的迭代器</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; vi;for (size_t i &#x3D; 0; i &lt; 10; i++) &#123;    vi.push_back(i);&#125;info(vi);int x &#x3D; 5;auto it &#x3D; remove_if(vi.begin(), vi.end(), [x](int&amp; val) &#123;return val &lt; x;&#125;);info(vi);cout &lt;&lt; *it &lt;&lt; endl;vi.erase(it, vi.end());info(vi);0 1 2 3 4 5 6 7 8 9 5 6 7 8 9 5 6 7 8 9     &#x2F;&#x2F; 把 5~9替换掉前面的0~45   &#x2F;&#x2F; 返回指向无用部分的第一个元素5 6 7 8 9   &#x2F;&#x2F; 再用erase把后面那些没用的删掉<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除重复元素-unique"><a href="#删除重复元素-unique" class="headerlink" title="删除重复元素 unique"></a>删除重复元素 unique</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto it &#x3D; unique(vi.begin(), vi.end());vi.erase(it, vi.end());info(vi);-1 -1 -1 -1 8 8 8 8-1 8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="替换-replace-replace-if"><a href="#替换-replace-replace-if" class="headerlink" title="替换 replace/replace_if"></a>替换 replace/replace_if</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; vi(8);fill(vi.begin(), vi.begin() + 4, 5);fill_n(vi.begin() + 4, 4, 8);info(vi);replace(vi.begin(), vi.end(), 5, 1);info(vi);replace_if(vi.begin(), vi.end(), [](int&amp; val) &#123;return (val % 2);&#125;, -1);info(vi);5 5 5 5 8 8 8 8         &#x2F;&#x2F; 填充前4格为5，后4歌为81 1 1 1 8 8 8 8         &#x2F;&#x2F; 把5替换成1-1 -1 -1 -1 8 8 8 8     &#x2F;&#x2F; 把奇数替换成-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分区-partition-stable-partition"><a href="#分区-partition-stable-partition" class="headerlink" title="分区 partition/stable_partition"></a>分区 partition/stable_partition</h2><p><code>partition</code>是乱序的<br><code>stable_partition</code>保持原来的顺序</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; partition(vi.begin(), vi.end(), [](int&amp; val) &#123;return (val % 2);&#125;);info(vi);stable_partition(vi.begin(), vi.end(), [](int&amp; val) &#123;return (val % 2);&#125;);info(vi);0 1 2 3 4 5 6 7 8 9 1 3 5 7 9 0 2 4 6 8 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound/upper_bound"></a>lower_bound/upper_bound</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto it &#x3D; lower_bound(vi.begin(), vi.end(), 5);cout &lt;&lt; *it &lt;&lt; endl;it &#x3D; upper_bound(vi.begin(), vi.end(), 5);cout &lt;&lt; *it &lt;&lt; endl;0 1 2 3 4 5 6 7 8 9 5   &#x2F;&#x2F; 小于等于5的最大数是56   &#x2F;&#x2F; 大于5的最小数是6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例：基本数据类型"><a href="#代码示例：基本数据类型" class="headerlink" title="代码示例：基本数据类型"></a>代码示例：基本数据类型</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 这种叫函数对象class Print&#123;public:    void operator () (const int&amp; val) &#123;cout &lt;&lt; val &lt;&lt; &quot; &quot;;&#125;&#125;;class Add&#123;public:    int operator () (const int&amp; val) &#123;return (val + 100);&#125;&#125;;class Greater&#123;public:    bool operator () (const int&amp; val) &#123;return (val &gt; 5);&#125;&#125;;int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi;    for (int i &#x3D; 0; i &lt; 10; i++) &#123;        vi.push_back(i);    &#125;    for_each(vi.begin(), vi.end(), Print());    cout &lt;&lt; endl;    auto it &#x3D; find(vi.begin(), vi.end(), 5);    if (it !&#x3D; vi.end()) &#123;        cout &lt;&lt; *it &lt;&lt; endl;    &#125;    cout &lt;&lt; binary_search(vi.begin(), vi.end(), 8) &lt;&lt; endl;    it &#x3D; find_if(vi.begin(), vi.end(), Greater());    if (it !&#x3D; vi.end()) &#123;        cout &lt;&lt; &quot;Found greater than five: &quot; &lt;&lt; *it &lt;&lt; endl;    &#125;    vi.push_back(6);    cout &lt;&lt; &quot;number of six: &quot; &lt;&lt; count(vi.begin(), vi.end(), 6) &lt;&lt; endl;    cout &lt;&lt; &quot;num of greater than five: &quot; &lt;&lt; count_if(vi.begin(), vi.end(), Greater()) &lt;&lt; endl;    vector&lt;int&gt; target;    target.resize(vi.size());    transform(vi.begin(), vi.end(), target.begin(), Add());    for_each(target.begin(), target.end(), Print());    cout &lt;&lt; endl;    return 0;&#125;0 1 2 3 4 5 6 7 8 9 51   &#x2F;&#x2F; binary_search的返回值是true&#x2F;false，表示是否找到该元素Found greater than five: 6number of six: 2num of greater than five: 5100 101 102 103 104 105 106 107 108 109 106 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例：自定义数据类型Person"><a href="#代码示例：自定义数据类型Person" class="headerlink" title="代码示例：自定义数据类型Person"></a>代码示例：自定义数据类型Person</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;class Person&#123;public:    string name;    int age;    Person(string _name, int _age): name(_name), age(_age) &#123;&#125;    bool operator &#x3D;&#x3D; (const Person&amp; input) &#123;        if (this-&gt;age &#x3D;&#x3D; input.age) &#123;            return true;        &#125;        else &#123;            return false;        &#125;    &#125;&#125;;class Add&#123;public:    int operator () (const int&amp; val) &#123;return (val + 100);&#125;&#125;;class GreaterAge&#123;public:    bool operator () (const Person&amp; input) &#123;        return (input.age &gt; 20);    &#125;&#125;;int main(int argc, char const *argv[])&#123;    printf(&quot;&gt;&gt;&gt;&gt;&gt;自定义数据类型&lt;&lt;&lt;&lt;&lt;&lt;\n&quot;);    vector&lt;Person&gt; person;    Person p1(&quot;kavin&quot;, 23);    Person p2(&quot;jack&quot;, 12);    Person p3(&quot;lisa&quot;, 12);    person.push_back(p1);    person.push_back(p2);    person.push_back(p3);    Person test(&quot;kavin&quot;, 23);    auto it2 &#x3D; find(person.begin(), person.end(), test);    if (it2 !&#x3D; person.end()) &#123;        cout &lt;&lt; &quot;Found test: &quot; &lt;&lt; it2-&gt;name &lt;&lt; &quot;, &quot; &lt;&lt; it2-&gt;age &lt;&lt; endl;    &#125;    auto it3 &#x3D; find_if(person.begin(), person.end(), GreaterAge());    if (it3 !&#x3D; person.end()) &#123;        cout &lt;&lt; &quot;Found age &gt; 20: &quot; &lt;&lt; it3-&gt;name &lt;&lt; &quot;, &quot; &lt;&lt; it3-&gt;age &lt;&lt; endl;    &#125;    Person p(&quot;test&quot;, 12);    cout &lt;&lt; &quot;same age: &quot; &lt;&lt; count(person.begin(), person.end(), p) &lt;&lt; endl;    cout &lt;&lt; &quot;num of age &gt; 20: &quot; &lt;&lt; count_if(person.begin(), person.end(), GreaterAge()) &lt;&lt; endl;    return 0;&#125;Found test: kavin, 23Found age &gt; 20: kavin, 23same age: 2num of age &gt; 20: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一元谓词"><a href="#一元谓词" class="headerlink" title="一元谓词"></a>一元谓词</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template&lt;typename T&gt;struct Count&#123;    int count;    Count(int x &#x3D; 0) : count(x) &#123;&#125;    void operator () (const T&amp; input) &#123;        ++count;        cout &lt;&lt; input &lt;&lt; &quot; &quot;;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi;    for (size_t i  &#x3D; 0; i &lt; 10; i++) &#123;        vi.push_back(i);    &#125;    Count&lt;int&gt; res;    &#x2F;&#x2F; Count&lt;int&gt;() 是函数对象    res &#x3D; for_each(vi.begin(), vi.end(), Count&lt;int&gt;());    cout &lt;&lt; endl;    cout &lt;&lt; res.count &lt;&lt; endl;    return 0;&#125;0 1 2 3 4 5 6 7 8 910<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对<code>vi</code>里的每个元素调用了<code>Count&lt;int&gt;()</code>函数，所以在<code>res</code>内部<code>count++</code>执行了10次，所以最后<code>count = 10</code></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-map</title>
      <link href="2021/04/24/C-STL-STL-map/"/>
      <url>2021/04/24/C-STL-STL-map/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="映射map"><a href="#映射map" class="headerlink" title="映射map"></a>映射map</h2><p><code>map</code>可以存储键-值对，不能重复的键，可以按键的大小排序，或者自定义<br><code>multimap</code>可以重复的键<br><code>unordered_map</code>查找时间复杂度为常数</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">map&lt;int, string, Compare&lt;int&gt;&gt; mapIntToString;int --&gt; stringCompare&lt;int&gt; 是排序结构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="构造键值对"><a href="#构造键值对" class="headerlink" title="构造键值对"></a>构造键值对</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mapIntToString.insert(make_pair(23, &quot;kavin&quot;));mapIntToString.insert(pair&lt;int, string&gt;(10, &quot;jack&quot;));mapIntToString[100] &#x3D; &quot;lisa&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;&#x2F;&#x2F; 自定义的排序结构template&lt;typename T&gt;struct Compare&#123;    bool operator () (const T&amp; key1, const T&amp; key2) const &#123;        return key1 &gt; key2;    &#125;&#125;;template&lt;typename T&gt;void info(const T&amp; se) &#123;    cout &lt;&lt; &quot;INFO: &quot;;    for (auto it &#x3D; se.begin(); it !&#x3D; se.end(); it++) &#123;        cout &lt;&lt; &quot;(&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;)&quot; &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    map&lt;int, string, Compare&lt;int&gt;&gt; mapIntToString;    mapIntToString.insert(make_pair(23, &quot;kavin&quot;));    mapIntToString.insert(pair&lt;int, string&gt;(10, &quot;jack&quot;));    mapIntToString[100] &#x3D; &quot;lisa&quot;;    info(mapIntToString);    auto it &#x3D; mapIntToString.find(100);    if (it !&#x3D; mapIntToString.end()) &#123;        cout &lt;&lt; &quot;Found: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    &#x2F;&#x2F; mapIntToString.erase(it);    mapIntToString.erase(10);    info(mapIntToString);    return 0;&#125;INFO: (100-&gt;lisa) (23-&gt;kavin) (10-&gt;jack) Found: 100-&gt;lisaINFO: (100-&gt;lisa) (23-&gt;kavin) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    multimap&lt;int, string&gt; multimapIntToString(mapIntToString.begin(), mapIntToString.end());    multimapIntToString.insert(make_pair(100, &quot;lili&quot;));    info(multimapIntToString);    cout &lt;&lt; multimapIntToString.count(100) &lt;&lt; endl;    it &#x3D; multimapIntToString.find(100);    if (it !&#x3D; multimapIntToString.end()) &#123;        size_t numOfKey &#x3D; multimapIntToString.count(100);        for (size_t i &#x3D; 0; i &lt; numOfKey; i++) &#123;            cout &lt;&lt; &quot;Found: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;-&gt;&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;            ++it;        &#125;    &#125;    return 0;&#125;INFO: (100-&gt;lisa) (23-&gt;kavin) INFO: (23-&gt;kavin) (100-&gt;lisa) (100-&gt;lili) 2Found: 100-&gt;lisaFound: 100-&gt;lili<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用循环的方式遍历找到的值</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-set</title>
      <link href="2021/04/23/C-STL-STL-set/"/>
      <url>2021/04/23/C-STL-STL-set/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><p>集合内部元素是有序的不能重复<br>不能通过指针修改元素的值，只能删掉，重新插入<br><code>multiset</code>可以添加重复元素</p><ul><li>插入元素 </li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Integer.insert(12);multiInteger.insert(Integer.begin(), Integer.end());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>查找元素</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto it &#x3D; Integer.find(23);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>删除元素</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Integer.erase(it);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>统计元素个数（针对multiset）</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">multiInteger.count(10)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查找第一个大于或小于某个值的数</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">upper_bound()lower_bound()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="代码示例1-set与multiset"><a href="#代码示例1-set与multiset" class="headerlink" title="代码示例1: set与multiset"></a>代码示例1: set与multiset</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;struct Contact&#123;    string name;    int num;    Contact(const string&amp; _name, const int&amp; _num) &#123;        name &#x3D; _name;        num &#x3D; _num;    &#125;    bool operator &lt; (const Contact&amp; itemToCompare) const &#123;        return this-&gt;num &lt; itemToCompare.num;    &#125;    void display() const &#123;        cout &lt;&lt; &quot;name&#x3D;&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;, num&#x3D;&quot; &lt;&lt; this-&gt;num &lt;&lt; endl;    &#125;&#125;;template&lt;typename T&gt;void info(const T&amp; se) &#123;    cout &lt;&lt; &quot;INFO: &quot;;    for (auto&amp; s : se) &#123;        cout &lt;&lt; s &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    set&lt;int&gt; Integer;    Integer.insert(12);    Integer.insert(23);    Integer.insert(1);    info(Integer);    it &#x3D; Integer.upper_bound(10);    if (it !&#x3D; Integer.end())        cout &lt;&lt; &quot;Found: &quot; &lt;&lt; *it &lt;&lt; endl;    else        cout &lt;&lt; &quot;NOT Found&quot; &lt;&lt; endl;    auto it &#x3D; Integer.find(23);    if (it !&#x3D; Integer.end()) &#123;        cout &lt;&lt; *it &lt;&lt; endl;    &#125;    Integer.erase(it);    info(Integer);    Integer.clear();    info(Integer);    multiset&lt;int&gt; multiInteger;    multiInteger.insert(10);    multiInteger.insert(10);    multiInteger.insert(Integer.begin(), Integer.end());    info(multiInteger);    cout &lt;&lt; multiInteger.count(10) &lt;&lt; endl;    return 0;&#125;INFO: 1 12 23 Found: 12   &#x2F;&#x2F; 找到第一个大于10的元素23INFO: 1 12 INFO: INFO: 10 10 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例2-存储结构体"><a href="#代码示例2-存储结构体" class="headerlink" title="代码示例2: 存储结构体"></a>代码示例2: 存储结构体</h2><p>要重载&lt;和==运算符，前者用于排序，后者用于查找<br><strong>问题</strong><br>用哪个值去实现&lt;运算符，也会用那个值去find</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct Contact&#123;    string name;    int num;    Contact(const string&amp; _name, const int&amp; _num) &#123;        name &#x3D; _name;        num &#x3D; _num;    &#125;    &#x2F;&#x2F; 如果这里用num去排序，查找时也是看num相不相同    bool operator &lt; (const Contact&amp; itemToCompare) const &#123;        return (this-&gt;name &lt; itemToCompare.name);    &#125;    &#x2F;&#x2F; 所以这里的规则最好一样    bool operator &#x3D;&#x3D; (const Contact&amp; itemToCompare) const &#123;        return (this-&gt;name &#x3D;&#x3D; itemToCompare.name);    &#125;    void display() const &#123;        cout &lt;&lt; &quot;name&#x3D;&quot; &lt;&lt; this-&gt;name &lt;&lt; &quot;, num&#x3D;&quot; &lt;&lt; this-&gt;num &lt;&lt; endl;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    const string NameInput &#x3D; &quot;kavin&quot;;    auto iterator &#x3D; setContacts.find(Contact(NameInput, 0));    if (iterator !&#x3D; setContacts.end()) &#123;        cout &lt;&lt; &quot;Found: &quot;;        iterator-&gt;display();    &#125;    else &#123;        cout &lt;&lt; &quot;NOT Found!!!&quot; &lt;&lt; endl;    &#125;    return 0;&#125;name&#x3D;jack, num&#x3D;23name&#x3D;joke, num&#x3D;0name&#x3D;kavin, num&#x3D;12name&#x3D;lisa, num&#x3D;34Found: name&#x3D;kavin, num&#x3D;12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到输入的是<code>(&quot;kavin&quot;,0)</code>，但是他还是找到了<code>(&quot;kavin&quot;,12)</code>，因为相等的规则是名字相同就可以</p><h2 id="散列表unordered-set"><a href="#散列表unordered-set" class="headerlink" title="散列表unordered_set"></a>散列表unordered_set</h2><p>无序的集合，不能重复<br>但是可以实现查找时间复杂度为常数<br><code>unordered_multiset</code>可以存储重复元素<br>查找、删除、</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;unordered_set&gt;using namespace std;template&lt;typename T&gt;void info(const T&amp; input) &#123;    cout &lt;&lt; &quot;Size&#x3D;&quot; &lt;&lt; input.size() &lt;&lt; endl;    cout &lt;&lt; &quot;Max bucket&#x3D;&quot; &lt;&lt; input.max_bucket_count() &lt;&lt; endl;    cout &lt;&lt; &quot;Load factor&#x3D;&quot; &lt;&lt; input.load_factor() &lt;&lt; endl;    cout &lt;&lt; &quot;INFO: &quot;;    for (auto&amp; s : input) &#123;        cout &lt;&lt; s &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    unordered_set&lt;int&gt; num &#x3D; &#123;45, 23, 78, 54&#125;;    info(num);    auto it &#x3D; num.find(78);    if (it !&#x3D; num.end()) &#123;        cout &lt;&lt; &quot;Found: &quot; &lt;&lt; *it &lt;&lt; endl;    &#125;    num.erase(it);    info(num);    return 0;&#125;Size&#x3D;4  &#x2F;&#x2F; 当前存储的元素个数Max bucket&#x3D;1152921504606846975  &#x2F;&#x2F; 最大可存储的元素数Load factor&#x3D;0.8INFO: 54 78 23 45 Found: 78Size&#x3D;3Max bucket&#x3D;1152921504606846975Load factor&#x3D;0.6INFO: 54 23 45 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-list</title>
      <link href="2021/04/23/C-STL-STL-list/"/>
      <url>2021/04/23/C-STL-STL-list/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="list双向链表"><a href="#list双向链表" class="headerlink" title="list双向链表"></a>list双向链表</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;list&gt;using namespace std;struct Contact&#123;    string name;    int num;    Contact(const string&amp; _name, const int&amp; _num) &#123;        name &#x3D; _name;        num &#x3D; _num;    &#125;    &#x2F;&#x2F; 需要重载&quot;&lt;&quot;运算符，让list知道怎么排序    bool operator &lt; (const Contact&amp; itemToCompare) const &#123;        return this-&gt;num &lt; itemToCompare.num;    &#125;&#125;;&#x2F;&#x2F; 自定义二元谓词函数实现自定义排序顺序bool descending(const int&amp; lsh, const int&amp; rsh) &#123;    return lsh &gt; rsh;&#125;int main(int argc, char const *argv[])&#123;    list&lt;int&gt; li &#x3D; &#123;12, 23&#125;;    info(li);       &#x2F;&#x2F; 12 23     li.push_back(100);  &#x2F;&#x2F; 从尾部插入    li.push_front(-1);  &#x2F;&#x2F; 从头部插入    info(li);       &#x2F;&#x2F; -1 12 23 100    li.insert(li.begin(), 2, 20);    info(li);       &#x2F;&#x2F; 20 20 -1 12 23 100     li.pop_back();  &#x2F;&#x2F; 从尾部弹出    li.pop_front(); &#x2F;&#x2F; 从头部弹出    info(li);    &#x2F;&#x2F; 20 -1 12 23     li.reverse();   &#x2F;&#x2F; 翻转    info(li);    &#x2F;&#x2F; 23 12 -1 20     li.sort();      &#x2F;&#x2F; 默认是从小到大排序    info(li);    &#x2F;&#x2F; -1 12 20 23     li.sort(descending);    &#x2F;&#x2F; 自定义从大到小排序    info(li);    &#x2F;&#x2F; 23 20 12 -1     Contact c1(&quot;kavin&quot;, 12);    Contact c2(&quot;jack&quot;, 23);    Contact c3(&quot;lisa&quot;, 34);    list&lt;Contact&gt; contacts &#x3D; &#123;c1, c2, c3&#125;;    contacts.sort();    for (auto it : contacts) &#123;        it.info();    &#125;    return 0;&#125;name&#x3D;kavin, num&#x3D;12name&#x3D;jack, num&#x3D;23name&#x3D;lisa, num&#x3D;34<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-vector</title>
      <link href="2021/04/20/C-STL-STL-vector/"/>
      <url>2021/04/20/C-STL-STL-vector/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="vector动态数组"><a href="#vector动态数组" class="headerlink" title="vector动态数组"></a>vector动态数组</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol><li>初始化列表</li><li>n个相同的元素</li><li>复制另一个vector初始化</li><li>复制另一个vector的一部分初始化</li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi &#x3D; &#123;20, 30&#125;;    vi.push_back(45);    vi.push_back(67);    for (auto&amp; v : vi) &#123;        cout &lt;&lt; v &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        vector&lt;int&gt; vec1(5, 23);    for (auto&amp; v : vec1) &#123;        cout &lt;&lt; v &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    vector&lt;int&gt; vec2(vec1);    for (auto&amp; v : vec2) &#123;        cout &lt;&lt; v &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    vector&lt;int&gt; vec3(vec1.begin(), vec1.begin() + 3);    for (auto&amp; v : vec3) &#123;        cout &lt;&lt; v &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;20 30 45 6723 23 23 23 23 23 23 23 23 23 23 23 23 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">auto it &#x3D; find(vi.begin(), vi.end(), 67);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><ol><li>在某个位置插入一个元素</li><li>在某个位置插入n个相同的元素</li><li>在某个位置插入另一个vector的元素</li></ol><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    vector&lt;int&gt; vi &#x3D; &#123;20, 30&#125;;    vi.push_back(45);    vi.push_back(67);    vi.insert(vi.begin(), 123);    vi.insert(vi.end(), 2, 89);    vector&lt;int&gt; temp(3, 100);    vi.insert(vi.begin() + 1, temp.begin(), temp.end());    return 0;&#125;20 30 45 67 123 20 30 45 67     &#x2F;&#x2F; 在头部插入一个元素123 20 30 45 67 89 89   &#x2F;&#x2F; 在尾部插入2个相同的元素123 100 100 100 20 30 45 67 89 89   &#x2F;&#x2F; 在第一个元素位置插入一个vector<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">begin()end()cbegin()cend()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><ol><li>迭代器</li><li>下标运算符[]</li><li>成员函数at()</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main() &#123;    vector&lt;int&gt; vi;    vi.push_back(45);    vi.push_back(67);    cout &lt;&lt; *vi.cbegin() &lt;&lt; endl;    auto it &#x3D; find(vi.begin(), vi.end(), 67);    if (it !&#x3D; vi.end()) &#123;        int index &#x3D; distance(vi.begin(), it);        cout &lt;&lt; *it &lt;&lt; endl;        cout &lt;&lt; index;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pop_back()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="大小和容量"><a href="#大小和容量" class="headerlink" title="大小和容量"></a>大小和容量</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size(): 返回vector大小capacity(): 返回vector容量，容量不够时会自动重新分配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">push_front(): 从头部插入pop_front(): 从头部弹出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template&lt;typename T&gt;void info(const deque&lt;T&gt;&amp; q) &#123;    for (auto&amp; x : q) &#123;        cout &lt;&lt; x &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;void disp(const deque&lt;int&gt;&amp; q) &#123;    for (auto it &#x3D; q.begin(); it !&#x3D; q.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    deque&lt;int&gt; q;    q.push_back(10);    q.push_back(11);    q.push_back(12);    q.push_front(9);    info(q);    q.pop_back();    q.pop_front();    disp(q);    return 0;&#125;9 10 11 12 10 11 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载=运算符</title>
      <link href="2021/04/20/C-%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2021/04/20/C-%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><p>运算符重载是C++的一项强大功能。通过重载，可以扩展C++运算符的功能，使它们能够操作用户自定义的数据类型，增加程序代码的直观性和可读性。</p><p>本章主要介绍 类成员运算符重载与友元运算符重载，二元运算符与一元运算符重载，运算符++、–、[]、()重载，this指针与运算符重载及 流运算符&lt;&lt;和&gt;&gt;的重载</p><h2 id="一、重载二元运算符"><a href="#一、重载二元运算符" class="headerlink" title="一、重载二元运算符"></a>一、重载二元运算符</h2><h3 id="二元运算符的调用形式与解析"><a href="#二元运算符的调用形式与解析" class="headerlink" title="二元运算符的调用形式与解析"></a>二元运算符的调用形式与解析</h3><pre class="line-numbers language-py" data-language="py"><code class="language-py">aa@bb可解释成: aa.operator@(bb)或解释成: operator@(aa,bb)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果两者都有定义,就按照重载解析</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class X&#123;public:    void operator + (int);    X(int);&#125;;void operator + (X, X);void operator + (X, double);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="类运算符重载形式"><a href="#类运算符重载形式" class="headerlink" title="类运算符重载形式"></a>类运算符重载形式</h3><h4 id="非静态成员运算符重载"><a href="#非静态成员运算符重载" class="headerlink" title="非静态成员运算符重载"></a>非静态成员运算符重载</h4><p>以类成员形式重载的运算符参数比实际参数少一个，第1个参数是以<code>this</code>指针隐式传递的。 </p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Complex&#123;    double real,image;public:    Complex operator+(Complex b)&#123;&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="友元运算符重载"><a href="#友元运算符重载" class="headerlink" title="友元运算符重载"></a>友元运算符重载</h4><p>如果将运算符函数作为类的友元重载，它需要的参数个数就与运算符实际需要的参数个数相同。比如，若用友元函数重载Complex类的加法运算符，则形式如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Complex&#123;    friend Complex operator+(Complex a,Complex b);  &#x2F;&#x2F;声明&#125;;Complex operator+(Complex a,Complex b)&#123;&#125;         &#x2F;&#x2F;定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、重载一元运算符"><a href="#二、重载一元运算符" class="headerlink" title="二、重载一元运算符"></a>二、重载一元运算符</h2><p>一元运算符只需要一个运算参数，如取地址运算符（&amp;）、负数（-）、自增加（++）等。</p><p>常见调用形式为：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">@a 或 a@  &#x2F;&#x2F;隐式调用形式a.operator@()   &#x2F;&#x2F; 显式调用一元运算符@其中的@代表一元运算符，a代表操作数。@a代表前缀一元运算，如“++a”；a@表示后缀运算，如“a++”。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>@a将被C++解释为下面的形式之一</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">a.operator@()operator@(a) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一元运算符作为类成员函数重载时不需要参数，其形式如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class X&#123;    T operator@()&#123;&#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>T是运算符@的返回类型。从形式上看，作为类成员函数重载的一元运算符没有参数，但实际上它包含了一个隐含参数<br>即调用对象的this指针。</p><h3 id="前自增-减-与后自增-减"><a href="#前自增-减-与后自增-减" class="headerlink" title="前自增(减)与后自增(减)"></a>前自增(减)与后自增(减)</h3><p>C++编译器可以通过在运算符函数参数表中是否插入关键字<code>int</code>来区分这两种方式</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;前缀operator -- ();operator -- (X &amp; x);&#x2F;&#x2F;后缀operator -- (int);operator -- (X &amp; x, int);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、重载赋值运算符"><a href="#三、重载赋值运算符" class="headerlink" title="三、重载赋值运算符="></a>三、重载赋值运算符<code>=</code></h2><p>赋值运算进行时将调用此运算符</p><p>只能用成员函数重载</p><p>如果需要而没有定义时，编译器自动生成，该版本进行<code>bit-by-bit</code>拷贝</p><h2 id="四、重载"><a href="#四、重载" class="headerlink" title="四、重载[]"></a>四、重载<code>[]</code></h2><p>1、<code>[]</code>是一个二元运算符，其重载形式如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class X&#123;    X&amp; operator[](int n);&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2、 重载<code>[]</code>需要注意的问题</p><ul><li><code>[]</code>是一个二元运算符，其第1个参数是通过对象的<code>this</code>指针传递的，第2个参数代表数组的下标</li><li>由于<code>[]</code>既可以出现在赋值符<code>=</code>的左边，也可以出现在赋值符<code>=</code>的右边，所以重载运算符<code>[]</code>时常返回引用。</li><li><strong><code>[]</code>只能被重载为类的非静态成员函数，不能被重载为友元和普通函数</strong>。</li></ul><h2 id="五、重载"><a href="#五、重载" class="headerlink" title="五、重载()"></a>五、重载<code>()</code></h2><p>1、运算符<code>()</code>是函数调用运算符，也能被重载。且只能被重载为类的成员函数。</p><p>2、运算符<code>()</code>的重载形式如下：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class X&#123;    X&amp; operator()(参数表);&#125;；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中的参数表可以包括任意多个参数。</p><p>3、运算符( )的调用形式如下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">X Obj;      &#x2F;&#x2F;对象定义Obj()(参数表);      &#x2F;&#x2F;调用形式1Obj(参数表);        &#x2F;&#x2F;调用形式2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="六、代码示例"><a href="#六、代码示例" class="headerlink" title="六、代码示例"></a>六、代码示例</h2><p>返回值要写成类引用<code>Class&amp;</code>，不然会再调用构造函数新建一个临时变量</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A&#123;public:    A(int val &#x3D; 0): x(val) &#123;         cout &lt;&lt; &quot;A: constructor. &quot;;         cout &lt;&lt; &quot;x &#x3D; &quot; &lt;&lt; val &lt;&lt; endl;    &#125;    &#x2F;&#x2F;返回引用类型    A&amp; operator &#x3D; (const A&amp; input) &#123;        cout &lt;&lt; &quot;copy Assignment&quot; &lt;&lt; endl;        x &#x3D; input.x;        return *this;    &#125;private:    int x;&#125;;int main(int argc, char const *argv[])&#123;    A a(34), b;    b &#x3D; a;    b.operator&#x3D;(a); &#x2F;&#x2F;写成这样也可以    A c &#x3D; a;    &#x2F;&#x2F; 写成这样就不会调用复制赋值运算符函数，编译器内部实现了    return 0;&#125;A: constructor. x &#x3D; 34A: constructor. x &#x3D; 0copy Assignment &#x2F;&#x2F; 调用了复制复制运算符函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载运算符</title>
      <link href="2021/04/18/C-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2021/04/18/C-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="project-1-重载-运算符"><a href="#project-1-重载-运算符" class="headerlink" title="project 1 重载()运算符"></a>project 1 重载()运算符</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Clock &#123;private:    int hour, minute, second;public:    Clock(int h, int m, int s) : hour(h), minute(m), second(s) &#123;&#125;    &#x2F;&#x2F; 重载()运算符    void operator()(int h, int m, int s) &#123;        hour &#x3D; h;        minute &#x3D; m;        second &#x3D; s;    &#125;    void ShowTime() &#123;        cout &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; second &lt;&lt; endl;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    Clock t1(12, 34, 45);    t1.ShowTime();    t1.operator()(10, 21, 32);    t1.ShowTime();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="project-2-重载-和-运算符"><a href="#project-2-重载-和-运算符" class="headerlink" title="project 2 重载()和[]运算符"></a>project 2 重载()和[]运算符</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;using namespace std;class X&#123;public:    int operator() (int i &#x3D; 0) &#123;        cout &lt;&lt; &quot;X operator (&quot; &lt;&lt; i &lt;&lt; &quot;)&quot; &lt;&lt; endl;        return i;    &#125;    int operator[] (int j) &#123;        cout &lt;&lt; &quot;X operator [&quot; &lt;&lt; j &lt;&lt; &quot;]&quot; &lt;&lt; endl;        return j;    &#125;&#125;;int main (void)&#123;       X obj;    int i &#x3D; obj(1);    cout &lt;&lt; i &lt;&lt; endl;    int j &#x3D; obj[234];    cout &lt;&lt; j &lt;&lt; endl;    return 0;&#125;X operator (1)1X operator [234]234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sublime</code>的代码复制到<code>VScode</code>之后会出现空格不一致的问题，解决方法是在<code>sublime</code>中把<code>tab</code>替换为空格<br><code>Perference-&gt;setting</code>添加</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&quot;tab_size&quot;: 4,&quot;translate_tabs_to_spaces&quot;: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="project-3-员工工资系统"><a href="#project-3-员工工资系统" class="headerlink" title="project 3 员工工资系统"></a>project 3 员工工资系统</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct person &#123;    double salary;    char* name;&#125;;class SalaryManage &#123;private:    person* employee;    int max;    &#x2F;&#x2F; 可容纳员工数    int count;  &#x2F;&#x2F; 当前员工数public:    SalaryManage(int Max &#x3D; 0) &#123;        max &#x3D; Max;        count &#x3D; 0;        employee &#x3D; new person[max];    &#125;    double &amp;operator [] (const char* Name) &#123;        person* ptr;        for (ptr &#x3D; employee; ptr &lt;&#x3D; employee + count; ptr++) &#123;            if (strcmp(ptr-&gt;name, Name) &#x3D;&#x3D; 0) &#123;                return ptr-&gt;salary;            &#125;            ptr &#x3D; employee + count; &#x2F;&#x2F; 跳到最后一个            count++;                &#x2F;&#x2F; 员工数++            ptr-&gt;name &#x3D; new char[strlen(Name) + 1]; &#x2F;&#x2F; 新建一个员工            strcpy(ptr-&gt;name, Name);            ptr-&gt;salary &#x3D; 0;            return ptr-&gt;salary;        &#125;    &#125;    void display() &#123;        for (int i &#x3D; 0; i &lt; count; i++) &#123;            cout &lt;&lt; employee[i].name &lt;&lt; &quot;: &quot; &lt;&lt; employee[i].salary &lt;&lt; endl;        &#125;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    SalaryManage s(2);    const char* ch1 &#x3D; &quot;kavin&quot;;    s[ch1] &#x3D; 3.2;    const char* ch2 &#x3D; &quot;jack&quot;;    s[ch2] &#x3D; 123.2;    cout &lt;&lt; s[ch1] &lt;&lt; endl;    s.display();    return 0;&#125;3.2kavin: 3.2jack: 123.2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>C++11</code>不能直接从<code>string</code>字符串转为<code>char*</code>，所以用一个指向字符串常量的指针指向他</p><h2 id="project-4-重载二元运算符"><a href="#project-4-重载二元运算符" class="headerlink" title="project 4 重载二元运算符"></a>project 4 重载二元运算符</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Complex&#123;public:    Complex(int _r &#x3D; 0, int _i &#x3D; 0) : r(_r), i(_i) &#123;&#125;    Complex operator + (Complex input);    Complex operator - (Complex input);    void info();private:    int r, i;&#125;;Complex Complex::operator + (Complex input) &#123;    return Complex(this-&gt;r + input.r, this-&gt;i + input.i);&#125;Complex Complex::operator - (Complex input) &#123;    return Complex(this-&gt;r - input.r, this-&gt;i - input.i);&#125;void Complex::info() &#123;    cout &lt;&lt; this-&gt;r;    if (this-&gt;i &gt; 0) cout &lt;&lt; &quot;+&quot;;    if (this-&gt;i !&#x3D; 0) cout &lt;&lt; this-&gt;i &lt;&lt; &quot;i&quot; &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    Complex a(2, -3);    a.info();    Complex b(3, 4);    b.info();    Complex c &#x3D; a + b;    c.info();    Complex d &#x3D; a - b;    d.info();    return 0;&#125;2-3i3+4i5+1i-1-7i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="project5-自定义String类"><a href="#project5-自定义String类" class="headerlink" title="project5 自定义String类"></a>project5 自定义String类</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class String&#123;public:    String(const char* &#x3D; &quot;&quot;);    ~String()&#123;&#125;    friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const String&amp; s) &#123;        return os &lt;&lt; s.sPtr;    &#125;    &#x2F;&#x2F; 声明为友元函数，参数要与实际需要的参数相同    friend String operator + (const String&amp; a, const String&amp; b);    const String&amp; operator &#x3D; (const String&amp;);    const String&amp; operator +&#x3D; (const String&amp;);    bool operator &#x3D;&#x3D; (const String&amp;);    bool operator !&#x3D; (const String&amp;);    bool operator &lt; (const String&amp;);    char&amp; operator [] (int index);    int getLength() &#123; return this-&gt;length; &#125;private:    char* sPtr;    int length;&#125;;String::String(const char* str) &#123;    this-&gt;sPtr &#x3D; new char[strlen(str) + 1];    strcpy(this-&gt;sPtr, str);    this-&gt;length &#x3D; strlen(str);&#125;&#x2F;&#x2F; 友元就不需要作用域String::了String operator + (const String&amp; a, const String&amp; b) &#123;    String res;    res.sPtr &#x3D; new char[a.length + b.length + 1];    strcpy(res.sPtr, a.sPtr);    strcat(res.sPtr, b.sPtr);    return String(res.sPtr);&#125;const String&amp; String::operator &#x3D; (const String&amp; s) &#123;    cout &lt;&lt; &quot;copy assignment&quot; &lt;&lt; endl;    this-&gt;length &#x3D; s.length;    strcpy(this-&gt;sPtr, s.sPtr);    return *this;&#125;const String&amp; String::operator +&#x3D; (const String&amp; s) &#123;    char* temp &#x3D; this-&gt;sPtr;    this-&gt;length +&#x3D; s.length;    this-&gt;sPtr &#x3D; new char[this-&gt;length + 1];    strcpy(this-&gt;sPtr, temp);    strcat(this-&gt;sPtr, s.sPtr);    delete[] temp;    return *this;&#125;bool String::operator &#x3D;&#x3D; (const String&amp; s) &#123;    return strcmp(this-&gt;sPtr, s.sPtr) &#x3D;&#x3D; 0;&#125;bool String::operator !&#x3D; (const String&amp; s) &#123;    return !(*this &#x3D;&#x3D; s);&#125;bool String::operator &lt; (const String&amp; s) &#123;    return strcmp(this-&gt;sPtr, s.sPtr) &lt; 0;&#125;char&amp; String::operator [] (int index) &#123;    return this-&gt;sPtr[index];&#125;int main(int argc, char const *argv[])&#123;    String s1(&quot;hello&quot;);    cout &lt;&lt; &quot;s1&#x3D;&quot; &lt;&lt; s1 &lt;&lt; endl;        String s2;    s2.operator&#x3D;(s1);    cout &lt;&lt; &quot;s2&#x3D;&quot; &lt;&lt; s2 &lt;&lt; endl;    s2 +&#x3D; &quot; world&quot;;    cout &lt;&lt; &quot;s2&#x3D;&quot; &lt;&lt; s2 &lt;&lt; endl;    for (int i &#x3D; 0; i &lt; s2.getLength(); i++) &#123;        cout &lt;&lt; s2[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    String s3 &#x3D; s1 + s2;    cout &lt;&lt; &quot;s3&#x3D;&quot; &lt;&lt; s3 &lt;&lt; endl;    String s4(&quot;hello world&quot;);    if (s2 !&#x3D; s4) &#123;        cout &lt;&lt; &quot;s2!&#x3D;s4&quot; &lt;&lt; endl;    &#125; else &#123;        cout &lt;&lt; &quot;s2&#x3D;&#x3D;s4&quot; &lt;&lt; endl;    &#125;    String str1(&quot;abd&quot;);    String str2(&quot;abc&quot;);    if (str1 &lt; str2) &#123;        cout &lt;&lt; &quot;str1 &lt; str2&quot; &lt;&lt; endl;    &#125; else &#123;        cout &lt;&lt; &quot;str1 &gt;&#x3D; str2&quot; &lt;&lt; endl;    &#125;    return 0;&#125;s1&#x3D;hellocopy assignments2&#x3D;hellos2&#x3D;hello worldh e l l o   w o r l d s3&#x3D;hellohello worlds2&#x3D;&#x3D;s4str1 &gt;&#x3D; str2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="2021/04/18/C-%E7%BB%A7%E6%89%BF/"/>
      <url>2021/04/18/C-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="重载基类的方法"><a href="#重载基类的方法" class="headerlink" title="重载基类的方法"></a>重载基类的方法</h2><p>如果要使用基类的方法，可以用作用域解析运算符<code>(::)</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    void info() &#123;        cout &lt;&lt; this-&gt;x &lt;&lt; endl;    &#125;&#125;;class B : public A &#123;public:    void info() &#123;   &#x2F;&#x2F; 重载基类的方法        cout &lt;&lt; &quot;B: &quot; &lt;&lt; this-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; this-&gt;y &lt;&lt; endl;        A::info();  &#x2F;&#x2F; 使用基类的方法    &#125;&#125;;int main(int argc, char const *argv[])&#123;    B* b &#x3D; new B(3, 4);    b-&gt;info();    delete b;    return 0;&#125;A constructorB constructorB: 3, 4     &#x2F;&#x2F; 调用派生类的info()A: 3        &#x2F;&#x2F; 调用基类的info()B destructorA destructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="隐藏基类的方法"><a href="#隐藏基类的方法" class="headerlink" title="隐藏基类的方法"></a>隐藏基类的方法</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    void info() &#123;        cout &lt;&lt; &quot;A: &quot; &lt;&lt; this-&gt;x &lt;&lt; endl;    &#125;    void info(int val) &#123;        cout &lt;&lt; &quot;A: receive &quot; &lt;&lt; val &lt;&lt; endl;    &#125;&#125;;class B : public A &#123;public:    void info() &#123;        cout &lt;&lt; &quot;B: &quot; &lt;&lt; this-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; this-&gt;y &lt;&lt; endl;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    B* b &#x3D; new B(3, 4);    b-&gt;info(34);    &#x2F;&#x2F; error，B中没有实现info(int val)    delete b;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>派生类中实现了<code>info()</code>，他隐藏了基类<code>A::info()</code>的所有版本，编译器调用了派生类的<code>info()</code>，但他没有接受参数，也就会出错</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>在<code>main()</code>中使用作用域解析运算符<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">b-&gt;A::info(34);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在派生类中使用<code>using</code>关键字<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">using A::info;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>重载基类的所有info方法<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void info() &#123;    cout &lt;&lt; &quot;B: &quot; &lt;&lt; this-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; this-&gt;y &lt;&lt; endl;&#125;void info(int val) &#123;    cout &lt;&lt; &quot;B: receive &quot; &lt;&lt; val &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h2><p>公有继承派生类在继承结构层次外部可以使用基类的公有和保护成员，如<code>b-&gt;g()</code><br>私有继承则表示，基类的公有和保护成员，只能在派生类内部使用，<strong>外部无法访问</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    virtual void f() &#x3D; 0;    void g() &#123; this-&gt;f(); &#125;&#125;;class B : private A &#123;public:    void f() &#123;        cout &lt;&lt; &quot;B: f(&quot; &lt;&lt; this-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; this-&gt;y &lt;&lt; &quot;)&quot; &lt;&lt; endl;    &#125;private:    int y;&#125;;int main(int argc, char const *argv[])&#123;    B* b &#x3D; new B(3, 4);    b-&gt;g();     &#x2F;&#x2F; error，私有继承不能访问基类的成员函数&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    virtual void f() &#x3D; 0;    void g() &#123; this-&gt;f(); &#125;&#125;;class B : public A &#123;public:    void f() &#123;        cout &lt;&lt; &quot;B: f(&quot; &lt;&lt; this-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; this-&gt;y &lt;&lt; &quot;)&quot; &lt;&lt; endl;    &#125;&#125;;class C : protected B &#123;    void func() &#123;        this-&gt;g();    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C类想访问A类的成员方法，如果B对A是私有或保护继承，C类是无法访问A类的成员方法的<br>只有B类对A类是公有继承，C类才能访问A类的成员方法</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>如果是<code>is-a</code>关系，即属于关系，要用公有继承</li><li>如果是<code>has-a</code>关系，即拥有关系，要用私有或保护继承</li><li><code>public</code>的限制最小，可以被类成员函数、派生类成员函数、友元访问，类对象也可以访问</li><li><code>protected</code>有点限制，可以被类成员函数、派生类成员函数、友元访问，类对象不能访问</li><li><code>private</code>限制最大，可以被类成员函数、友元访问，派生类、类对象都不能访问</li></ol><h3 id="三个访问限定符的区别"><a href="#三个访问限定符的区别" class="headerlink" title="三个访问限定符的区别"></a>三个访问限定符的区别</h3><table>    <tr>        <th>类型</th>        <th>类成员函数</th>        <th>友元</th>        <th>派生类成员函数</th>        <th>类对象</th>    </tr>    <tr>        <th>public</th>        <th>yes</th>        <th>yes</th>        <th>yes</th>        <th>yes</th>    </tr>    <tr>        <th>protected</th>        <th>yes</th>        <th>yes</th>        <th>yes</th>        <th>no</th>    </tr>    <tr>        <th>privated</th>        <th>yes</th>        <th>yes</th>        <th>no</th>        <th>no</th>    </tr></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类/虚函数/虚继承</title>
      <link href="2021/04/17/C-%E8%99%9A%E5%87%BD%E6%95%B0/"/>
      <url>2021/04/17/C-%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="一、多态性"><a href="#一、多态性" class="headerlink" title="一、多态性"></a>一、多态性</h2><p>多态性：多态就是在同一个类或继承体系结构的基类与派生类中，用同名函数来实现各种不同的功能。</p><p><strong>静态绑定又称静态联编</strong>，是指在编译程序时就根据调用函数提供的信息，把它所对应的具体函数确定下来，即在编译时就把调用函数名与具体函数绑定在一起。 </p><p><strong>动态绑定又称动态联编</strong>，是指在编译程序时还不能确定函数调用所对应的具体函数，只有在程序运行过程中才能够确定函数调用所对应的具体函数，即在程序运行时才把调用函数名与具体函数绑定在一起。</p><p>编译时多态性：静态联编(连接)—-系统在编译时就决定如何实现某一动作，即对某一消息如何处理。静态联编具有执行速度快的优点。在C++中的编译时多态性是通过函数重载和运算符重载实现的。<br>运行时多态性：动态联编(连接)—-系统在运行时动态实现某一动作，即对某一消息在运行过程实现其如何响应。动态联编为系统提供了灵活和高度问题抽象的优点，在C++中的运行时多态性是通过继承和虚函数实现的。</p><h2 id="二、虚函数"><a href="#二、虚函数" class="headerlink" title="二、虚函数"></a>二、虚函数</h2><p>虚函数的意义</p><p>1、基类与派生类的赋值相容</p><ul><li>派生类对象可以赋值给基类对象。</li><li>派生类对象的地址可以赋值给指向基类对象的指针。</li><li>派生类对象可以作为基类对象的引用。</li></ul><p>赋值相容的问题：不论哪种赋值方式，都只能通过基类对象（或基类对象的指针或引用）访问到派生类对象从基类中继承到的成员， 不能借此访问派生类定义的成员。</p><p>2、虚函数使得可以通过基类对象的指针或引用访问派生类定义的成员。</p><p>3、<code>virtual</code>关键字其实质是告知编译系统，被指定为<code>virtual</code>的函数采用动态联编的形式编译。</p><p>4、虚函数的虚特征：基类指针指向派生类的对象时，通过该指针访问其虚函数将调用派生类的版本。</p><ul><li>一旦将某个成员函数声明为虚函数后，它在继承体系中就永远为虚函数了 </li><li>如果基类定义了虚函数，当通过基类指针或引用调用派生类对象时，将访问到它们实际所指对象中的虚函数版本。</li><li>只有通过基类对象的指针和引用访问派生类对象的虚函数时，才能体现虚函数的特性。</li><li>派生类中的虚函数要保持其虚特征，必须与基类虚函数的函数原型完全相同，否则就是普通的重载函数，与基类的虚函数无关。</li><li>派生类通过从基类继承的成员函数调用虚函数时，将访问到派生类中的版本。</li><li>只有类的非静态成员函数才能被定义为虚函数，类的构造函数和静态成员函数不能定义为虚函数。原因是虚函数在继承层次结构中才能够发生作用，而构造函数、静态成员是不能够被继承的。</li><li>内联函数也不能是虚函数。因为内联函数采用的是静态联编的方式，而虚函数是在程序运行时才与具体函数动态绑定的，采用的是动态联编的方式，即使虚函数在类体内被定义，C++编译器也将它视为非内联函数。</li></ul><p>5、基类析构函数几乎总是为虚析构函数。<br>假定使用<code>delete</code>和一个指向派生类的基类指针来销毁派生类对象，如果基类析构函数不为虚,就如一个普通成员函数，<code>delete</code>函数调用的就是基类析构函数。在通过基类对象的引用或指针调用派生类对象时，将致使对象析构不彻底！</p><h2 id="三、纯虚函数和抽象类"><a href="#三、纯虚函数和抽象类" class="headerlink" title="三、纯虚函数和抽象类"></a>三、纯虚函数和抽象类</h2><p>1、纯虚函数概念？</p><p>仅定义函数原型而不定义其实现的虚函数<br>实用角度：占位手段<code>place-holder</code><br>方法学：接口定义手段，抽象表达手段</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class X&#123;    virtual ret_type func_name (param) &#x3D; 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、抽象类概念？</p><p>包含一个或多个纯虚函数的类<br><strong>不能实例化抽象类</strong><br>但是可以定义抽象类的指针和引用</p><p>3、C++对抽象类具有以下限定</p><ul><li>抽象类中含有纯虚函数，由于纯虚函数没有实现代码，所以不能建立抽象类的对象。</li><li>抽象类只能作为其他类的基类，可以通过抽象类对象的指针或引用访问到它的派生类对象，实现运行时的多态性。</li><li>如果派生类只是简单地继承了抽象类的纯虚函数，而没有重新定义基类的纯虚函数，则派生类也是一个抽象类。</li></ul><h2 id="虚函数的用法"><a href="#虚函数的用法" class="headerlink" title="虚函数的用法"></a>虚函数的用法</h2><p>为什么要使用虚函数，因为我们希望基类指针如果指向派生类对象，调用的应该是派生类中的方法，如果不用虚函数，只用重载，那他将会调用基类的方法，所以需要虚函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;    virtual void info() &#123; cout &lt;&lt; &quot;A: info&quot; &lt;&lt; endl;&#125;&#125;;class B : public A &#123;public:    void info() &#123; cout &lt;&lt; &quot;B: info&quot; &lt;&lt; endl;&#125;&#125;;int main(int argc, char const *argv[])&#123;    A* b &#x3D; new B(3, 4);    b-&gt;info();    return 0;&#125;没有virtual时，调用基类方法:A: info加了virtual，调用派生类方法:B: info<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>抽象类中含有虚函数，继承类中需要实现抽象类的所有虚函数<br>成员函数可以调用虚函数，构造函数和析构函数不能调用虚函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    virtual void f() &#x3D; 0;   &#x2F;&#x2F;纯虚函数    void g() &#123;        this-&gt;f();          &#x2F;&#x2F; 调用虚函数    &#125;&#125;;class B : public A &#123;public:    void f() &#123;      &#x2F;&#x2F; 派生类要实现虚函数        cout &lt;&lt; &quot;B: f()&quot; &lt;&lt; endl;    &#125;&#125;;int main(int argc, char const *argv[])&#123;    A a;            &#x2F;&#x2F; error，不能创建抽象类对象    A* a &#x3D; new A;   &#x2F;&#x2F; error，不能创建抽象类指针对象    B* b &#x3D; new B;    b-&gt;g();         &#x2F;&#x2F;因为B对A是公有继承，所以可以使用A中的成员方法    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>虚函数是用虚函数表实现的，虚函数表由一系列函数指针组成，每个函数指针指向虚函数的实现<br>从下面的例子可以看出，<code>Base</code>含有2个<code>int</code>和一个虚函数(几个都一样)，<code>Derived</code>含有2个<code>int</code>，他们差了一个指针的大小(8)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Base&#123;    int x, y;public:    virtual void doSomeThing() &#x3D; 0;&#125;;class Derived&#123;    int x, y;&#125;;int main(int argc, char const *argv[])&#123;    cout &lt;&lt; sizeof(int) &lt;&lt; endl;    cout &lt;&lt; sizeof(int*) &lt;&lt; endl;    cout &lt;&lt; sizeof(Base) &lt;&lt; endl;    cout &lt;&lt; sizeof(Derived) &lt;&lt; endl;    return 0;&#125;4   &#x2F;&#x2F; int占用4字节8   &#x2F;&#x2F; 指针占用8字节16  &#x2F;&#x2F; 2个int+1个虚函数指针8   &#x2F;&#x2F; 2个int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="抽象类构造函数"><a href="#抽象类构造函数" class="headerlink" title="抽象类构造函数"></a>抽象类构造函数</h2><p>构造函数不能是虚函数<br>可以用基类指针指向派生类对象<br><code>protected</code>允许派生类和友元类访问，但禁止在继承结构层次外部访问</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    A(int i) : x(i) &#123; cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; endl; &#125;    virtual void f() &#x3D; 0;    void g() &#123;        this-&gt;f();    &#125;protected:  &#x2F;&#x2F; 成员变量声明为protected，可以在派生类和友元类中访问    int x;&#125;;class B : public A &#123;public:    B(int i, int j) : A(i), y(j) &#123; cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; endl; &#125;    void f() &#123;        cout &lt;&lt; &quot;B: f(&quot; &lt;&lt; this-&gt;x &lt;&lt; &quot;, &quot; &lt;&lt; this-&gt;y &lt;&lt; &quot;)&quot; &lt;&lt; endl;    &#125;private:    int y;&#125;;int main(int argc, char const *argv[])&#123;    A* b &#x3D; new B(3, 4); &#x2F;&#x2F;基类指针指向派生类对象    b-&gt;g();    return 0;&#125;A constructorB constructorB: f(3, 4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到先调用了<code>A</code>的构造函数，后调用了<code>B</code>的构造函数</p><h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    virtual ~A() &#123; cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; endl; &#125;&#125;;class B : public A &#123;public:    ~B() &#123; cout &lt;&lt; &quot;B destructor&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[])&#123;    A* b &#x3D; new B(3, 4);    b-&gt;g();    delete b;    return 0;&#125;析构函数没有加virtual时：A constructorB constructorB: f(3, 4)A destructor析构函数加virtual时：A constructorB constructorB: f(3, 4)B destructor    &#x2F;&#x2F; 先调用了派生类的析构函数A destructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用基类指针指向派生类对象时，如果基类的析构函数没有声明为<code>virtual</code>，销毁对象时就只会调用<strong>基类</strong>的析构函数，这样会造成内存泄漏<br>所以把基类的析构函数声明为<code>virtual</code>，销毁对象时就会先调用<strong>派生类</strong>的析构函数，再调用<strong>基类</strong>的析构函数</p><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>为了解决菱形问题，一个基类有多个派生类，这些派生类又被一个类继承</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    int x;    A() &#123; cout &lt;&lt; &quot;A: constructor&quot; &lt;&lt; endl; &#125;&#125;;class B : public A &#123;&#125;;class B1 : public A &#123;&#125;;class C : public B, public B1 &#123;public:    C() &#123; cout &lt;&lt; &quot;C: constructor&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[])&#123;    C c;    c.x &#x3D; 10;   &#x2F;&#x2F; error，发生混淆，不知道是谁的x    return 0;&#125;A: constructor  &#x2F;&#x2F; 调用了两次基类的构造函数A: constructorC: constructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>解决方法：基类的多个派生类使用<strong>虚继承</strong>，确保只有<strong>一个基类实例</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;public:    int x;    A() &#123; cout &lt;&lt; &quot;A: constructor&quot; &lt;&lt; endl; &#125;&#125;;class B : public virtual A &#123;&#125;;class B1 : public virtual A &#123;&#125;;class C : public B, public B1 &#123;public:    C() &#123; cout &lt;&lt; &quot;C: constructor&quot; &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[])&#123;    C c;    c.x &#x3D; 10;   &#x2F;&#x2F; yes    return 0;&#125;A: constructor  &#x2F;&#x2F; 只调用了一次基类的构造函数C: constructor<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static关键字</title>
      <link href="2021/04/17/C-static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2021/04/17/C-static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="函数中使用static"><a href="#函数中使用static" class="headerlink" title="函数中使用static"></a>函数中使用static</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; void demo() &#123;     static int count &#x3D; 0;     cout &lt;&lt; count &lt;&lt; &quot; &quot;;     count++; &#125; int main() &#123;     for (int i &#x3D; 0; i &lt; 5; i++)        demo();     return 0; &#125;0 1 2 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<code>count</code>在不断累加，<code>static</code>变量的空间只分配一次，每次调用之后不会再进行初始化</p><h2 id="类中使用static"><a href="#类中使用static" class="headerlink" title="类中使用static"></a>类中使用static</h2><ul><li>类中的<code>static</code>变量只能声明，定义要放在类外面</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Human&#123;public:    static int ip;  &#x2F;&#x2F; 类中声明static变量private:    string _name;    int _age;&#125;;int Human::ip &#x3D; 0;  &#x2F;&#x2F; 类外定义static变量int main(int argc, char const *argv[])&#123;    Human kavin(&quot;kavin&quot;, 23);    cout &lt;&lt; kavin.ip &lt;&lt; endl;    kavin.ip &#x3D; 10;    Human* jack &#x3D; new Human(&quot;jack&quot;, 12);    jack-&gt;ip &#x3D; 30;    cout &lt;&lt; kavin.ip &lt;&lt; endl;    return 0;&#125;030<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到不同对象都可以对<code>static</code>变量进行修改，他们是共享的</p><h2 id="静态变量需要初值"><a href="#静态变量需要初值" class="headerlink" title="静态变量需要初值"></a>静态变量需要初值</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class A &#123;    static const int num &#x3D; 5;    或者 enum &#123; num &#x3D; 5 &#125;;    int arr[num];&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里数组必须知道大小，所以就必须在给<code>num</code>赋初值<br>也可以用<code>enum</code></p><h2 id="静态对象"><a href="#静态对象" class="headerlink" title="静态对象"></a>静态对象</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    int x &#x3D; 1;    if (x &#x3D;&#x3D; 1) &#123;        int num1 &#x3D; 100;        Human kavin(&quot;kavin&quot;, 23, num1);    &#125;    cout &lt;&lt; &quot;main function end&quot; &lt;&lt; endl;    return 0;&#125;Destructor: delete ptrmain function end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为<code>kavin</code>对象的生命周期在if语句结束之后就没了，所以就会调用析构函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    int x &#x3D; 1;    if (x &#x3D;&#x3D; 1) &#123;        int num1 &#x3D; 100;        static Human kavin(&quot;kavin&quot;, 23, num1);    &#125;    cout &lt;&lt; &quot;main function end&quot; &lt;&lt; endl;    return 0;&#125;main function endDestructor: delete ptr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静态对象的声明周期贯穿整个程序，所以在程序结束之后才会调用析构函数</p><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><p>类中的静态成员函数只能使用类中的静态成员变量和成员函数<br>建议使用类名和范围解析运算符调用静态成员函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Human&#123;public:    static int ip;    static void info();&#125;;int Human::ip &#x3D; 0;void Human::info() &#123;    cout &lt;&lt; ip &lt;&lt; endl;    &#x2F;&#x2F; Introduce();    &#x2F;&#x2F;error，不能调用非静态成员函数&#125;int main(int argc, char const *argv[])&#123;    Human kavin(&quot;kavin&quot;, 23);    kavin.ip &#x3D; 10;    Human::info();    return 0;&#125;10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拷贝构造函数</title>
      <link href="2021/04/16/C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
      <url>2021/04/16/C-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Human&#123;public:    Human(string name, int age, const int&amp; val);    ~Human();private:    string _name;    int _age;    int* _ptr &#x3D; nullptr;&#125;;Human::Human(string name, int age, const int&amp; val) &#123;    this-&gt;_name &#x3D; name;    this-&gt;_age &#x3D; age;    if (&amp;val !&#x3D; nullptr) &#123;        this-&gt;_ptr &#x3D; new int;        *this-&gt;_ptr &#x3D; val;    &#125;    else        this-&gt;_ptr &#x3D; nullptr;&#125;Human::~Human() &#123;    if (this-&gt;_ptr !&#x3D; nullptr) &#123;        cout &lt;&lt; &quot;delete ptr&quot; &lt;&lt; endl;        delete this-&gt;_ptr;    &#125;&#125;int main(int argc, char const *argv[])&#123;    int num1 &#x3D; 100;    Human kavin(&quot;kavin&quot;, 23, num1);    kavin.setAge(34);    kavin.Introduce();    return 0;&#125;I&#39;m kavin, and I&#39;m 34 years old.delete ptr  &#x2F;&#x2F; 调用了析构函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类成员变量里有指针，程序结束时应该要释放，所以需要重载析构函数，类里面只有一个析构函数。</p><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Human&#123;&#x2F;&#x2F; 拷贝构造函数Human::Human(const Human&amp; copySource) &#123;    this-&gt;_name &#x3D; copySource._name;    this-&gt;_age &#x3D; copySource._age;    cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl;    if (copySource._ptr !&#x3D; nullptr) &#123;        this-&gt;_ptr &#x3D; new int;        *this-&gt;_ptr &#x3D; *copySource._ptr;    &#125;    else         this-&gt;_ptr &#x3D; nullptr;&#125;void UseHuman(Human input) &#123;    input.Introduce();&#125;int main(int argc, char const *argv[])&#123;    int num1 &#x3D; 100;    Human kavin(&quot;kavin&quot;, 23, num1);    kavin.setAge(34);    kavin.Introduce();    UseHuman(kavin);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有拷贝构造函数，在<code>UseHuman</code>函数完成之后，类中的指针所指的空间就会被释放，而在<code>main</code>函数结束时，又会调用析构函数释放内存，这样就会发生错误。<br>原因在于，传递参数时是浅复制，没有对指针所指内容进行复制，导致两个指针指向同一个地方，所以拷贝构造函数就需要对指针所指内容进行复制。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类/友元</title>
      <link href="2021/04/16/C-C-%E7%B1%BB/"/>
      <url>2021/04/16/C-C-%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="一个简单的Human类"><a href="#一个简单的Human类" class="headerlink" title="一个简单的Human类"></a>一个简单的Human类</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;class Human&#123;public:    Human();    &#x2F;&#x2F; 默认构造函数    Human(string name, int age);    &#x2F;&#x2F; 重载构造函数    void setName(string name);    void setAge(int age);    string getName();    int getAge();    void Introduce();private:    string _name;    int _age;    string _gender;&#125;;&#x2F;&#x2F; 重载构造函数Human::Human(string name, int age) &#123;    this-&gt;_name &#x3D; name;    this-&gt;_age &#x3D; age;&#125;void Human::setName(string name) &#123;    this-&gt;_name &#x3D; name;&#125;void Human::setAge(int age) &#123;    this-&gt;_age &#x3D; age;&#125;string Human::getName() &#123;    return this-&gt;_name;&#125;int Human::getAge() &#123;    return this-&gt;_age;&#125;void Human::Introduce() &#123;    cout &lt;&lt; &quot;I&#39;m &quot; &lt;&lt; this-&gt;getName() &lt;&lt; &quot;, and I&#39;m &quot; &lt;&lt; this-&gt;getAge() &lt;&lt; &quot; years old.&quot; &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    Human kavin(&quot;kavin&quot;, 23);    kavin.setAge(34);    kavin.Introduce();    Human* jack &#x3D; new Human(&quot;jack&quot;, 12);    jack-&gt;Introduce();    return 0;&#125;I&#39;m kavin, and I&#39;m 34 years old.I&#39;m jack, and I&#39;m 12 years old.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>声明友元函数或友元类，就可以访问类里面的私有变量</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Human&#123;public:    friend void disp(const Human&amp; person);&#125;;void disp(const Human&amp; person) &#123;    cout &lt;&lt; person._age &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    Human kavin(&quot;kavin&quot;, 23);    disp(kavin);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Human&#123;public:    friend class Boys;&#125;;class Boys&#123;public:    static void dispName(const Human&amp; person) &#123;        cout &lt;&lt; person._name &lt;&lt; endl;   &#x2F;&#x2F;可以使用类里面的私有变量    &#125;&#125;;int main(int argc, char const *argv[])&#123;    Human kavin(&quot;kavin&quot;, 23);    Boys::dispName(kavin);    return 0;&#125;kavin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一个简单的Circle类"><a href="#一个简单的Circle类" class="headerlink" title="一个简单的Circle类"></a>一个简单的Circle类</h2><p><code>pi</code>是一个常量</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; class Circle&#123;public:    Circle(int radius) : _radius(radius) &#123;        this-&gt;_perimeter &#x3D; 2 * this-&gt;pi * this-&gt;_radius;        this-&gt;_area &#x3D; this-&gt;pi * this-&gt;_radius * this-&gt;_radius;    &#125;    void info();private:    int _radius;    double _perimeter;    double _area;    const double pi &#x3D; 3.14159;&#125;;void Circle::info() &#123;    cout &lt;&lt; this-&gt;_perimeter &lt;&lt; endl;    cout &lt;&lt; this-&gt;_area &lt;&lt; endl;&#125;int main(int argc, char const *argv[])&#123;    Circle first(6);    first.info();    return 0;&#125;37.6991113.097<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要声明为<code>static</code>，要在类外面定义</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Circle&#123;    static const double pi;         &#x2F;&#x2F;类里面声明&#125;;const double Circle::pi &#x3D; 3.14159;  &#x2F;&#x2F;类外面定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake</title>
      <link href="2021/04/16/C-cmake/"/>
      <url>2021/04/16/C-cmake/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="CMake变量"><a href="#CMake变量" class="headerlink" title="CMake变量"></a>CMake变量</h2><p><strong><code>CMAKE_CURRENT_SOURCE_DIR</code></strong></p><ul><li>指的是当前处理的CMakeLists.txt所在的路径。</li></ul><p><strong><code>CMAKE_CURRRENT_BINARY_DIR</code></strong></p><ul><li>如果是in-source编译，它跟CMAKE_CURRENT_SOURCE_DIR一致，如果是out-ofsource 编译，他指的是target编译目录。</li></ul><p><strong><code>CMAKE_CURRENT_LIST_FILE</code></strong></p><ul><li>输出调用这个变量的CMakeLists.txt的完整路径</li></ul><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><img src="/2021/04/16/C-cmake/cmake.png#pic_center" width="50%" height="50%" alt="test"><h3 id="Solider目录的CMakeLists-txt"><a href="#Solider目录的CMakeLists-txt" class="headerlink" title="Solider目录的CMakeLists.txt"></a>Solider目录的CMakeLists.txt</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">aux_source_directory(. SRC_LIST)&#x2F;&#x2F; 将此目录的源文件集合称为变量SRC_LISTmessage($&#123;SRC_LIST&#125;)&#x2F;&#x2F; #un.cpp;Solider.cppinclude_directories($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)&#x2F;&#x2F; 头文件目录add_library(Solider_shared SHARED $&#123;SRC_LIST&#125;)&#x2F;&#x2F; 库的名称，类型，源文件（动态库）add_library(Solider_static STATIC $&#123;SRC_LIST&#125;)&#x2F;&#x2F; 静态库set_target_properties(Solider_shared PROPERTIES OUTPUT_NAME &quot;Solider&quot;)&#x2F;&#x2F; # 库的名称，库的输出名称（动态库）set_target_properties(Solider_static PROPERTIES OUTPUT_NAME &quot;Solider&quot;)&#x2F;&#x2F; # 静态库set(LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;lib)&#x2F;&#x2F; 库文件输出到工作空间的lib目录下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="工作空间的CMakeLists-txt-生成库文件"><a href="#工作空间的CMakeLists-txt-生成库文件" class="headerlink" title="工作空间的CMakeLists.txt (生成库文件)"></a>工作空间的CMakeLists.txt (生成库文件)</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cmake_minimum_required(VERSION 3.0)project(MAIN)&#x2F;&#x2F; message($&#123;MAIN_BINARY_DIR&#125;)&#x2F;&#x2F; message($&#123;PROJECT_BINARY_DIR&#125;)&#x2F;&#x2F; message($&#123;CMAKE_BINARY_DIR&#125;)&#x2F;&#x2F; 如果是out-of-source编译，指的是工程编译发生的目录 &#x2F;&#x2F; &#x2F;home&#x2F;kavin&#x2F;algorithm&#x2F;VSCode&#x2F;test05&#x2F;build&#x2F;&#x2F; message($&#123;MAIN_SOURCE_DIR&#125;)&#x2F;&#x2F; message($&#123;PROJECT_SOURCE_DIR&#125;)&#x2F;&#x2F; message($&#123;CMAKE_SOURCE_DIR&#125;)&#x2F;&#x2F; 这三个变量指代的内容是一致的，是工程顶层目录 &#x2F;&#x2F; &#x2F;home&#x2F;kavin&#x2F;algorithm&#x2F;VSCode&#x2F;test05&#x2F;&#x2F; 为了生成库文件，完成之后面再把这句注释掉&#x2F;&#x2F; 会进入Solider目录执行里里面的工作空间的CMakeLists.txtadd_subdirectory(Solider)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="工作空间的CMakeLists-txt-编译源文件"><a href="#工作空间的CMakeLists-txt-编译源文件" class="headerlink" title="工作空间的CMakeLists.txt (编译源文件)"></a>工作空间的CMakeLists.txt (编译源文件)</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cmake_minimum_required(VERSION 3.0)project(MAIN)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125;&quot;)set(CMAKE_BUILD_TYPE Debug)     &#x2F;&#x2F; 要启用F5调试一定要用这一条&#x2F;&#x2F; 头文件目录include_directories($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;include)&#x2F;&#x2F; 库文件目录link_directories(lib)&#x2F;&#x2F; 生成可执行文件add_executable(main main.cpp)&#x2F;&#x2F; 链接库(静态库)target_link_libraries(main libSolider.a)&#x2F;&#x2F; 如果是动态库要记得添加环境变量 LD_LIBRARY_PATH&#x3D;lib&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++引用</title>
      <link href="2021/04/16/C-%E5%BC%95%E7%94%A8/"/>
      <url>2021/04/16/C-%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="什么叫引用"><a href="#什么叫引用" class="headerlink" title="什么叫引用"></a>什么叫引用</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[]) &#123;    int original &#x3D; 30;    cout &lt;&lt; &quot;address of original: &quot; &lt;&lt; hex &lt;&lt; &amp;original &lt;&lt; endl;        &#x2F;&#x2F; 定义一个ref引用original    int&amp; ref &#x3D; original;    cout &lt;&lt; &quot;address of ref: &quot; &lt;&lt; hex &lt;&lt; &amp;ref &lt;&lt; endl;    cout &lt;&lt; dec &lt;&lt; ref &lt;&lt; endl;    return 0;&#125;address of original: 0x7ffc14a1acfcaddress of ref: 0x7ffc14a1acfc30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到<code>original</code>和<code>ref</code>的地址和数值都是一样的，所以引用就相当于起了个别名，注意与指针区别</p><h2 id="引用有什么用"><a href="#引用有什么用" class="headerlink" title="引用有什么用"></a>引用有什么用</h2><p>函数在传参数的时候，如果是按值传递，将会对变量进行复制，如果变量很大，就会消耗很多的时间和内存，所以使用引用可以对变量本身直接继续修改</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;void DoSomeThing(int&amp; val) &#123;    cout &lt;&lt; &quot;address of val: &quot; &lt;&lt; hex &lt;&lt; &amp;val &lt;&lt; endl;    val +&#x3D; 100; &#x2F;&#x2F; 对变量值进行增加操作&#125;int main(int argc, char const *argv[])&#123;    int original &#x3D; 30;    cout &lt;&lt; &quot;address of original: &quot; &lt;&lt; hex &lt;&lt; &amp;original &lt;&lt; endl;    int&amp; ref &#x3D; original;    cout &lt;&lt; &quot;address of ref: &quot; &lt;&lt; hex &lt;&lt; &amp;ref &lt;&lt; endl;    cout &lt;&lt; dec &lt;&lt; ref &lt;&lt; endl;    DoSomeThing(ref);    cout &lt;&lt; dec &lt;&lt; original &lt;&lt; endl;    return 0;&#125;address of original: 0x7ffc14a1acfcaddress of ref: 0x7ffc14a1acfc30address of val: 0x7ffc14a1acfc130 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到最初的变量<code>original</code>的值发生了变化，按引用传递的形参的地址还是和原来一样的</p><h2 id="加个const"><a href="#加个const" class="headerlink" title="加个const"></a>加个const</h2><p>有时候我们希望函数只能使用传递的参数，不能修改他，就需要加个<code>const</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int&amp; ref2 &#x3D; ref;int num &#x3D; 10;ref2 &#x3D; num; &#x2F;&#x2F; 报错，ref2是只读参数，不能作为左值ref2 &#x3D; 100; &#x2F;&#x2F; 报错，ref2是只读参数，不能作为左值void DoSomeThing(const int&amp; val) &#123;    cout &lt;&lt; &quot;address of val: &quot; &lt;&lt; hex &lt;&lt; &amp;val &lt;&lt; endl;    val +&#x3D; 100; &#x2F;&#x2F; 报错，ref2是只读参数，不能作为左值&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不能修改的加个<code>const</code>，需要修改的就不用加<code>const</code>，可以像下面这样写</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void DoSomeThing(const int&amp; val, int&amp; res) &#123;    res &#x3D; val * val;&#125;int main(int argc, char const *argv[])&#123;    int original &#x3D; 30;    int res &#x3D; 0;    DoSomeThing(original, res);    cout &lt;&lt; original &lt;&lt; endl;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;30  &#x2F;&#x2F;const引用的值没有被改变900 &#x2F;&#x2F;没有const的值被修改了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2_addTwoNumbers</title>
      <link href="2021/04/16/LeetCode-02-addTwoNumbers/"/>
      <url>2021/04/16/LeetCode-02-addTwoNumbers/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="LeetCode-02-两数相加"><a href="#LeetCode-02-两数相加" class="headerlink" title="LeetCode 02. 两数相加"></a>LeetCode 02. 两数相加</h2><p>给你两个<strong>非空</strong>的链表，表示两个非负的整数。它们每位数字都是按照<strong>逆序</strong>的方式存储的，并且每个节点只能存储<strong>一位</strong>数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字0之外，这两个数都不会以0开头。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]输出：[7,0,8]解释：342 + 465 &#x3D; 807.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ListNode* cur &#x3D; ptr;&#x2F;&#x2F; cur指针指向ptr，之后创建一个next，再移动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) &#123;&#125; *     ListNode(int x) : val(x), next(nullptr) &#123;&#125; *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; *&#x2F;class Solution &#123;public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;        int flag &#x3D; 0;   &#x2F;&#x2F; 进位        ListNode* ptr &#x3D; new ListNode(0);    &#x2F;&#x2F; 空头指针        ListNode* cur &#x3D; ptr;        &#x2F;&#x2F; 判断-&gt;求和-&gt;赋值-&gt;指针移动        while (l1 !&#x3D; nullptr &amp;&amp; l2 !&#x3D; nullptr) &#123;            int sum &#x3D; l1-&gt;val + l2-&gt;val + flag;            cur-&gt;next &#x3D; new ListNode(sum % 10);            cur &#x3D; cur-&gt;next;            flag &#x3D; sum &#x2F; 10;            l1 &#x3D; l1-&gt;next;            l2 &#x3D; l2-&gt;next;        &#125;        &#x2F;&#x2F; 考虑两条链表不一样长的情况，针对这一条链表，进行与之前类似的操作        while (l1 !&#x3D; nullptr) &#123;            int sum &#x3D; l1-&gt;val + flag;            cur-&gt;next &#x3D; new ListNode(sum % 10);            cur &#x3D; cur-&gt;next;            flag &#x3D; sum &#x2F; 10;            l1 &#x3D; l1-&gt;next;        &#125;        while (l2 !&#x3D; nullptr) &#123;            int sum &#x3D; l2-&gt;val + flag;            cur-&gt;next &#x3D; new ListNode(sum % 10);            cur &#x3D; cur-&gt;next;            flag &#x3D; sum &#x2F; 10;            l2 &#x3D; l2-&gt;next;        &#125;        &#x2F;&#x2F; 如果此时还有进位，就再加个1        if (flag) &#123;            cur-&gt;next &#x3D; new ListNode(flag);            cur &#x3D; cur-&gt;next;        &#125;        return(ptr-&gt;next);    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV_shadow</title>
      <link href="2021/04/13/OpenCV-OpenCV-shadow/"/>
      <url>2021/04/13/OpenCV-OpenCV-shadow/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="创建Mat"><a href="#创建Mat" class="headerlink" title="创建Mat"></a>创建Mat</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 5行3列随机值Mat img &#x3D; Mat(5, 3, CV_8UC3);randu(img, Scalar::all(0), Scalar::all(255));&#x2F;&#x2F; 2行2列固定值Mat img1(Size(2, 2), CV_8UC3, Scalar(0, 0, 255));&#x2F;&#x2F; create()函数Mat img2;img2.create(Size(4, 4), CV_8UC3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输出Mat"><a href="#输出Mat" class="headerlink" title="输出Mat"></a>输出Mat</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cout &lt;&lt; img &lt;&lt; endl;cout &lt;&lt; format(img, Formatter::FMT_PYTHON) &lt;&lt; endl;cout &lt;&lt; format(img, Formatter::FMT_NUMPY) &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="获取行数和列数"><a href="#获取行数和列数" class="headerlink" title="获取行数和列数"></a>获取行数和列数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">行数: src.rows列数: src.cols<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="形态学"><a href="#形态学" class="headerlink" title="形态学"></a>形态学</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 创建核Mat kernal &#x3D; getStructuringElement(MORPH_RECT, Size(15, 15));Mat img_dilate, img_erosion;&#x2F;&#x2F; 膨胀dilate(gray, img_dilate, kernal);&#x2F;&#x2F; 腐蚀erode(img_dilate, img_erosion, kernal);&#x2F;&#x2F; 开闭运算 礼帽 黑帽morphologyEx(gray, dst_open, MORPH_TOPHAT, kernal);MORPH_OPEN: 先腐蚀后膨胀MORPH_CLOSE: 先膨胀后腐蚀MORPH_TOPHAT: 原图与开运算之差MORPH_BLACKHAT: 闭运算与原图之差<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;using namespace std;int main(int artc, char** argv) &#123;    Mat img &#x3D; Mat(5, 3, CV_8UC3);    randu(img, Scalar::all(0), Scalar::all(255));    cout &lt;&lt; img &lt;&lt; endl;    &#x2F;&#x2F; [ 91,   2,  79, 179,  52, 205, 236,   8, 181;    &#x2F;&#x2F; 239,  26, 248, 207, 218,  45, 183, 158, 101;    &#x2F;&#x2F; 102,  18, 118,  68, 210, 139, 198, 207, 211;    &#x2F;&#x2F; 181, 162, 197, 191, 196,  40,   7, 243, 230;    &#x2F;&#x2F; 45,   6,  48, 173, 242, 125, 175,  90,  63]    cout &lt;&lt; &quot;python:&quot; &lt;&lt; endl;    cout &lt;&lt; format(img, Formatter::FMT_PYTHON) &lt;&lt; endl;    &#x2F;&#x2F; python:    &#x2F;&#x2F; [[[ 91,   2,  79], [179,  52, 205], [236,   8, 181]],    &#x2F;&#x2F;  [[239,  26, 248], [207, 218,  45], [183, 158, 101]],    &#x2F;&#x2F;  [[102,  18, 118], [ 68, 210, 139], [198, 207, 211]],    &#x2F;&#x2F;  [[181, 162, 197], [191, 196,  40], [  7, 243, 230]],    &#x2F;&#x2F;  [[ 45,   6,  48], [173, 242, 125], [175,  90,  63]]]    cout &lt;&lt; &quot;numpy:&quot; &lt;&lt; endl;    cout &lt;&lt; format(img, Formatter::FMT_NUMPY) &lt;&lt; endl;    &#x2F;&#x2F; numpy:    &#x2F;&#x2F; array([[[ 91,   2,  79], [179,  52, 205], [236,   8, 181]],    &#x2F;&#x2F;        [[239,  26, 248], [207, 218,  45], [183, 158, 101]],    &#x2F;&#x2F;        [[102,  18, 118], [ 68, 210, 139], [198, 207, 211]],    &#x2F;&#x2F;        [[181, 162, 197], [191, 196,  40], [  7, 243, 230]],    &#x2F;&#x2F;        [[ 45,   6,  48], [173, 242, 125], [175,  90,  63]]], dtype&#x3D;&#39;uint8&#39;)    Mat img1(Size(2, 2), CV_8UC3, Scalar(0, 0, 255));    cout &lt;&lt; format(img1, Formatter::FMT_PYTHON) &lt;&lt; endl;    &#x2F;&#x2F; [[[  0,   0, 255], [  0,   0, 255]],    &#x2F;&#x2F;  [[  0,   0, 255], [  0,   0, 255]]]    Mat img2;    img2.create(Size(4, 4), CV_8UC3);    cout &lt;&lt; format(img2, Formatter::FMT_PYTHON) &lt;&lt; endl;    &#x2F;&#x2F; [[[  0,   0,   0], [  0,   0,   0], [  0,   0,   0], [  0,   0,   0]],    &#x2F;&#x2F;  [[  0,   0,   0], [  0,   0,   0], [  0,   0,   0], [  0,   0,   0]],    &#x2F;&#x2F;  [[  0,   0,   0], [  0,   0,   0], [  0,   0,   0], [  0,   0,   0]],    &#x2F;&#x2F;  [[  0,   0,   0], [  0,   0,   0], [  0,   0,   0], [  0,   0,   0]]]    Mat src &#x3D; imread(&quot;&#x2F;homevin&#x2F;Picturesadow.png&quot;, IMREAD_COLOR);    if (src.empty()) &#123;        cout &lt;&lt; &quot;can&#39;t find picture&quot; &lt;&lt; endl;        return -1;    &#125;    cout &lt;&lt; src.rows &lt;&lt; endl;    cout &lt;&lt; src.cols &lt;&lt; endl;    Mat gray;    cvtColor(src, gray, COLOR_BGR2GRAY);    Mat kernal &#x3D; getStructuringElement(MORPH_RECT, Size(15, 15));    Mat img_dilate, img_erosion;    &#x2F;&#x2F;Mat dst_open, dst_theshould;    &#x2F;&#x2F; erode(gray, dst, kernal);    dilate(gray, img_dilate, kernal);    erode(img_dilate, img_erosion, kernal);    Mat img_diff &#x3D; img_erosion - gray;    img_diff &#x3D; 255 - img_diff;    Mat img_norm;    normalize(img_diff, img_norm, 0, 255, NORM_MINMAX);    &#x2F;&#x2F;morphologyEx(gray, dst_open, MORPH_TOPHAT, kernal);    &#x2F;&#x2F;threshold(dst_open, dst_theshould, 110, 255, THRESH_BINARY);    &#x2F;&#x2F; namedWindow(&quot;src&quot;);    &#x2F;&#x2F; imshow(&quot;src&quot;, img_diff);    waitKey(0);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/13/OpenCV-OpenCV-shadow/init.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">原图</div></center><center><img src="/2021/04/13/OpenCV-OpenCV-shadow/shadow.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">去阴影</div></center><h2 id="Trackbar找阈值"><a href="#Trackbar找阈值" class="headerlink" title="Trackbar找阈值"></a>Trackbar找阈值</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;using namespace std;string winName &#x3D; &quot;threshould&quot;;Mat src, gray;int g_ThreshouldValue &#x3D; 100;&#x2F;&#x2F; 回调函数void on_Threshould(int ,void* )&#123;    threshold(gray, dst, g_ThreshouldValue, 255, THRESH_BINARY);    imshow(winName, dst);&#125;int main(int artc, char** argv) &#123;    src &#x3D; imread(&quot;&#x2F;home&#x2F;kavin&#x2F;Pictures&#x2F;panels&#x2F;panels_2&#x2F;dst_1.png&quot;, IMREAD_COLOR);    Mat dst &#x3D; src.clone();    if (src.empty()) &#123;        cout &lt;&lt; &quot;can&#39;t find picture&quot; &lt;&lt; endl;        return -1;    &#125;    Mat blur;    GaussianBlur(src, blur, Size(3, 3), 0, 0);    cvtColor(blur, gray, COLOR_BGR2GRAY);    namedWindow(winName, WINDOW_NORMAL);    &#x2F;&#x2F;创建trackbar，确定二值化的阈值    createTrackbar(&quot;threshould&quot;, winName, &amp;g_ThreshouldValue, 255, on_Threshould);    on_Threshould(0, 0);    while (1)    &#123;        int key;        key &#x3D; waitKey(20);        if (char(key) &#x3D;&#x3D; 27) break;    &#125;    &#x2F;&#x2F; threshold(gray, dst, 135, 255, THRESH_BINARY);    waitKey(0);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="提取矩形"><a href="#提取矩形" class="headerlink" title="提取矩形"></a>提取矩形</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;using namespace std;string winName &#x3D; &quot;threshould&quot;;Mat src, gray;int main(int artc, char** argv) &#123;    src &#x3D; imread(&quot;&#x2F;home&#x2F;kavin&#x2F;Pictures&#x2F;panels&#x2F;panels_2&#x2F;dst_1.png&quot;, IMREAD_COLOR);    Mat dst &#x3D; src.clone();    if (src.empty()) &#123;        cout &lt;&lt; &quot;can&#39;t find picture&quot; &lt;&lt; endl;        return -1;    &#125;    Mat blur;    GaussianBlur(src, blur, Size(3, 3), 0, 0);    cvtColor(blur, gray, COLOR_BGR2GRAY);    namedWindow(winName, WINDOW_NORMAL);        gray &#x3D; gray &gt; 130;    Mat kernal &#x3D; getStructuringElement(MORPH_RECT, Size(12, 12));    Mat img_dilate, img_erosion;    Mat dstImage &#x3D; Mat::zeros(src.size(), CV_8U);    dilate(gray, img_dilate, kernal);    &#x2F;&#x2F; imshow(&quot;dilate&quot;, img_dilate);    vector&lt;vector&lt;Point&gt; &gt; contours;    &#x2F;&#x2F; 存储轮廓点    vector&lt;Vec4i&gt; hierarchy;    findContours(img_dilate, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE);    vector&lt;Rect&gt; panelsRect;    &#x2F;&#x2F; drawContours(src, contours, -1, Scalar(255, 0, 255), 3);    &#x2F;&#x2F; 画出符合条件的轮廓，并生成矩形    for (int i &#x3D; 0; i &lt; contours.size(); i++) &#123;        if (arcLength(contours[i], true) &gt;&#x3D; 450 &amp;&amp; arcLength(contours[i], true) &lt;&#x3D; 500) &#123;            drawContours(src, contours, i, Scalar(255, 0, 255), 2);            Rect boundRect &#x3D; boundingRect(Mat(contours[i]));            rectangle(src, boundRect.tl(), boundRect.br(), Scalar(0, 255, 0), 2);            panelsRect.push_back(boundRect);        &#125;    &#125;    cout &lt;&lt; panelsRect.size() &lt;&lt; endl;        Mat panel;    for (int i &#x3D; 0; i &lt; 2; i++) &#123;        dst(panelsRect[i]).copyTo(panel);        imshow(&quot;panel_&quot; + to_string(i), panel);    &#125;    imshow(winName, src);    waitKey(0);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/13/OpenCV-OpenCV-shadow/panel.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">原图</div></center>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV_mask/transform</title>
      <link href="2021/04/12/OpenCV-OpenCV-mask/"/>
      <url>2021/04/12/OpenCV-OpenCV-mask/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="颜色分割"><a href="#颜色分割" class="headerlink" title="颜色分割"></a>颜色分割</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import cv2 as cvimport numpy as npsrc &#x3D; cv.imread(&quot;.&#x2F;bird.png&quot;)blur &#x3D; cv.blur(src, (5, 5))     # 滤波blur0 &#x3D; cv.medianBlur(blur, 5)blur1 &#x3D; cv.GaussianBlur(blur0, (5, 5), 0)blur2 &#x3D; cv.bilateralFilter(blur1, 9, 75, 75)hsv &#x3D; cv.cvtColor(blur2, cv.COLOR_BGR2HSV)  # 转换颜色空间low_blue &#x3D; np.array([55, 0, 0])high_blue &#x3D; np.array([118, 255, 255])mask &#x3D; cv.inRange(hsv, low_blue, high_blue)res &#x3D; cv.bitwise_and(src, src, mask&#x3D;mask)cv.imwrite(&#39;bird_1.png&#39;, res)cv.namedWindow(&quot;input&quot;, cv.WINDOW_AUTOSIZE)cv.imshow(&quot;input&quot;, res)cv.waitKey(0)cv.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/bird.png#pic_center" width="80%" height="80%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">原始图像</div></center><center><img src="/2021/04/12/OpenCV-OpenCV-mask/bird_1.png#pic_center" width="80%" height="80%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">分割图像</div></center><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">import numpy as npimport cv2 as cvimport matplotlib.pyplot as pltimg &#x3D; cv.imread(&#39;1.png&#39;)print(img.shape)rows, cols &#x3D; img.shape[:2]print(rows)print(cols)pts1 &#x3D; np.float32([[50, 50], [200, 50], [50, 200]])pts2 &#x3D; np.float32([[100, 100], [200, 50], [100, 250]])M &#x3D; cv.getAffineTransform(pts1, pts2)dst &#x3D; cv.warpAffine(img, M, (cols, rows))fig, axes &#x3D; plt.subplots(nrows&#x3D;1, ncols&#x3D;2, figsize&#x3D;(10, 8), dpi&#x3D;100)axes[0].imshow(img[:, :, ::-1])axes[0].set_title(&#39;init&#39;)axes[1].imshow(dst[:, :, ::-1])axes[1].set_title(&#39;transform&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/affine.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">仿射变换</div></center><h2 id="透射变换"><a href="#透射变换" class="headerlink" title="透射变换"></a>透射变换</h2><p>透射变换是视角变化的结果，是指利用透视中心、像点、目标点三点共线的条件，按透视旋转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。</p><center><img src="/2021/04/12/OpenCV-OpenCV-mask/2.png#pic_center" width="80%" height="80%" alt="test"></center><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Mat M &#x3D; getPerspectiveTransform(pts, pt2);&#x2F;&#x2F; 由两幅图像的对应4个点获得变换矩阵warpPerspective(src, dst, M, Size(dst_width, dst_height));&#x2F;&#x2F; src: 源图像&#x2F;&#x2F; dst: 目标图像&#x2F;&#x2F; M: 变换矩阵&#x2F;&#x2F; Size: 变换后的图像大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;using namespace std;Mat src, mat, dst;int pts_count &#x3D; 0;Point2f pts[4];     &#x2F;&#x2F; 需要指定4个点构造矩阵int dst_width &#x3D; 800;int dst_height &#x3D; 600;&#x2F;&#x2F; 鼠标双击事件，确定需要变换的区域static void _mouse_double_click_handler(int nEvt, int x, int y, int flags, void* p) &#123;    switch (nEvt)    &#123;    case EVENT_LBUTTONDBLCLK:        if (pts_count &lt; 4) &#123;            pts[pts_count] &#x3D; Point2f(x, y);            pts_count++;            circle(mat, Point(x, y), 5, Scalar(0, 0, 255), -1, 8);            imshow(&quot;src&quot;, mat);        &#125;        break;    default:        break;    &#125;    if (pts_count &#x3D;&#x3D; 4) &#123;        Point2f pt2[4];        pt2[0] &#x3D; Point2f(0, 0);        pt2[1] &#x3D; Point2f(dst_width, 0);        pt2[2] &#x3D; Point2f(dst_width, dst_height);        pt2[3] &#x3D; Point2f(0, dst_height);        Mat M &#x3D; getPerspectiveTransform(pts, pt2);        warpPerspective(src, dst, M, Size(dst_width, dst_height));        imshow(&quot;dst&quot;, dst);        imwrite(&quot;transform.png&quot;, dst);    &#125;&#125;int main(int artc, char** argv) &#123;    src &#x3D; imread(&quot;1.png&quot;, IMREAD_COLOR);    if (src.empty()) &#123;        cout &lt;&lt; &quot;can&#39;t find picture&quot; &lt;&lt; endl;        return -1;    &#125;    namedWindow(&quot;src&quot;);    setMouseCallback(&quot;src&quot;, _mouse_double_click_handler);    mat &#x3D; src.clone();    imshow(&quot;src&quot;, mat);    waitKey(0);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/1.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">原始图像</div></center><center><img src="/2021/04/12/OpenCV-OpenCV-mask/transform.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">仿射图像</div></center><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npimport cv2 as cvimport matplotlib.pyplot as pltdst_width &#x3D; 1200dst_height &#x3D; 900img &#x3D; cv.imread(&#39;1.png&#39;)print(img.shape)rows, cols &#x3D; img.shape[:2]print(rows)print(cols)pts1 &#x3D; np.float32([[33, 74], [1238, 60], [963, 555], [318, 563]])pts2 &#x3D; np.float32([[0, 0], [dst_width, 0], [dst_width, dst_height], [0, dst_height]])M &#x3D; cv.getPerspectiveTransform(pts1, pts2)dst &#x3D; cv.warpPerspective(img, M, (dst_width, dst_height))cv.imwrite(&#39;perspective.png&#39;, dst)fig, axes &#x3D; plt.subplots(nrows&#x3D;1, ncols&#x3D;2, figsize&#x3D;(10, 8), dpi&#x3D;100)axes[0].imshow(img[:, :, ::-1])axes[0].set_title(&#39;init&#39;)axes[1].imshow(dst[:, :, ::-1])axes[1].set_title(&#39;transform&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/perspective.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">仿射变换</div></center><h2 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npimport cv2 as cvimport matplotlib.pyplot as pltsrc &#x3D; cv.imread(&#39;mask2.png&#39;)img &#x3D; cv.cvtColor(src, cv.COLOR_BGR2GRAY)kernel &#x3D; np.ones((10, 10), np.int8)kernel2 &#x3D; np.ones((25, 25), np.int8)erosion &#x3D; cv.erode(img, kernel)dilate &#x3D; cv.dilate(erosion, kernel2)plt.figure(1)plt.imshow(src[:, :, ::-1])plt.figure(2)plt.imshow(dilate, cmap&#x3D;&quot;binary&quot;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/open.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">开运算</div></center><h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">import numpy as npimport cv2 as cvimport matplotlib.pyplot as pltsrc &#x3D; cv.imread(&#39;open.png&#39;, cv.IMREAD_GRAYSCALE)print(src.shape)low &#x3D; 100high &#x3D; 200canny &#x3D; cv.Canny(src, low, high)fig, axes &#x3D; plt.subplots(nrows&#x3D;1, ncols&#x3D;2, figsize&#x3D;(10, 8), dpi&#x3D;100)axes[0].imshow(src, cmap&#x3D;&quot;binary&quot;)axes[0].set_title(&#39;init&#39;)axes[1].imshow(canny, cmap&#x3D;&quot;binary&quot;)axes[1].set_title(&#39;Canny&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/canny.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">边缘检测</div></center><h2 id="绘制轮廓"><a href="#绘制轮廓" class="headerlink" title="绘制轮廓"></a>绘制轮廓</h2><pre class="line-numbers language-py" data-language="py"><code class="language-py">cv.drawContours(image, contours, contourIdx&#x3D;1, color&#x3D;(255, 0, 0), thickness&#x3D;5)# image: 在哪个图像上画# contours: 轮廓集合# contourIdx: 绘制哪个轮廓，-1表示所有# color: 颜色# thickness: 线宽<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-py" data-language="py"><code class="language-py">import cv2 as cvfrom matplotlib import pyplot as pltimport numpy as npimage &#x3D; cv.imread(&quot;images&#x2F;open.png&quot;)print(image.shape)blur &#x3D; cv.blur(image, (5, 5))gray &#x3D; cv.cvtColor(blur, cv.COLOR_BGR2GRAY)# 二值化ret, binary &#x3D; cv.threshold(gray, 20, 100, cv.THRESH_BINARY_INV)contours, hierarchy &#x3D; cv.findContours(binary, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)print(&#39;len:&#39;, len(contours))    # 2cv.drawContours(image, contours, contourIdx&#x3D;1, color&#x3D;(255, 0, 0), thickness&#x3D;5)# 选择符合要求的轮廓进行绘制# for i in range(len(contours)):#     cnt &#x3D; contours[i]#     perimeter &#x3D; cv.arcLength(cnt, True)   # 轮廓周长#     if 3000 &lt; perimeter &lt; 3300:#         cv.drawContours(image, [cnt], -1, (255, 0, 0), 5)fig, axes &#x3D; plt.subplots(nrows&#x3D;1, ncols&#x3D;2, figsize&#x3D;(10, 8), dpi&#x3D;100)axes[0].imshow(binary, cmap&#x3D;&quot;binary&quot;)axes[0].set_title(&#39;bibary&#39;)axes[1].imshow(image, cmap&#x3D;&quot;binary&quot;)axes[1].set_title(&#39;contours&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-mask/contour.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">绘制轮廓</div></center>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV_Panel</title>
      <link href="2021/04/12/OpenCV-OpenCV-Panel/"/>
      <url>2021/04/12/OpenCV-OpenCV-Panel/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-py" data-language="py"><code class="language-py">import cv2 as cvfrom matplotlib import pyplot as pltimport numpy as npfrom numpy.linalg import inv&quot;&quot;&quot; 求两直线交点 &quot;&quot;&quot;def intersection(line1, line2):    # [x1, y1, x2, y2]    a1 &#x3D; line1[1] - line1[3]    # a &#x3D; y1 - y2    b1 &#x3D; line1[2] - line1[0]    # b &#x3D; x2 - x1    c1 &#x3D; line1[0] * line1[3] - line1[2] * line1[1]    # c &#x3D; x1 * y2 - x2 * y1    a2 &#x3D; line2[1] - line2[3]    # a &#x3D; y1 - y2    b2 &#x3D; line2[2] - line2[0]    # b &#x3D; x2 - x1    c2 &#x3D; line2[0] * line2[3] - line2[2] * line2[1]    # c &#x3D; x1 * y2 - x2 * y1    A &#x3D; np.array([[a1, b1], [a2, b2]])    B &#x3D; np.array([[c1], [c2]])    pt &#x3D; np.dot(inv(A), -B)    x &#x3D; pt[0, 0]    y &#x3D; pt[1, 0]    return [x, y]src &#x3D; cv.imread(&quot;images&#x2F;2.png&quot;)mat &#x3D; src.copy()gray &#x3D; cv.cvtColor(src, cv.COLOR_BGR2GRAY)blur &#x3D; cv.blur(gray, (5, 5))# plt.figure(1)# plt.imshow(blur, cmap&#x3D;&quot;binary&quot;)kernel &#x3D; np.ones((10, 10), np.int8)dilate &#x3D; cv.dilate(blur, kernel)&quot;&quot;&quot; 二值化 &quot;&quot;&quot;ret, binary &#x3D; cv.threshold(dilate, 100, 120, cv.THRESH_BINARY_INV)# plt.figure(2)# plt.imshow(binary, cmap&#x3D;&quot;binary&quot;)&quot;&quot;&quot; 求轮廓 &quot;&quot;&quot;contours, hierarchy &#x3D; cv.findContours(binary, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)# print(&#39;len:&#39;, len(contours))cnt &#x3D; contours[0]# cv.drawContours(src, [cnt], -1, (0, 0, 255), 2)&quot;&quot;&quot; 找到满足周长条件的轮廓 &quot;&quot;&quot;for i in range(len(contours)):    cnt &#x3D; contours[i]    perimeter &#x3D; cv.arcLength(cnt, True)    if 2500 &lt; perimeter &lt; 3500:        print(perimeter)        # cv.drawContours(src, [cnt], -1, (0, 255, 255), 2)        break# plt.figure(2)# plt.imshow(src[:, :, ::-1])&quot;&quot;&quot; 求凸包 &quot;&quot;&quot;hull &#x3D; cv.convexHull(cnt)img &#x3D; np.ones((720, 1280, 3), dtype&#x3D;np.uint8)# print(type(gray))   # &lt;class &#39;numpy.ndarray&#39;&gt;# print(gray.shape)   # (720, 1280)# print(type(img))    # &lt;class &#39;numpy.ndarray&#39;&gt;# print(img.shape)    # (720, 1280)# cv.drawContours(src, [hull], -1, (255, 0, 0), 3)# print(len(hull))&quot;&quot;&quot; 在另一张图上画出凸包 &quot;&quot;&quot;cv.drawContours(img, [hull], -1, (0, 0, 255), 2)img_gray &#x3D; cv.cvtColor(img, cv.COLOR_BGR2GRAY)&quot;&quot;&quot; 二值化 &quot;&quot;&quot;_, img_binary &#x3D; cv.threshold(img_gray, 50, 100, cv.THRESH_BINARY)plt.figure(3)plt.imshow(img_binary, cmap&#x3D;&quot;binary&quot;)#### cv.imwrite(&quot;images&#x2F;img.png&quot;, img_binary)&quot;&quot;&quot; 霍夫线检测 &quot;&quot;&quot;lines &#x3D; cv.HoughLines(img_binary, 1.0, np.pi&#x2F;180, 250)print(lines.shape)      # (8, 1, 2)lines &#x3D; np.squeeze(lines)print(lines.shape)      # (8, 2)&quot;&quot;&quot; K-means对四种线分类 &quot;&quot;&quot;criteria &#x3D; (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 10, 1.0)ret,label,center &#x3D; cv.kmeans(lines, 4, None, criteria, 10, cv.KMEANS_RANDOM_CENTERS)# print(center.shape)   # (4, 2)line_point &#x3D; []for i in range(center.shape[0]):    rho, theta &#x3D; center[i]    a &#x3D; np.cos(theta)    b &#x3D; np.sin(theta)    x0 &#x3D; rho * a    y0 &#x3D; rho * b    x1 &#x3D; int(x0 + 2000 * (-b))    y1 &#x3D; int(y0 + 2000 * a)    x2 &#x3D; int(x0 - 2000 * (-b))    y2 &#x3D; int(y0 - 2000 * a)    line_point.append([x1, y1, x2, y2])    cv.line(img, (x1, y1), (x2, y2), (255, 0, 255), 4)# print(line_point)&quot;&quot;&quot; 求4条线的4个交点 &quot;&quot;&quot;pt &#x3D; []for i in range(2):    pt.append(intersection(line_point[i], line_point[2]))    pt.append(intersection(line_point[i], line_point[3]))print(pt)points &#x3D; np.array(pt, dtype&#x3D;int)print(points.shape)     # (4, 2)print(points)# for i in range(points.shape[0]):#     cv.circle(img, (points[i, 0], points[i, 1]), 8, (0, 255, 0), -1)&quot;&quot;&quot; 画出4个交点 &quot;&quot;&quot;for pt in points:    cv.circle(img, (pt[0], pt[1]), 6, (0, 255, 0), -1)plt.figure(5)plt.imshow(img)# cv.imwrite(&quot;images&#x2F;lines.png&quot;, img)&quot;&quot;&quot; 对4个交点进行排序，因为分类的顺序是随机的 &quot;&quot;&quot;idx &#x3D; np.lexsort([points[:, 0]])tr_points &#x3D; points[idx, :]print(tr_points)&quot;&quot;&quot; 利用找到的4隔点进行透射变换 &quot;&quot;&quot;dst_width &#x3D; 800dst_height &#x3D; 600pts1 &#x3D; np.float32([tr_points[0], tr_points[3], tr_points[2], tr_points[1]])pts2 &#x3D; np.float32([[0, 0], [dst_width, 0], [dst_width, dst_height], [0, dst_height]])M &#x3D; cv.getPerspectiveTransform(pts1, pts2)dst &#x3D; cv.warpPerspective(mat, M, (dst_width, dst_height))plt.figure(6)plt.imshow(dst[:, :, ::-1])cv.imwrite(&#39;images&#x2F;dst_2.png&#39;, dst)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/12/OpenCV-OpenCV-Panel/1.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">1.原图</div></center><center><img src="/2021/04/12/OpenCV-OpenCV-Panel/img.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">2.凸包</div></center><center><img src="/2021/04/12/OpenCV-OpenCV-Panel/lines.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">3. 霍夫线检测与交点</div></center><center><img src="/2021/04/12/OpenCV-OpenCV-Panel/dst_1.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">4.透射变换</div></center>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV_Pix</title>
      <link href="2021/04/01/OpenCV-OpenCV-Pix/"/>
      <url>2021/04/01/OpenCV-OpenCV-Pix/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="获取并修改像素值"><a href="#获取并修改像素值" class="headerlink" title="获取并修改像素值"></a>获取并修改像素值</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;using namespace cv;using namespace std;int main(int artc, char** argv) &#123;    Mat src &#x3D; imread(&quot;&#x2F;home&#x2F;kavin&#x2F;Pictures&#x2F;test.png&quot;, IMREAD_COLOR);    if (src.empty()) &#123;        printf(&quot;could not load image...\n&quot;);        return -1;    &#125;    for (int i &#x3D; 5; i &lt; 50; i++) &#123;          &#x2F;&#x2F; 行        for (int j &#x3D; 30; j &lt; 100; j++) &#123;    &#x2F;&#x2F; 列            src.at&lt;Vec3b&gt;(i, j)[0] &#x3D; 255;            src.at&lt;Vec3b&gt;(i, j)[1] &#x3D; 0;            src.at&lt;Vec3b&gt;(i, j)[2] &#x3D; 0;        &#125;    &#125;    namedWindow(&quot;input&quot;, WINDOW_AUTOSIZE);    imshow(&quot;input&quot;, src);    imwrite(&quot;pix.png&quot;, src);    waitKey(0);    &#x2F;&#x2F; 对应的roi区域 （左上角坐标（w,h）,width,height）    Rect rect_roi(30, 5, 70, 45);    Mat img_roi &#x3D; src(rect_roi);    imshow(&quot;roi&quot;, img_roi);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/01/OpenCV-OpenCV-Pix/pixels.png#pic_center" width="50%" height="50%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">修改像素值</div></center><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">src &#x3D; cv.imread(&quot;.&#x2F;test.png&quot;)&#x2F;&#x2F; 获取某个点的像素值px &#x3D; src[200, 250]      # [ 27  15 244]&#x2F;&#x2F; 获取某个点某个通道的像素值blue &#x3D; src[200, 250, 0] # 27&#x2F;&#x2F; 修改高度为200的所有像素值为0src[200, :] &#x3D; [0, 0, 0]cv.namedWindow(&quot;input&quot;, cv.WINDOW_AUTOSIZE)cv.imshow(&quot;input&quot;, src)cv.waitKey(0)cv.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/01/OpenCV-OpenCV-Pix/pix.png#pic_center" width="50%" height="50%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">修改像素值</div></center><h2 id="通道拆分与合并"><a href="#通道拆分与合并" class="headerlink" title="通道拆分与合并"></a>通道拆分与合并</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">b, g, r &#x3D; cv.split(src)img &#x3D; cv.merge((b, g, r))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><center><img src="/2021/04/01/OpenCV-OpenCV-Pix/b.png#pic_center" width="50%" height="50%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">B通道图像</div></center><h2 id="转换颜色空间"><a href="#转换颜色空间" class="headerlink" title="转换颜色空间"></a>转换颜色空间</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">hsv &#x3D; cv.cvtColor(src, cv.COLOR_BGR2HSV)cv.namedWindow(&quot;hsv&quot;, cv.WINDOW_AUTOSIZE)cv.imshow(&quot;hsv&quot;, hsv)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/01/OpenCV-OpenCV-Pix/hsv.png#pic_center" width="50%" height="50%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">HSV颜色空间</div></center>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV_RGB&amp;GRAY</title>
      <link href="2021/04/01/OpenCV-OpenCV-RGB-GRAY/"/>
      <url>2021/04/01/OpenCV-OpenCV-RGB-GRAY/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="读取图像"><a href="#读取图像" class="headerlink" title="读取图像"></a>读取图像</h2><h3 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">imread( const String&amp; filename, int flags &#x3D; IMREAD_COLOR )filename&#x2F;&#x2F; 图片路径flags&#x2F;&#x2F; 以彩色图或灰度图的方式进行读取    IMREAD_GRAYSCALE &#x3D; 0    &#x2F;&#x2F; 灰度图    IMREAD_COLOR     &#x3D; 1    &#x2F;&#x2F; 彩色图(默认)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">namedWindow(const String&amp; winname, int flags &#x3D; WINDOW_AUTOSIZE)winname&#x2F;&#x2F; 窗口名称flags&#x2F;&#x2F; 窗口属性WINDOW_NORMAL&#x2F;&#x2F; 可拖动改变大小WINDOW_AUTOSIZE&#x2F;&#x2F; 自动调整适应图片大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">imwrite(const String&amp; filename, InputArray img, const std::vector&lt;int&gt;&amp; params &#x3D; std::vector&lt;int&gt;())filename&#x2F;&#x2F; 文件名img&#x2F;&#x2F; 对象名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Mat src &#x3D; imread(&quot;.&#x2F;test.png&quot;, IMREAD_GRAYSCALE);namedWindow(&quot;input&quot;, WINDOW_AUTOSIZE);imshow(&quot;input&quot;, src);waitKey(0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv.imread()cv.imshow()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">import cv2 as cvsrc &#x3D; cv.imread(&quot;.&#x2F;test.png&quot;)print(type(src))&#x2F;&#x2F; &lt;class &#39;numpy.ndarray&#39;&gt;print(src.dtype)&#x2F;&#x2F; uint8print(src.shape)&#x2F;&#x2F; (610, 570, 3)cv.namedWindow(&quot;input&quot;, cv.WINDOW_AUTOSIZE)cv.imshow(&quot;input&quot;, src)cv.waitKey(0)cv.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/01/OpenCV-OpenCV-RGB-GRAY/test.png#pic_center" width="50%" height="50%" alt="test"></center><h2 id="转化为灰度图"><a href="#转化为灰度图" class="headerlink" title="转化为灰度图"></a>转化为灰度图</h2><h3 id="C-版本-1"><a href="#C-版本-1" class="headerlink" title="C++版本"></a>C++版本</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cvtColor(src, gray, COLOR_BGR2GRAY)src&#x2F;&#x2F; inputgray&#x2F;&#x2F; outputCOLOR_BGR2GRAY&#x2F;&#x2F;RGB图转为GRAY灰度图默认三个通道顺序是: B, G, R<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;opencv2&#x2F;opencv.hpp&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;int main(int artc, char** argv) &#123;    Mat src &#x3D; imread(&quot;.&#x2F;test.png&quot;, IMREAD_COLOR);    if (src.empty()) &#123;        printf(&quot;could not load image...\n&quot;);        return -1;    &#125;    namedWindow(&quot;input&quot;, WINDOW_AUTOSIZE);    imshow(&quot;input&quot;, src);    Mat gray;    cvtColor(src, gray, COLOR_BGR2GRAY);    imwrite(&quot;.&#x2F;gray.png&quot;, gray);    namedWindow(&quot;gray&quot;, WINDOW_AUTOSIZE);    imshow(&quot;gray&quot;, gray);    waitKey(0);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Python版本-1"><a href="#Python版本-1" class="headerlink" title="Python版本"></a>Python版本</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">src &#x3D; cv.imread(&quot;.&#x2F;test.png&quot;)cv.namedWindow(&quot;input&quot;, cv.WINDOW_AUTOSIZE)cv.imshow(&quot;input&quot;, src)gray &#x3D; cv.cvtColor(src, cv.COLOR_BGR2GRAY)cv.imwrite(&#39;gray.png&#39;, gray)cv.imshow(&quot;gray&quot;, gray)cv.waitKey(0)cv.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/04/01/OpenCV-OpenCV-RGB-GRAY/gray.png#pic_center" width="50%" height="50%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">灰度图</div></center>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV_draw</title>
      <link href="2021/04/01/OpenCV-OpenCV-draw/"/>
      <url>2021/04/01/OpenCV-OpenCV-draw/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a>绘制直线</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv.line(img,start,end,color,thickness)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>img</code>: 要绘制直线的图像</li><li><code>start,end</code>: 直线的起点和终点</li><li><code>color</code>: 线条的颜色</li><li><code>thickness</code>: 线条宽度</li></ul><h2 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv.circle(img,centerpoint, r, color, thickness)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>img</code>: 要绘制圆形的图像</li><li><code>centerpoint, r</code>: 圆心和半径</li><li><code>color</code>: 线条的颜色</li><li><code>thickness</code>: 线条宽度，为-1时生成闭合图案并填充颜色</li></ul><h2 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv.rectangle(img,leftupper,rightdown,color,thickness)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>img</code>: 要绘制矩形的图像</li><li><code>leftupper, rightdown</code>: 矩形的左上角和右下角坐标</li><li><code>color</code>: 线条的颜色</li><li><code>thickness</code>: 线条宽度</li></ul><h2 id="向图像中添加文字"><a href="#向图像中添加文字" class="headerlink" title="向图像中添加文字"></a>向图像中添加文字</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv.putText(img,text,station, font, fontsize,color,thickness,cv.LINE_AA)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>img</code>: 图像</li><li><code>text</code>: 要写入的文本数据</li><li><code>station</code>: 文本的放置位置</li><li><code>font</code>: 字体</li><li><code>fontsize</code>: 字体大小</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">import cv2 as cvimport numpy as npsrc &#x3D; np.zeros([512, 512, 3], np.uint8)# 创建一张512X512大小的8位3通道图像，数据类型是unsigned int# 第一个方向是width，第二个是heightcv.line(src, (0, 0), (511, 511), (0, 0, 255), 3)cv.rectangle(src, (384,0),(510,128), (0,255,0), 3)cv.circle(src, (447,63), 63, (0,0,255), -1)font &#x3D; cv.FONT_ITALICcv.putText(src, &#39;OpenCV&#39;, (10,500), font, 2, (255,255,255), 2, cv.LINE_AA)cv.namedWindow(&quot;src&quot;, cv.WINDOW_AUTOSIZE)cv.imshow(&quot;src&quot;, src)cv.waitKey(0)cv.destroyAllWindows()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/2021/04/01/OpenCV-OpenCV-draw/draw.png#pic_center" width="50%" height="50%" alt="test">]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4</title>
      <link href="2021/03/26/PX4-PX4/"/>
      <url>2021/03/26/PX4-PX4/</url>
      
        <content type="html"><![CDATA[<!-- TOC --><h2 id="关于PX4的一些基本概念"><a href="#关于PX4的一些基本概念" class="headerlink" title="关于PX4的一些基本概念"></a>关于PX4的一些基本概念</h2><ul><li>PX4是一套开源的飞控套件，许多无人机的飞控系统都是基于PX4构建的</li><li>MAVLink是一种常用的通信协议，常用于无人机于地面站(Ground Control Station)或无人机之间的通讯</li><li>OFFBOARD控制：PX4仅仅执行飞行姿态等与飞行相关的控制，初次之外的其他控制(如视觉导航)由外部程序进行</li></ul><h2 id="ROS、PX4和它们之间的关系"><a href="#ROS、PX4和它们之间的关系" class="headerlink" title="ROS、PX4和它们之间的关系"></a>ROS、PX4和它们之间的关系</h2><ul><li>SITL即Software In The Loop，指的是使用软件飞控进行模拟飞行——PX4飞控运行在PC上</li><li>与之对应的是HITL，Hardware In The Loop，即使用单独的飞控硬件执行模拟</li><li>无人机可以使用专业的飞行遥控器进行控制，也可以使用软件在PC或手机上进行控制</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> PX4 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4_pos_estimator</title>
      <link href="2021/03/26/PX4-PX4-pos-estimator/"/>
      <url>2021/03/26/PX4-PX4-pos-estimator/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int input_source;float rate_hz;Eigen::Vector3f pos_offset;float yaw_offset;string object_name;ros::Time last_timestamp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="laser定位相关"><a href="#laser定位相关" class="headerlink" title="laser定位相关"></a>laser定位相关</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen::Vector3d pos_drone_laser; &#x2F;&#x2F;无人机当前位置 (laser)Eigen::Quaterniond q_laser;Eigen::Vector3d Euler_laser; &#x2F;&#x2F;无人机当前姿态(laser)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="T265"><a href="#T265" class="headerlink" title="T265"></a>T265</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen::Vector3d pos_drone_t265;Eigen::Quaterniond q_t265;Eigen::Vector3d Euler_t265;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="gazebo真值相关"><a href="#gazebo真值相关" class="headerlink" title="gazebo真值相关"></a>gazebo真值相关</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen::Vector3d pos_drone_gazebo;Eigen::Quaterniond q_gazebo;Eigen::Vector3d Euler_gazebo;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="SLAM相关"><a href="#SLAM相关" class="headerlink" title="SLAM相关"></a>SLAM相关</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen::Vector3d pos_drone_slam;Eigen::Quaterniond q_slam;Eigen::Vector3d Euler_slam;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="发布相关变量"><a href="#发布相关变量" class="headerlink" title="发布相关变量"></a>发布相关变量</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">geometry_msgs::TransformStamped laser; &#x2F;&#x2F;当前时刻cartorgrapher发布的数据ros::Publisher vision_pub;ros::Publisher drone_state_pub;ros::Publisher message_pub;ros::Publisher odom_pub;ros::Publisher trajectory_pub;prometheus_msgs::Message message;prometheus_msgs::DroneState Drone_State;nav_msgs::Odometry Drone_odom;std::vector&lt;geometry_msgs::PoseStamped&gt; posehistory_vector_;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">ros::init(argc, argv, &quot;px4_pos_estimator&quot;);ros::NodeHandle nh(&quot;~&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="读取参数表中的参数"><a href="#读取参数表中的参数" class="headerlink" title="读取参数表中的参数"></a>读取参数表中的参数</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;读取参数表中的参数&#x2F;&#x2F; 定位数据输入源 0 for vicon， 1 for 激光SLAM, 2 for gazebo ground truth, 3 for T265 ,  9 for outdoor nh.param&lt;int&gt;(&quot;input_source&quot;, input_source, 0);&#x2F;&#x2F;　程序执行频率nh.param&lt;float&gt;(&quot;rate_hz&quot;, rate_hz, 20);&#x2F;&#x2F;　定位设备偏移量nh.param&lt;float&gt;(&quot;offset_x&quot;, pos_offset[0], 0);nh.param&lt;float&gt;(&quot;offset_y&quot;, pos_offset[1], 0);nh.param&lt;float&gt;(&quot;offset_z&quot;, pos_offset[2], 0);nh.param&lt;float&gt;(&quot;offset_yaw&quot;, yaw_offset, 0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 【订阅】cartographer估计位置ros::Subscriber laser_sub &#x3D; nh.subscribe&lt;tf2_msgs::TFMessage&gt;(&quot;&#x2F;tf&quot;, 100, laser_cb);&#x2F;&#x2F; 【订阅】t265估计位置ros::Subscriber t265_sub &#x3D; nh.subscribe&lt;nav_msgs::Odometry&gt;(&quot;&#x2F;t265&#x2F;odom&#x2F;sample&quot;, 100, t265_cb);&#x2F;&#x2F; 【订阅】gazebo仿真真值ros::Subscriber gazebo_sub &#x3D; nh.subscribe&lt;nav_msgs::Odometry&gt;(&quot;&#x2F;prometheus&#x2F;ground_truth&#x2F;p300_basic&quot;, 100, gazebo_cb);&#x2F;&#x2F; 【订阅】SLAM估计位姿ros::Subscriber slam_sub &#x3D; nh.subscribe&lt;geometry_msgs::PoseStamped&gt;(&quot;&#x2F;slam&#x2F;pose&quot;, 100, slam_cb);&#x2F;&#x2F; 10秒定时打印，以确保程序在正确运行ros::Timer timer &#x3D; nh.createTimer(ros::Duration(10.0), timerCallback);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><h4 id="laser-cb"><a href="#laser-cb" class="headerlink" title="laser_cb"></a>laser_cb</h4><h4 id="gazebo-cb"><a href="#gazebo-cb" class="headerlink" title="gazebo_cb"></a>gazebo_cb</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pos_drone_gazebo &#x3D; Eigen::Vector3d(msg-&gt;pose.pose.position.x, msg-&gt;pose.pose.position.y, msg-&gt;pose.pose.position.z);q_gazebo &#x3D; Eigen::Quaterniond(msg-&gt;pose.pose.oriention.w, msg-&gt;pose.pose.oriention.x, msg-&gt;pose.pose.oriention.y, msg-&gt;pose.pose.oriention.z);Euler_gazebo &#x3D; quaterniond_to_euler(q_gazebo);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="slam-cb"><a href="#slam-cb" class="headerlink" title="slam_cb"></a>slam_cb</h4><h4 id="t265-cb"><a href="#t265-cb" class="headerlink" title="t265_cb"></a>t265_cb</h4><h4 id="timerCallback"><a href="#timerCallback" class="headerlink" title="timerCallback"></a>timerCallback</h4><h3 id="用于与mavros通讯的类，通过mavros接收来至飞控的消息【飞控-gt-mavros-gt-本程序】"><a href="#用于与mavros通讯的类，通过mavros接收来至飞控的消息【飞控-gt-mavros-gt-本程序】" class="headerlink" title="用于与mavros通讯的类，通过mavros接收来至飞控的消息【飞控-&gt;mavros-&gt;本程序】"></a>用于与mavros通讯的类，通过mavros接收来至飞控的消息【飞控-&gt;mavros-&gt;本程序】</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">state_from_mavros _state_from_mavros;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="state-from-mavros订阅的话题"><a href="#state-from-mavros订阅的话题" class="headerlink" title="state_from_mavros订阅的话题"></a>state_from_mavros订阅的话题</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 【订阅】无人机当前状态 - 来自飞控state_sub &#x3D; state_nh.subscribe&lt;mavros_msgs::State&gt;(uav_name + &quot;&#x2F;mavros&#x2F;state&quot;, 10, &amp;state_from_mavros::state_cb,this);&#x2F;&#x2F; 【订阅】无人机当前状态 - 来自飞控extended_state_sub &#x3D; state_nh.subscribe&lt;mavros_msgs::ExtendedState&gt;(uav_name + &quot;&#x2F;mavros&#x2F;extended_state&quot;, 10, &amp;state_from_mavros::extended_state_cb,this);&#x2F;&#x2F; 【订阅】无人机当前位置 坐标系:ENU系 （此处注意，所有状态量在飞控中均为NED系，但在ros中mavros将其转换为ENU系处理。所以，在ROS中，所有和mavros交互的量都为ENU系）position_sub &#x3D; state_nh.subscribe&lt;geometry_msgs::PoseStamped&gt;(uav_name + &quot;&#x2F;mavros&#x2F;local_position&#x2F;pose&quot;, 10, &amp;state_from_mavros::pos_cb,this);&#x2F;&#x2F; 【订阅】无人机当前速度 坐标系:ENU系velocity_sub &#x3D; state_nh.subscribe&lt;geometry_msgs::TwistStamped&gt;(uav_name + &quot;&#x2F;mavros&#x2F;local_position&#x2F;velocity_local&quot;, 10, &amp;state_from_mavros::vel_cb,this);&#x2F;&#x2F; 【订阅】无人机当前欧拉角 坐标系:ENU系attitude_sub &#x3D; state_nh.subscribe&lt;sensor_msgs::Imu&gt;(uav_name + &quot;&#x2F;mavros&#x2F;imu&#x2F;data&quot;, 10, &amp;state_from_mavros::att_cb,this); &#x2F;&#x2F; 【订阅】无人机相对高度 此订阅仅针对户外实验alt_sub &#x3D; state_nh.subscribe&lt;std_msgs::Float64&gt;(uav_name + &quot;&#x2F;mavros&#x2F;global_position&#x2F;rel_alt&quot;, 10, &amp;state_from_mavros::alt_cb,this);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h3><h4 id="send-to-fcu"><a href="#send-to-fcu" class="headerlink" title="send_to_fcu();"></a><code>send_to_fcu();</code></h4><ul><li>将采集的机载设备的定位信息及偏航角信息发送至飞控，根据参数<code>input_source</code>选择定位信息来源</li></ul><h4 id="pub-to-nodes-state-from-mavros-DroneState"><a href="#pub-to-nodes-state-from-mavros-DroneState" class="headerlink" title="pub_to_nodes(_state_from_mavros._DroneState);"></a><code>pub_to_nodes(_state_from_mavros._DroneState);</code></h4><ul><li>发布无人机状态至其他节点  </li><li>发布无人机当前<code>odometry</code>,用于导航及<code>rviz</code>显示</li><li>发布无人机运动轨迹，用于<code>rviz</code>显示<center><img src="/2021/03/26/PX4-PX4-pos-estimator/PX4.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">rqt_graph</div></center></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> PX4 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4_sender</title>
      <link href="2021/03/26/PX4-PX4-sender/"/>
      <url>2021/03/26/PX4-PX4-sender/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">float cur_time;         &#x2F;&#x2F;程序运行时间float Takeoff_height;   &#x2F;&#x2F;默认起飞高度float Disarm_height;    &#x2F;&#x2F;自动上锁高度float Land_speed;       &#x2F;&#x2F;降落速度int Land_mode;          &#x2F;&#x2F;降落策略选择Eigen::Vector2f geo_fence_x;        &#x2F;&#x2F;地理围栏Eigen::Vector2f geo_fence_y;Eigen::Vector2f geo_fence_z;Eigen::Vector3d Takeoff_position;   &#x2F;&#x2F; 起飞位置prometheus_msgs::DroneState _DroneState;    &#x2F;&#x2F;无人机状态量prometheus_msgs::ControlCommand Command_Now;    &#x2F;&#x2F;无人机当前执行命令prometheus_msgs::ControlCommand Command_Last;   &#x2F;&#x2F;无人机上一条执行命令Eigen::Vector3d state_sp(0,0,0);Eigen::Vector3d state_sp_extra(0,0,0);double yaw_sp;double yaw_rate_sp;prometheus_msgs::Message message;prometheus_msgs::LogMessageControl LogMessage;&#x2F;&#x2F;RVIZ显示：期望位置geometry_msgs::PoseStamped ref_pose_rviz;float dt &#x3D; 0;ros::Publisher rivz_ref_pose_pub;ros::Publisher message_pub;ros::Publisher log_message_pub;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 【订阅】为任务模块生成的控制指令(来自terminal_control.cpp)ros::Subscriber Command_sub &#x3D; nh.subscribe&lt;prometheus_msgs::ControlCommand&gt;(&quot;&#x2F;prometheus&#x2F;control_command&quot;, 10, Command_cb);&#x2F;&#x2F; 本话题为Prometheus地面站发送的控制指令ros::Subscriber station_command_sub &#x3D; nh.subscribe&lt;prometheus_msgs::ControlCommand&gt;(&quot;&#x2F;prometheus&#x2F;control_command_station&quot;, 10, station_command_cb);&#x2F;&#x2F;【订阅】无人机状态(来自px4_pos_estimator.cpp)ros::Subscriber drone_state_sub &#x3D; nh.subscribe&lt;prometheus_msgs::DroneState&gt;(&quot;&#x2F;prometheus&#x2F;drone_state&quot;, 10, drone_state_cb);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 【发布】参考位姿 RVIZ显示用rivz_ref_pose_pub &#x3D; nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;&#x2F;prometheus&#x2F;control&#x2F;ref_pose_rviz&quot;, 10);&#x2F;&#x2F; 【发布】用于地面站显示的提示消息message_pub &#x3D; nh.advertise&lt;prometheus_msgs::Message&gt;(&quot;&#x2F;prometheus&#x2F;message&#x2F;main&quot;, 10);&#x2F;&#x2F; 【发布】用于log的消息log_message_pub &#x3D; nh.advertise&lt;prometheus_msgs::LogMessageControl&gt;(&quot;&#x2F;prometheus&#x2F;log&#x2F;control&quot;, 10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 参数读取nh.param&lt;float&gt;(&quot;Takeoff_height&quot;, Takeoff_height, 1.0);nh.param&lt;float&gt;(&quot;Disarm_height&quot;, Disarm_height, 0.15);nh.param&lt;float&gt;(&quot;Land_speed&quot;, Land_speed, 0.2);nh.param&lt;int&gt;(&quot;Land_mode&quot;,Land_mode,0);nh.param&lt;float&gt;(&quot;geo_fence&#x2F;x_min&quot;, geo_fence_x[0], -100.0);nh.param&lt;float&gt;(&quot;geo_fence&#x2F;x_max&quot;, geo_fence_x[1], 100.0);nh.param&lt;float&gt;(&quot;geo_fence&#x2F;y_min&quot;, geo_fence_y[0], -100.0);nh.param&lt;float&gt;(&quot;geo_fence&#x2F;y_max&quot;, geo_fence_y[1], 100.0);nh.param&lt;float&gt;(&quot;geo_fence&#x2F;z_min&quot;, geo_fence_z[0], -100.0);nh.param&lt;float&gt;(&quot;geo_fence&#x2F;z_max&quot;, geo_fence_z[1], 100.0);&#x2F;&#x2F; 设定起飞位置Takeoff_position[0] &#x3D; 0.0;Takeoff_position[1] &#x3D; 0.0;Takeoff_position[2] &#x3D; 0.15;&#x2F;&#x2F; 建议控制频率: 10 - 50Hz, 控制频率取决于控制形式，若控制方式为速度或加速度应适当提高频率ros::Rate rate(20.0);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="用于与mavros通讯的类，通过mavros发送控制指令至飞控【本程序-gt-mavros-gt-飞控】"><a href="#用于与mavros通讯的类，通过mavros发送控制指令至飞控【本程序-gt-mavros-gt-飞控】" class="headerlink" title="用于与mavros通讯的类，通过mavros发送控制指令至飞控【本程序-&gt;mavros-&gt;飞控】"></a>用于与mavros通讯的类，通过mavros发送控制指令至飞控【本程序-&gt;mavros-&gt;飞控】</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">command_to_mavros _command_to_mavros;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F; 【订阅】无人机期望位置&#x2F;速度&#x2F;加速度 坐标系:ENU系 本话题来自飞控position_target_sub &#x3D; command_nh.subscribe&lt;mavros_msgs::PositionTarget&gt;(uav_name + &quot;&#x2F;mavros&#x2F;setpoint_raw&#x2F;target_local&quot;, 10, &amp;command_to_mavros::pos_target_cb,this);&#x2F;&#x2F; 【订阅】无人机期望角度&#x2F;角速度 坐标系:ENU系 本话题来自飞控attitude_target_sub &#x3D; command_nh.subscribe&lt;mavros_msgs::AttitudeTarget&gt;(uav_name + &quot;&#x2F;mavros&#x2F;setpoint_raw&#x2F;target_attitude&quot;, 10, &amp;command_to_mavros::att_target_cb,this);&#x2F;&#x2F; 【发布】位置&#x2F;速度&#x2F;加速度期望值至飞控 坐标系 ENU系advertise&lt;mavros_msgs::PositionTarget&gt;(uav_name + &quot;&#x2F;mavros&#x2F;setpoint_raw&#x2F;local&quot;, 10);&#x2F;&#x2F; 【发布】角度&#x2F;角速度期望值至飞控 坐标系 ENU系setpoint_raw_attitude_pub &#x3D; command_nh.advertise&lt;mavros_msgs::AttitudeTarget&gt;(uav_name + &quot;&#x2F;mavros&#x2F;setpoint_raw&#x2F;attitude&quot;, 10);&#x2F;&#x2F; 【发布】底层控制量（Mx My Mz 及 F） [0][1][2][3]分别对应 roll pitch yaw控制量及油门推力注意这里是NED系的！！actuator_setpoint_pub &#x3D; command_nh.advertise&lt;mavros_msgs::ActuatorControl&gt;(uav_name + &quot;&#x2F;mavros&#x2F;actuator_control&quot;, 10);&#x2F;&#x2F; 【发布】本话题要发送至飞控(通过Mavros_extra功能包 &#x2F;plugins&#x2F;mount_control.cpp发送)mount_control_pub &#x3D; command_nh.advertise&lt;mavros_msgs::MountControl&gt;(uav_name + &quot;&#x2F;mavros&#x2F;mount_control&#x2F;command&quot;, 1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h2><ul><li><p>Idle</p></li><li><p>Takeoff</p></li><li><p>Hold</p></li><li><p>Land</p></li><li><p>Move</p></li><li><p>Disarm</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> PX4 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus</title>
      <link href="2021/03/26/PX4-Prometheus/"/>
      <url>2021/03/26/PX4-Prometheus/</url>
      
        <content type="html"><![CDATA[<h2 id="Control模块"><a href="#Control模块" class="headerlink" title="Control模块"></a>Control模块</h2><ul><li>Idle：怠速；意思就是飞机会进入offboard模式，但是在该模式下，没有对飞机进行任何指令的发送。飞机也不会有任何动作。这个指令一般也可以不用。</li><li>Takeoff：起飞；起飞点为当前点，起飞高度通过 yaml参数设置，单位是米，默认起飞高度是0.5m</li><li>Hold：悬停；飞机正在飞行过程中如果接受到 2 指令，会在当前时刻进入悬停状态。</li><li>Land：降落；降落速度通过 yaml参数设置，单位是m/s ，默认降落速度为0.2m/s 。还有一个 上锁高度 到达上锁高度之后飞机会进入飞控的本身降落模式进而缓缓着地，上锁高度通过 yaml 参数进行设置，单位是米，默认是 0.18m，即认为离地不到20cm的时候进入飞控本身的降落飞行模式。</li><li>Move模式；该模式就包含我们所称的指点飞行功能，在此模式下，又有5种子模式，</li><li>XYZ_POS, 空间位置控制</li><li>XY_POS_Z_VEL, 水平面位置控制高度速度控制</li><li>XY_VEL_Z_POS, 水平面速度控制高度定高控制</li><li>XYZ_VEL, 空间速度控制</li><li>TRAJECTORY, 轨迹跟踪控制</li></ul><h2 id="Common模块"><a href="#Common模块" class="headerlink" title="Common模块"></a>Common模块</h2><p>公用模块中比较核心的就是自定义的msg消息</p><ul><li>ControlCommand.msg：控制无人机指令的msg格式，掌握API首先掌握msg定义</li><li>DetectionInfo.msg：目标检测模块的输出结果</li><li>DroneState.msg：无人机当下各个状态信息（与板载计算机是否通信连接，解锁或者上锁，当前飞行模式，当前的状态量位置速度加速度及姿态）</li><li>LogMessageControl.msg：控制端的日志打印信息记录</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> PX4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prometheus_msgs</title>
      <link href="2021/03/26/PX4-Prometheus-msg/"/>
      <url>2021/03/26/PX4-Prometheus-msg/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="prometheus-msgs-DroneState"><a href="#prometheus-msgs-DroneState" class="headerlink" title="prometheus_msgs/DroneState"></a>prometheus_msgs/DroneState</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ rosmsg show prometheus_msgs&#x2F;DroneState std_msgs&#x2F;Header header  uint32 seq  time stamp  string frame_idstring mode     &#x2F;&#x2F; 模式选择，来自&quot;&#x2F;mavros&#x2F;state&quot;话题，类型是mavros_msgs::Statebool connected  &#x2F;&#x2F; 是否连接，来自&quot;&#x2F;mavros&#x2F;state&quot;话题，类型是mavros_msgs::Statebool armed      &#x2F;&#x2F; 是否解锁，来自&quot;&#x2F;mavros&#x2F;state&quot;话题，类型是mavros_msgs::Statebool landed     &#x2F;&#x2F; 是否降落，来自&quot;&#x2F;mavros&#x2F;extended_state&quot;，类型是mavros_msgs::ExtendedStatefloat32 time_from_startfloat32[3] position &#x2F;&#x2F; 位置，来自&quot;&#x2F;mavros&#x2F;local_position&#x2F;pose&quot;，类型是geometry_msgs::PoseStampedfloat32 rel_altfloat32[3] velocity &#x2F;&#x2F; 速度，来自&quot;&#x2F;mavros&#x2F;local_position&#x2F;velocity_local&quot;，类型是geometry_msgs::TwistStampedfloat32[3] attitude &#x2F;&#x2F; 姿态欧拉角，来自&quot;&#x2F;mavros&#x2F;Imu&#x2F;data&quot;，由四元数转换而来geometry_msgs&#x2F;Quaternion attitude_q &#x2F;&#x2F;姿态四元数，来自&quot;&#x2F;mavros&#x2F;Imu&#x2F;data&quot;，类型是sensor_msgs::Imu里面的orientation  float64 x  float64 y  float64 z  float64 wfloat32[3] attitude_rate    &#x2F;&#x2F; 角速度，来自&quot;&#x2F;mavros&#x2F;Imu&#x2F;data&quot;，类型是sensor_msgs::Imu里面的angular_velocity<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="prometheus-msgs-Message"><a href="#prometheus-msgs-Message" class="headerlink" title="prometheus_msgs/Message"></a>prometheus_msgs/Message</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ rosmsg show prometheus_msgs&#x2F;Message std_msgs&#x2F;Header header  uint32 seq  time stamp  string frame_iduint8 message_type          &#x2F;&#x2F; 节点回传地面站的消息uint8 NORMAL&#x3D;0              &#x2F;&#x2F; enum message_typeuint8 WARN&#x3D;1uint8 ERROR&#x3D;2string source_nodestring content$ rosmsg show nav_msgs&#x2F;Odometry std_msgs&#x2F;Header header  uint32 seq  time stamp  string frame_idstring child_frame_idgeometry_msgs&#x2F;PoseWithCovariance pose  geometry_msgs&#x2F;Pose pose    geometry_msgs&#x2F;Point position      float64 x      float64 y      float64 z    geometry_msgs&#x2F;Quaternion orientation      float64 x      float64 y      float64 z      float64 w  float64[36] covariancegeometry_msgs&#x2F;TwistWithCovariance twist  geometry_msgs&#x2F;Twist twist    geometry_msgs&#x2F;Vector3 linear      float64 x      float64 y      float64 z    geometry_msgs&#x2F;Vector3 angular      float64 x      float64 y      float64 z  float64[36] covariance<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="prometheus-msgs-ControlCommand"><a href="#prometheus-msgs-ControlCommand" class="headerlink" title="prometheus_msgs/ControlCommand"></a>prometheus_msgs/ControlCommand</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ rosmsg show prometheus_msgs&#x2F;ControlCommand uint8 Idle&#x3D;0uint8 Takeoff&#x3D;1uint8 Hold&#x3D;2uint8 Land&#x3D;3uint8 Move&#x3D;4uint8 Disarm&#x3D;5uint8 User_Mode1&#x3D;6uint8 User_Mode2&#x3D;7std_msgs&#x2F;Header header  uint32 seq  time stamp  string frame_iduint32 Command_IDstring sourceuint8 Modeprometheus_msgs&#x2F;PositionReference Reference_State  uint8 XYZ_POS&#x3D;0  uint8 XY_POS_Z_VEL&#x3D;1  uint8 XY_VEL_Z_POS&#x3D;2  uint8 XYZ_VEL&#x3D;3  uint8 XYZ_ACC&#x3D;4  uint8 TRAJECTORY&#x3D;5  uint8 ENU_FRAME&#x3D;0  uint8 BODY_FRAME&#x3D;1  uint8 MIX_FRAME&#x3D;2  std_msgs&#x2F;Header header    uint32 seq    time stamp    string frame_id  uint8 Move_mode  uint8 Move_frame  float32 time_from_start  float32[3] position_ref  float32[3] velocity_ref  float32[3] acceleration_ref  bool Yaw_Rate_Mode  float32 yaw_ref  float32 yaw_rate_ref<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="prometheus-msgs-PositionReference"><a href="#prometheus-msgs-PositionReference" class="headerlink" title="prometheus_msgs/PositionReference"></a>prometheus_msgs/PositionReference</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ rosmsg show prometheus_msgs&#x2F;PositionReferenceuint8 XYZ_POS&#x3D;0uint8 XY_POS_Z_VEL&#x3D;1uint8 XY_VEL_Z_POS&#x3D;2uint8 XYZ_VEL&#x3D;3uint8 XYZ_ACC&#x3D;4uint8 TRAJECTORY&#x3D;5uint8 ENU_FRAME&#x3D;0uint8 BODY_FRAME&#x3D;1uint8 MIX_FRAME&#x3D;2std_msgs&#x2F;Header header  uint32 seq  time stamp  string frame_iduint8 Move_modeuint8 Move_framefloat32 time_from_startfloat32[3] position_reffloat32[3] velocity_reffloat32[3] acceleration_refbool Yaw_Rate_Modefloat32 yaw_reffloat32 yaw_rate_ref<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> PX4 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS_1</title>
      <link href="2021/03/26/ROS-ROS-1/"/>
      <url>2021/03/26/ROS-ROS-1/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="容易出错的地方"><a href="#容易出错的地方" class="headerlink" title="容易出错的地方"></a>容易出错的地方</h2><h4 id="链接catkin的库"><a href="#链接catkin的库" class="headerlink" title="链接catkin的库"></a>链接<code>catkin</code>的库</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">target_link_libraries(main_node $&#123;catkin_LIBRARIES&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="使用自定义头文件，前面加包名"><a href="#使用自定义头文件，前面加包名" class="headerlink" title="使用自定义头文件，前面加包名"></a>使用自定义头文件，前面加包名</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;package_name&#x2F;xxx.h&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h4><pre class="line-numbers language-php" data-language="php"><code class="language-php"># 头文件位置include_libraries(include)# 添加库文件add_libraries(Student STATIC src&#x2F;Student.cpp)# 链接target_link_libraries(main_node Student)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="用到std-msgs的数据类型"><a href="#用到std-msgs的数据类型" class="headerlink" title="用到std_msgs的数据类型"></a>用到<code>std_msgs</code>的数据类型</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;std_msgs&#x2F;Float64.h&gt;Float64 的成员变量    float64 data#include &lt;std_msgs&#x2F;Float64MultiArray.h&gt;Float64MultiArray 有个数组成员变量    float64[] data&#x2F;&#x2F; 这种可变数组就相当于vector<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;talker&quot;);    &#x2F;&#x2F; 节点名    ros::NodeHandle n;                  &#x2F;&#x2F; 句柄    ros::Publisher pub &#x3D; n.advertise&lt;std_msgs::Float64&gt;(&quot;chatting&quot;, 10);    &#x2F;&#x2F; 往chatting话题上发消息，数据类型是std_msgs::Float64    std_msgs::Float64 input;    input.data &#x3D; 0.0;    ros::Rate loop_rate(1);             &#x2F;&#x2F; 1s发一次    while(ros::ok())    &#123;        input.data +&#x3D; 0.1;        pub.publish(input);        loop_rate.sleep();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void chatting_cb(const std_msgs::Float64::ConstPtr &amp;message)&#123;    ROS_INFO(&quot;I receive the number: %f&quot;, message-&gt;data);&#125;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;listener&quot;);    ros::NodeHandle n;    ros::Subscribe sub &#x3D; n.subscribe(&quot;chatting&quot;, 1, chatting_cb);    ros::spin();    &#x2F;&#x2F; 阻塞&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;talker&quot;);    ros::NodeHandle n;    ros::Publisher pub &#x3D; n.advertise&lt;std_msgs::Float64MultiArray&gt;(&quot;chatting&quot;, 10);    ros::Rate loop_rate(1);    double arr[3] &#x3D; &#123;14, 15, 16&#125;;    std::vector&lt;double&gt; vi(arr, arr+3);     # float64就是double    std_msgs::Float64MultiArray input_float;    input_float.data &#x3D; vi;    while(ros::ok())    &#123;        for (auto &amp; i : input_float.data)            std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;        std::cout &lt;&lt; std::endl;        pub.publish(input_float);        loop_rate.sleep();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS_2</title>
      <link href="2021/03/26/ROS-ROS-2/"/>
      <url>2021/03/26/ROS-ROS-2/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="Minimal-Simulator"><a href="#Minimal-Simulator" class="headerlink" title="Minimal Simulator"></a>Minimal Simulator</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;ros&#x2F;ros.h&gt; #include&lt;std_msgs&#x2F;Float64.h&gt; std_msgs::Float64 g_velocity;std_msgs::Float64 g_force;void myCallback(const std_msgs::Float64&amp; message_holder) &#123;    ROS_INFO(&quot;received force value is: %f&quot;, message_holder.data);    g_force.data &#x3D; message_holder.data; &#125;int main(int argc, char **argv) &#123;    ros::init(argc, argv, &quot;minimal_simulator&quot;);    ros::NodeHandle nh;     ros::Subscriber my_subscriber_object &#x3D; nh.subscribe(&quot;force_cmd&quot;, 1, myCallback);    ros::Publisher my_publisher_object &#x3D; nh.advertise&lt;std_msgs::Float64&gt;(&quot;velocity&quot;, 1);    &#x2F;&#x2F; 订阅力控制话题，通过积分发布速度话题    double mass &#x3D; 1.0;    double dt &#x3D; 0.01;   &#x2F;&#x2F;10ms 积分时间    double sample_rate &#x3D; 1.0 &#x2F; dt;     ros::Rate naptime(sample_rate);    g_velocity.data &#x3D; 0.0;      g_force.data &#x3D; 0.0;     while (ros::ok()) &#123;        g_velocity.data &#x3D; g_velocity.data + (g_force.data &#x2F; mass) * dt;         my_publisher_object.publish(g_velocity);         ROS_INFO(&quot;velocity &#x3D; %f&quot;, g_velocity.data);        ros::spinOnce();        naptime.sleep();     &#125;    return 0;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Minimal-Controller"><a href="#Minimal-Controller" class="headerlink" title="Minimal Controller"></a>Minimal Controller</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;std_msgs&#x2F;Float64.h&gt;std_msgs::Float64 g_vel;std_msgs::Float64 g_vel_cmd;std_msgs::Float64 g_force;void vel_cb(const std_msgs::Float64::ConstPtr &amp;velocity)&#123;    ROS_WARN(&quot;Receive velocity: %f m&#x2F;s&quot;, velocity-&gt;data);    g_vel.data &#x3D; velocity-&gt;data;&#125;void vel_cmd_cb(const std_msgs::Float64::ConstPtr &amp;vel_cmd)&#123;    ROS_WARN(&quot;Receive desired velocity: %f m&#x2F;s&quot;, vel_cmd-&gt;data);    g_vel_cmd.data &#x3D; vel_cmd-&gt;data;&#125;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;controller&quot;);    ros::NodeHandle nh;    &#x2F;&#x2F; 订阅当前速度和期望速度    ros::Subscriber vel_sub &#x3D; nh.subscribe(&quot;velocity&quot;, 1, vel_cb);    ros::Subscriber vel_cmd_sub &#x3D; nh.subscribe(&quot;vel_cmd&quot;, 1, vel_cmd_cb);    &#x2F;&#x2F; 输出期望控制力    ros::Publisher force_pub &#x3D; nh.advertise&lt;std_msgs::Float64&gt;(&quot;force_cmd&quot;, 10);    double Kv &#x3D; 1.0;    &#x2F;&#x2F; 比例控制器    double dt &#x3D; 0.01;     double sample_rate &#x3D; 1.0 &#x2F; dt;     ros::Rate naptime(sample_rate);    g_vel.data &#x3D; 0.0;     g_vel_cmd.data &#x3D; 0.0;     g_force.data &#x3D; 0.0;    double vel_err &#x3D; 0.0;    while(ros::ok())    &#123;        vel_err &#x3D; g_vel_cmd.data - g_vel.data;        g_force.data &#x3D; Kv * vel_err;        force_pub.publish(g_force);        ROS_INFO(&quot;force command &#x3D; %f N&quot;, g_force.data);        ros::spinOnce();        naptime.sleep();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="launch文件"><a href="#launch文件" class="headerlink" title="launch文件"></a><code>launch</code>文件</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;launch&gt;    &lt;node name&#x3D;&quot;simulator&quot; pkg&#x3D;&quot;ros_learning&quot; type&#x3D;&quot;simulator_node&quot;&#x2F;&gt;    &lt;node name&#x3D;&quot;controller&quot; pkg&#x3D;&quot;ros_learning&quot; type&#x3D;&quot;controller_node&quot;&#x2F;&gt;&lt;&#x2F;launch&gt;# name: 节点名# pkg: 包名# type: 可执行文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="rqt-plot-画曲线"><a href="#rqt-plot-画曲线" class="headerlink" title="rqt_plot 画曲线"></a><code>rqt_plot</code> 画曲线</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">rostopic pub -r 10 vel_cmd std_msgs&#x2F;Float64 0.5rqt_plot velocity&#x2F;data, vel_cmd&#x2F;data, force_cmd&#x2F;data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><center><img src="/2021/03/26/ROS-ROS-2/profiles.png#pic_center" width="100%" height="100%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">profiles</div></center>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS自定义srv</title>
      <link href="2021/03/26/ROS-ROS-4/"/>
      <url>2021/03/26/ROS-ROS-4/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="自定义srv消息"><a href="#自定义srv消息" class="headerlink" title="自定义srv消息"></a>自定义<code>srv</code>消息</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string name---int32 agebool sex<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改CMakeLists-txt"><a href="#修改CMakeLists-txt" class="headerlink" title="修改CMakeLists.txt"></a>修改<code>CMakeLists.txt</code></h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">add_service_files(  FILES  stu.srv)generate_messages(  DEPENDENCIES  std_msgs  std_srvs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;ros_learning&#x2F;stu.h&quot;using namespace std;&#x2F;&#x2F; 注意回调函数的参数写法bool stu_cb(ros_learning::stu::Request &amp;request, ros_learning::stu::Response &amp;response)&#123;    string input_name(request.name);    cout &lt;&lt; input_name &lt;&lt; endl;    response.age &#x3D; 20;    response.sex &#x3D; true;    return true;&#125;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;service&quot;);    ros::NodeHandle nh;    ros::ServiceServer service &#x3D; nh.advertiseService(&quot;look_up_stu&quot;, stu_cb);    ros::spin();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &quot;ros_learning&#x2F;stu.h&quot;using namespace std;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;client&quot;);    ros::NodeHandle n;    ros::ServiceClient client &#x3D; n.serviceClient&lt;ros_learning::stu&gt;(&quot;look_up_stu&quot;);    ros_learning::stu srv;    string inputName;    while(ros::ok())    &#123;        cin &gt;&gt; inputName;        srv.request.name &#x3D; inputName;        if (!inputName.compare(&quot;exit&quot;))            return 0;         if (client.call(srv))        &#123;            cout &lt;&lt; &quot;name: &quot; &lt;&lt; srv.request.name &lt;&lt; endl;            cout &lt;&lt; &quot;age: &quot; &lt;&lt; srv.response.age &lt;&lt; endl;            cout &lt;&lt; &quot;sex: &quot; &lt;&lt; srv.response.sex &lt;&lt; endl;        &#125;                &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS自定义msg</title>
      <link href="2021/03/26/ROS-ROS-3/"/>
      <url>2021/03/26/ROS-ROS-3/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="自定义msg消息"><a href="#自定义msg消息" class="headerlink" title="自定义msg消息"></a>自定义<code>msg</code>消息</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Header headerint32 numfloat64[] data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="修改CMakeLists-txt"><a href="#修改CMakeLists-txt" class="headerlink" title="修改CMakeLists.txt"></a>修改<code>CMakeLists.txt</code></h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">find_package(catkin REQUIRED COMPONENTS  OpenCV  roscpp  rospy  std_msgs  message_generation)add_message_files(  FILES  test.msg)generate_messages(  DEPENDENCIES  std_msgs)catkin_package( CATKIN_DEPENDS roscpp rospy std_msgs message_runtime)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改package-xml"><a href="#修改package-xml" class="headerlink" title="修改package.xml"></a>修改<code>package.xml</code></h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;build_depend&gt;message_generation&lt;&#x2F;build_depend&gt;&lt;exec_depend&gt;message_runtime&lt;&#x2F;exec_depend&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;iostream&gt;#include &quot;ros_learning&#x2F;test.h&quot;using namespace std;using namespace Eigen;using namespace cv;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;talker&quot;);    ros::NodeHandle n;    ros::Publisher pub &#x3D; n.advertise&lt;ros_learning::test&gt;(&quot;chatting&quot;, 10);    ros::Rate loop_rate(10);    double arr[3] &#x3D; &#123;14, 15, 16&#125;;    std::vector&lt;double&gt; vi(arr, arr+3);    ros_learning::test input_msg;    input_msg.header.stamp &#x3D; ros::Time::now();    input_msg.header.seq &#x3D; 0;    input_msg.header.frame_id &#x3D; &quot;base_frame&quot;;    input_msg.num &#x3D; 0;    input_msg.data &#x3D; vi;    while(ros::ok())    &#123;        input_msg.header.seq++;        input_msg.header.stamp &#x3D; ros::Time::now();        for (auto &amp; i : input_msg.data)            std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;        std::cout &lt;&lt; std::endl;        pub.publish(input_msg);        loop_rate.sleep();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="是否使用仿真时间"><a href="#是否使用仿真时间" class="headerlink" title="是否使用仿真时间"></a>是否使用仿真时间</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">$ rosparam get use_sim_timetrue$ rosparam set use_sim_time false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS自定义类</title>
      <link href="2021/03/26/ROS-ROS-5/"/>
      <url>2021/03/26/ROS-ROS-5/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#ifndef EXAMPLE_H_#define EXAMPLE_H_#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;ros&#x2F;ros.h&gt; #include &lt;std_msgs&#x2F;Bool.h&gt;#include &lt;std_msgs&#x2F;Float32.h&gt;#include &lt;std_srvs&#x2F;Trigger.h&gt; &#x2F;&#x2F; rossrv show std_msgs&#x2F;Trigger&#x2F;&#x2F; bool success&#x2F;&#x2F; string messageclass Example&#123;public:    Example(ros::NodeHandle* nodehandle);   &#x2F;&#x2F; 构造函数，传句柄地址private:    ros::NodeHandle nh_;     ros::Subscriber minimal_subscriber_;    ros::ServiceServer minimal_service_;    ros::Publisher  minimal_publisher_;        double val_from_subscriber_;     double val_to_remember_;         void initializeSubscribers();   &#x2F;&#x2F; 初始化订阅者成员函数    void initializePublishers();    &#x2F;&#x2F; 初始化发布者成员函数    void initializeServices();      &#x2F;&#x2F; 初始化服务端成员函数        &#x2F;&#x2F; 回调函数    void subscriberCallback(const std_msgs::Float32 &amp;msg);     bool serviceCallback(std_srvs::Trigger::Request &amp;request, std_srvs::Trigger::Response &amp;response);&#125;;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;Example.h&quot;Example::Example(ros::NodeHandle* nodehandle) : nh_(*nodehandle)&#123;    ROS_INFO(&quot;in class constructor of Example&quot;);    initializeSubscribers();     initializePublishers();    initializeServices();&#125;void Example::initializeSubscribers()&#123;    ROS_INFO(&quot;Initializing Subscribers&quot;);    minimal_subscriber_ &#x3D; nh_.subscribe(&quot;input_topic&quot;, 1, &amp;Example::subscriberCallback, this);    &#x2F;&#x2F;函数指针和this指针&#125;void Example::initializePublishers()&#123;    ROS_INFO(&quot;Initializing Publishers&quot;);    minimal_publisher_ &#x3D; nh_.advertise&lt;std_msgs::Float32&gt;(&quot;output_topic&quot;, 1, true);&#125;void Example::initializeServices()&#123;    ROS_INFO(&quot;Initializing Services&quot;);    minimal_service_ &#x3D; nh_.advertiseService(&quot;service&quot;, &amp;Example::serviceCallback, this);&#125;void Example::subscriberCallback(const std_msgs::Float32 &amp;msg)&#123;    val_from_subscriber_ &#x3D; msg.data;    ROS_INFO(&quot;Receive message: %f&quot;, msg.data);       val_to_remember_ +&#x3D; val_from_subscriber_;    std_msgs::Float32 output_msg;    output_msg.data &#x3D; val_to_remember_;    minimal_publisher_.publish(output_msg);&#125;bool Example::serviceCallback(std_srvs::Trigger::Request &amp;request, std_srvs::Trigger::Response &amp;response)&#123;    ROS_INFO(&quot;service callback&quot;);    response.success &#x3D; true;    response.message &#x3D; &quot;response message&quot;;&#125;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;Example&quot;);    ros::NodeHandle nh;    Example example(&amp;nh);   &#x2F;&#x2F; 构造函数的参数是句柄地址    ros::spin();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="生成库文件"><a href="#生成库文件" class="headerlink" title="生成库文件"></a>生成库文件</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">add_libraries(Example src&#x2F;Example.cpp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="可执行文件链接库"><a href="#可执行文件链接库" class="headerlink" title="可执行文件链接库"></a>可执行文件链接库</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">add_executable(test_node src&#x2F;test.cpp)target_link_libraries(test_node Example)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS action</title>
      <link href="2021/03/26/ROS-ROS-action/"/>
      <url>2021/03/26/ROS-ROS-action/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="自定义action文件"><a href="#自定义action文件" class="headerlink" title="自定义action文件"></a>自定义<code>action</code>文件</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">int32 input---int32 outputint32 goal_stamp---int32 feedback<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php">add_action_files(  FILES  demo.action)generate_messages(DEPENDENCIES  std_msgs  std_srvs  actionlib_msgs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="package-xml"><a href="#package-xml" class="headerlink" title="package.xml"></a>package.xml</h2><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_depend</span><span class="token punctuation">></span></span>actionlib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_depend</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build_export_depend</span><span class="token punctuation">></span></span>actionlib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build_export_depend</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exec_depend</span><span class="token punctuation">></span></span>actionlib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exec_depend</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;actionlib&#x2F;server&#x2F;simple_action_server.h&gt;#include &quot;ros_learning&#x2F;demoAction.h&quot;int g_count &#x3D; 0;bool g_count_failure &#x3D; false;class ExampleActionServer &#123;private:    ros::NodeHandle nh_;     actionlib::SimpleActionServer&lt;ros_learning::demoAction&gt; as_;    ros_learning::demoGoal goal_;     ros_learning::demoResult result_;     ros_learning::demoFeedback feedback_;    &#x2F;&#x2F; 每部分都有对应的类名public:    ExampleActionServer();    ~ExampleActionServer(void) &#123;&#125;    void executeCB(const actionlib::SimpleActionServer&lt;ros_learning::demoAction&gt;::GoalConstPtr&amp; goal);&#125;;ExampleActionServer::ExampleActionServer() : as_(nh_,                                                 &quot;example_action&quot;,                                                 boost::bind(&amp;ExampleActionServer::executeCB, this, _1),                                                false)&#123;    ROS_INFO(&quot;in constructor of exampleActionServer...&quot;);    as_.start(); &#x2F;&#x2F; 启动服务    &#x2F;&#x2F; 构造函数中的false是指在初始化时先不启动，调用start()函数之后再启动&#125;void ExampleActionServer::executeCB(const actionlib::SimpleActionServer&lt;ros_learning::demoAction&gt;::GoalConstPtr&amp; goal) &#123;    g_count++;    result_.output &#x3D; g_count;    result_.goal_stamp &#x3D; goal-&gt;input;        if (g_count !&#x3D; goal-&gt;input) &#123;        ROS_WARN(&quot;hey--mismatch!&quot;);        ROS_INFO(&quot;g_count &#x3D; %d; goal_stamp &#x3D; %d&quot;, g_count, result_.goal_stamp);        g_count_failure &#x3D; true;        ROS_WARN(&quot;informing client of aborted goal&quot;);        as_.setAborted();     &#125;    else &#123;        as_.setSucceeded(result_);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char** argv) &#123;    ros::init(argc, argv, &quot;action_server_node&quot;);    ROS_INFO(&quot;instantiating the demo action server: &quot;);    ExampleActionServer as_object;        ROS_INFO(&quot;going into spin&quot;);    while (!g_count_failure &amp;&amp; ros::ok()) &#123;        ros::spinOnce();    &#125;    return 0;&#125;#include &lt;ros&#x2F;ros.h&gt;#include &lt;actionlib&#x2F;client&#x2F;simple_action_client.h&gt;#include &quot;ros_learning&#x2F;demoAction.h&quot;void doneCb(const actionlib::SimpleClientGoalState&amp; state,            const ros_learning::demoResultConstPtr&amp; result) &#123;    ROS_WARN(&quot;doneCb: server responded with state [%s]&quot;, state.toString().c_str());    int diff &#x3D; result-&gt;output - result-&gt;goal_stamp;    ROS_WARN(&quot;got result output &#x3D; %d; goal_stamp &#x3D; %d; diff &#x3D; %d&quot;, result-&gt;output, result-&gt;goal_stamp, diff);&#125;int main(int argc, char** argv) &#123;    ros::init(argc, argv, &quot;action_client_node&quot;);    int g_count &#x3D; 0;    ros_learning::demoGoal goal;    actionlib::SimpleActionClient&lt;ros_learning::demoAction&gt; action_client(&quot;example_action&quot;, true);    ROS_INFO(&quot;waiting for server: &quot;);    bool server_exists &#x3D; action_client.waitForServer(ros::Duration(5.0));    &#x2F;&#x2F;bool server_exists &#x3D; action_client.waitForServer(); &#x2F;&#x2F;wait forever    if (!server_exists) &#123;        ROS_WARN(&quot;could not connect to server; halting&quot;);        return 0;    &#125;    ROS_INFO(&quot;connected to action server&quot;);    while (true)     &#123;        g_count++;        goal.input &#x3D; g_count;        action_client.sendGoal(goal, &amp;doneCb);        &#x2F;&#x2F; action_client.sendGoal(goal);         &#x2F;&#x2F; action_client.sendGoal(goal, &amp;doneCb, &amp;activeCb, &amp;feedbackCb);        bool finished_before_timeout &#x3D; action_client.waitForResult(ros::Duration(5.0));        &#x2F;&#x2F; action_client.waitForResult(); &#x2F;&#x2F; wait forever...        if (!finished_before_timeout) &#123;            ROS_WARN(&quot;giving up waiting on result for goal number %d&quot;, g_count);            return 0;        &#125; else &#123;            &#x2F;&#x2F;if here, then server returned a result to us        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS cv_bridge</title>
      <link href="2021/03/26/ROS-ROS-CV/"/>
      <url>2021/03/26/ROS-ROS-CV/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="发布图像"><a href="#发布图像" class="headerlink" title="发布图像"></a>发布图像</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">image_transport::ImageTransport it(nh);     &#x2F;&#x2F;用句柄初始化image_transportimage_transport::Publisher image_pub &#x3D; it.advertise(&quot;image_topic&quot;, 10);&#x2F;&#x2F;cv::Mat通过cv_bridge::CvImage转换为sensor_msgs::ImagePtrsensor_msgs::ImagePtr msg &#x3D; cv_bridge::CvImage(std_msgs::Header(), &quot;bgr8&quot;, image).toImageMsg();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"># include &lt;ros&#x2F;ros.h&gt;# include &lt;image_transport&#x2F;image_transport.h&gt;# include &lt;opencv2&#x2F;highgui&#x2F;highgui.hpp&gt;# include &lt;opencv2&#x2F;core&#x2F;core.hpp&gt;# include &lt;cv_bridge&#x2F;cv_bridge.h&gt;# include &lt;iostream&gt;using namespace std;using namespace cv;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;image_pub_node&quot;);    ros::NodeHandle nh;    image_transport::ImageTransport it(nh);    image_transport::Publisher image_pub &#x3D; it.advertise(&quot;image_topic&quot;, 10);    Mat image &#x3D; imread(&quot;&#x2F;home&#x2F;kavin&#x2F;Pictures&#x2F;test.png&quot;, IMREAD_COLOR);    if (image.empty())    &#123;        cout &lt;&lt; &quot;can&#39;t find picture&quot; &lt;&lt; endl;        return -1;    &#125;    sensor_msgs::ImagePtr msg &#x3D; cv_bridge::CvImage(std_msgs::Header(), &quot;bgr8&quot;, image).toImageMsg();    ros::Rate loop_rate(1);    while(nh.ok())    &#123;        image_pub.publish(msg);        ROS_INFO(&quot;publish an image&quot;);        loop_rate.sleep();    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="接收图像"><a href="#接收图像" class="headerlink" title="接收图像"></a>接收图像</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">image_transport::Subscriber image_sub &#x3D; it.subscribe(&quot;&#x2F;simple_camera&#x2F;image_raw&quot;, 1, image_topic_cb);&#x2F;&#x2F;sensor_msgs话题通过cv_bridge::toCvCopy转换为cv::Mat指针cv_bridge::CvImagePtr cv_ptr &#x3D; cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);Mat colorImg &#x3D; cv_ptr-&gt;image;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;sensor_msgs&#x2F;image_encodings.h&gt;#include &lt;image_transport&#x2F;image_transport.h&gt;#include &lt;opencv2&#x2F;opencv.hpp&gt;#include &lt;cv_bridge&#x2F;cv_bridge.h&gt;#include &lt;iostream&gt;using namespace std;using namespace cv;Mat colorImg;void image_topic_cb(const sensor_msgs::ImageConstPtr&amp; msg)&#123;    try    &#123;        ROS_INFO(&quot;Receive an image successfully&quot;);        cv_bridge::CvImagePtr cv_ptr &#x3D; cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);        colorImg &#x3D; cv_ptr-&gt;image;        imshow(&quot;image&quot;, colorImg);        Mat grayImg;        cvtColor(colorImg, grayImg, COLOR_BGR2GRAY);        imshow(&quot;gray&quot;, grayImg);        &#x2F;&#x2F; cv::imshow(&quot;image&quot;, cv_bridge::toCvShare(msg, &quot;bgr8&quot;)-&gt;image);        &#x2F;&#x2F; cv::waitKey(10);    &#125;    catch(cv_bridge::Exception&amp; e)    &#123;        std::cerr &lt;&lt; e.what() &lt;&lt; &#39;\n&#39;;    &#125;    &#125;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;image_sub&quot;);    ros::NodeHandle nh;    image_transport::ImageTransport it(nh);    namedWindow(&quot;image&quot;, CV_WINDOW_AUTOSIZE);    namedWindow(&quot;gray&quot;, CV_WINDOW_AUTOSIZE);    startWindowThread();    image_transport::Subscriber image_sub &#x3D; it.subscribe(&quot;&#x2F;simple_camera&#x2F;image_raw&quot;, 1, image_topic_cb);    ros::spin();    destroyWindow(&quot;image&quot;);    destroyWindow(&quot;gray&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS find_red_pixels</title>
      <link href="2021/03/26/ROS-ROS-find-red-pixels/"/>
      <url>2021/03/26/ROS-ROS-find-red-pixels/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="ImageConverter类声明"><a href="#ImageConverter类声明" class="headerlink" title="ImageConverter类声明"></a><code>ImageConverter</code>类声明</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;#include &lt;image_transport&#x2F;image_transport.h&gt;#include &lt;cv_bridge&#x2F;cv_bridge.h&gt;#include &lt;sensor_msgs&#x2F;image_encodings.h&gt;#include &lt;opencv2&#x2F;imgproc&#x2F;imgproc.hpp&gt;#include &lt;opencv2&#x2F;highgui&#x2F;highgui.hpp&gt;static const std::string OPENCV_WINDOW &#x3D; &quot;OpenCV display window&quot;;using namespace std;using namespace cv;int g_redratio; &#x2F;&#x2F; 红色阈值class ImageConverter &#123;    ros::NodeHandle nh_;    image_transport::ImageTransport it_;    image_transport::Subscriber image_sub_;    image_transport::Publisher image_pub_;public:    ImageConverter(ros::NodeHandle &amp;nodehandle)    : it_(nh_) &#123;        image_sub_ &#x3D; it_.subscribe(&quot;simple_camera&#x2F;image_raw&quot;, 1,                &amp;ImageConverter::imageCb, this);        image_pub_ &#x3D; it_.advertise(&quot;&#x2F;image_converter&#x2F;output_video&quot;, 1);        namedWindow(OPENCV_WINDOW);    &#125;    ~ImageConverter() &#123;        destroyWindow(OPENCV_WINDOW);    &#125;    void imageCb(const sensor_msgs::ImageConstPtr&amp; msg);     &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="imageCb回调函数定义"><a href="#imageCb回调函数定义" class="headerlink" title="imageCb回调函数定义"></a><code>imageCb</code>回调函数定义</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void ImageConverter::imageCb(const sensor_msgs::ImageConstPtr&amp; msg)&#123;    cv_bridge::CvImagePtr cv_ptr; &#x2F;&#x2F;OpenCV data type    try &#123;        cv_ptr &#x3D; cv_bridge::toCvCopy(msg, sensor_msgs::image_encodings::BGR8);    &#125; catch (cv_bridge::Exception&amp; e) &#123;        ROS_ERROR(&quot;cv_bridge exception: %s&quot;, e.what());        return;    &#125;    int npix &#x3D; 0;   &#x2F;&#x2F; 红色区域总的像素    int isum &#x3D; 0;   &#x2F;&#x2F; 红色的列数    int jsum &#x3D; 0;   &#x2F;&#x2F; 红色的行数    int redval, blueval, greenval, testval;    Vec3b rgbpix;    for (int i &#x3D; 0; i &lt; cv_ptr-&gt;image.cols; i++) &#123;        for (int j &#x3D; 0; j &lt; cv_ptr-&gt;image.rows; j++) &#123;            &#x2F;&#x2F; 提取某点像素值            rgbpix &#x3D; cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i);            redval &#x3D; rgbpix[2] + 1; &#x2F;&#x2F; +1 防止除以0            blueval &#x3D; rgbpix[0] + 1;            greenval &#x3D; rgbpix[1] + 1;            testval &#x3D; redval &#x2F; (blueval + greenval);            &#x2F;&#x2F; 如果这个点判定为红色，设为白色            if (testval &gt; g_redratio) &#123;                cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i)[0] &#x3D; 255;                cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i)[1] &#x3D; 255;                cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i)[2] &#x3D; 255;                npix++;     &#x2F;&#x2F; 红色区域总的像素                isum +&#x3D; i;  &#x2F;&#x2F; 红色的列数                jsum +&#x3D; j;  &#x2F;&#x2F; 红色的行数            &#125; else &#123; &#x2F;&#x2F; 其他点设为黑色                cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i)[0] &#x3D; 0;                cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i)[1] &#x3D; 0;                cv_ptr-&gt;image.at&lt;Vec3b&gt;(j, i)[2] &#x3D; 0;            &#125;        &#125;    &#125;    ROS_WARN(&quot;npix: %d&quot;, npix);    int half_box &#x3D; 5; &#x2F;&#x2F; 矩形大小    int i_centroid, j_centroid;    double x_centroid, y_centroid;    if (npix &gt; 0) &#123;        i_centroid &#x3D; isum &#x2F; npix;   &#x2F;&#x2F; 中间点位置        j_centroid &#x3D; jsum &#x2F; npix;        x_centroid &#x3D; ((double) isum)&#x2F;((double) npix);        y_centroid &#x3D; ((double) jsum)&#x2F;((double) npix);        ROS_INFO(&quot;u_avg: %f; v_avg: %f&quot;,x_centroid,y_centroid);        ROS_WARN(&quot;center (col, row) : (%d, %d)&quot;, i_centroid, j_centroid);        for (int i_box &#x3D; i_centroid - half_box; i_box &lt;&#x3D; i_centroid + half_box; i_box++) &#123;            for (int j_box &#x3D; j_centroid - half_box; j_box &lt;&#x3D; j_centroid + half_box; j_box++) &#123;                if ((i_box &gt;&#x3D; 0)&amp;&amp;(j_box &gt;&#x3D; 0)&amp;&amp;(i_box &lt; cv_ptr-&gt;image.cols)&amp;&amp;(j_box &lt; cv_ptr-&gt;image.rows)) &#123;                    cv_ptr-&gt;image.at&lt;Vec3b&gt;(j_box, i_box)[0] &#x3D; 255; &#x2F;&#x2F;(255,0,0) is pure blue                    cv_ptr-&gt;image.at&lt;Vec3b&gt;(j_box, i_box)[1] &#x3D; 0;                    cv_ptr-&gt;image.at&lt;Vec3b&gt;(j_box, i_box)[2] &#x3D; 0;                &#125;            &#125;        &#125;    &#125;    imshow(OPENCV_WINDOW, cv_ptr-&gt;image);   &#x2F;&#x2F; 图像显示    waitKey(3);     image_pub_.publish(cv_ptr-&gt;toImageMsg());   &#x2F;&#x2F; 将处理后的图像发布出去&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char** argv) &#123;    ros::init(argc, argv, &quot;find_red_pixels_node&quot;);    ros::NodeHandle n;        ImageConverter ic(n);   &#x2F;&#x2F; 创建类实例    g_redratio&#x3D; 10;         &#x2F;&#x2F; 红色的阈值    ros::Duration timer(0.1);    while (ros::ok()) &#123;        ros::spinOnce();        timer.sleep();    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/03/26/ROS-ROS-find-red-pixels/image.png#pic_center" width="80%" height="80%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">原始图像</div></center><center><img src="/2021/03/26/ROS-ROS-find-red-pixels/image2.png#pic_center" width="80%" height="80%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">找到红色区域中心位置</div></center><h2 id="canny函数"><a href="#canny函数" class="headerlink" title="canny函数"></a><code>canny</code>函数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Mat gray_image, contours;cvtColor(cv_ptr-&gt;image, gray_image, COLOR_BGR2GRAY);Canny(gray_image, contours, 125, 350);imshow(OPENCV_WINDOW, contours);waitKey(3); sensor_msgs::ImagePtr msg_contours;try &#123;    msg_contours &#x3D; cv_bridge::CvImage(std_msgs::Header(), &quot;mono8&quot;, contours).toImageMsg();&#125; catch(cv_bridge::Exception&amp; e) &#123;    ROS_ERROR(&quot;cv_bridge exception: %s&quot;, e.what());    return;&#125;image_pub_.publish(msg_contours);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="编码参数"><a href="#编码参数" class="headerlink" title="编码参数"></a>编码参数</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php">mono8: CV_8UC1, grayscale imagemono16: CV_16UC1, 16-bit grayscale imagebgr8: CV_8UC3, color image with blue-green-red color orderrgb8: CV_8UC3, color image with red-green-blue color orderbgra8: CV_8UC4, BGR color image with an alpha channelrgba8: CV_8UC4, RGB color image with an alpha channel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><img src="/2021/03/26/ROS-ROS-find-red-pixels/contours.png#pic_center" width="80%" height="80%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">红色边缘</div></center>]]></content>
      
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS_MAVROS</title>
      <link href="2021/03/26/ROS-ROS-mavros/"/>
      <url>2021/03/26/ROS-ROS-mavros/</url>
      
        <content type="html"><![CDATA[<!-- toc --><center><img src="/2021/03/26/ROS-ROS-mavros/mavros.png#pic_center" width="50%" height="50%" alt="test"><br><div style="color:orange; border-bottom: 1px solid #d9d9d9;display: inline-block;color: #999;padding: 2px;">通信流程图</div></center><h2 id="常用MAVROS消息"><a href="#常用MAVROS消息" class="headerlink" title="常用MAVROS消息"></a>常用<code>MAVROS</code>消息</h2><h3 id="global-position-订阅-GPS-数据"><a href="#global-position-订阅-GPS-数据" class="headerlink" title="global_position 订阅 GPS 数据"></a><code>global_position</code> 订阅 GPS 数据</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php">消息名称: mavros&#x2F;global_position&#x2F;global类型名称: sensor_msgs::NavSatFix常用类成员变量: float64 latitude    &#x2F;&#x2F;经float64 longitude   &#x2F;&#x2F;纬float64 altitude    &#x2F;&#x2F;海拔float64[9] position_covarianceuint8 position_covariance_type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="imu-pub-订阅-IMU-原始数据"><a href="#imu-pub-订阅-IMU-原始数据" class="headerlink" title="imu_pub 订阅 IMU 原始数据"></a><code>imu_pub</code> 订阅 IMU 原始数据</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php">消息名称: mavros&#x2F;imu&#x2F;data(不是mavros&#x2F;imu&#x2F;data_raw, mavros&#x2F;imu&#x2F;data 为经过滤波后的数据)类型名称: sensor_msgs::Imu常用类成员变量:geometry_msgs::Quaternion orientation       &#x2F;&#x2F;旋转四元数(xyzw)float64[9] orientation_covariance           &#x2F;&#x2F;方差geometry_msgs::Vector3 angular_velocity     &#x2F;&#x2F;3 轴角速度(xyz)float64[9] angular_velocity_covariance      &#x2F;&#x2F;方差geometry_msgs::Vector3 linear_acceleration  &#x2F;&#x2F;线性加速度(xyz)float64[9] linear_acceleration_covariance   &#x2F;&#x2F;方差<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="local-position-订阅本地位置数据"><a href="#local-position-订阅本地位置数据" class="headerlink" title="local_position 订阅本地位置数据"></a><code>local_position</code> 订阅本地位置数据</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php">消息名称: mavros&#x2F;local_position&#x2F;pose类型名称: geometry_msgs::PoseStamped<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="manual-control-订阅遥控器的值"><a href="#manual-control-订阅遥控器的值" class="headerlink" title="manual_control 订阅遥控器的值"></a><code>manual_control</code> 订阅遥控器的值</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php">消息名称: mavros&#x2F;manual_control&#x2F;control类型名称: mavros_msgs::ManualControl常用类成员变量:float32 xfloat32 yfloat32 zfloat32 ruint16 buttons<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sys-status-查询系统状态"><a href="#sys-status-查询系统状态" class="headerlink" title="sys_status 查询系统状态"></a><code>sys_status</code> 查询系统状态</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php">消息名称: mavros&#x2F;state类型名称: mavros_msgs::State常用类成员变量:bool connected  &#x2F;&#x2F;是否连接bool armed      &#x2F;&#x2F;是否解锁bool guided     &#x2F;&#x2F;是否被引导（offboard 模式）string mode     &#x2F;&#x2F;模式类型uint8 system_status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="waypoint-查询航点"><a href="#waypoint-查询航点" class="headerlink" title="waypoint 查询航点"></a><code>waypoint</code> 查询航点</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php">消息名称: mavros&#x2F;mission&#x2F;waypoints类型名称: mavros_msgs::WaypointList常用类成员变量:uint16 current_seq  &#x2F;&#x2F;当前航点索引mavros_msgs::Waypoint[] waypoints    uint8 frame     &#x2F;&#x2F;坐标类型    uint16 command  &#x2F;&#x2F;命令 id，16 为航点    bool is_current    bool autocontinue    float32 param1    float32 param2    float32 param3    float32 param4    float64 x_lat   &#x2F;&#x2F;经度或者 x 坐标    float64 y_long  &#x2F;&#x2F;维度或者 y 坐标    float64 z_alt   &#x2F;&#x2F;海拔或者 z 坐标<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p><code>px4</code>使用的坐标系为<code>NED</code>（北东地）坐标系或者<code>FRD</code>（前右下）坐标系。<br><code>mavros</code>中常使用的是<code>ENU</code>（东北天）坐标系或者<code>body</code>系，<code>mavros</code>会自动将输入的<code>ENU</code>坐标值或者<code>body</code>系坐标值转换到<code>NED</code>坐标系中，再通过<code>mavlink</code>发送给飞控。</p><p>mavros的话题中常见的坐标系有<code>global</code>系、<code>local</code>系、<code>body</code>系</p><ul><li><p><code>global</code>系是gps坐标系，经纬度。</p></li><li><p><code>local</code>系指当地坐标系，一般是<code>ENU</code>坐标系，坐标原点一般在起飞点。如果有offset的话坐标原点在飞机上，这时其实是导航坐标系。</p></li><li><p><code>body</code>系在melodic版本中，改成了FLU（前左上）坐标系。</p></li></ul><h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><ul><li><code>coordinate_frame=1</code>虽然代表向px4发送<code>NED</code>坐标值，但是发送到这个话题的坐标系应该用<code>ENU</code>，<code>mavros</code>会自动完成这个坐标系的转换</li><li><code>ROS</code>程序发布的给定姿态<code>topic</code>为<code>/mavros/setpoint_raw/attitude</code>，而非<code>/mavros/setpoint_attitude/attitude</code></li><li><code>ROS</code>发布的速度指令<code>topic</code>为<code>/mavros/setpoint_velocity/cmd_vel_unstamped</code></li></ul><pre class="line-numbers language-php" data-language="php"><code class="language-php">topic: &quot;mavros&#x2F;setpoint_raw&#x2F;local&quot;rosmsg show marvros_msg&#x2F;PositionTarget    uint8 coordinate_frame    uint8 FRAME_LOCAL_NED &#x3D; 1    uint8 FRAME_LOCAL_OFFSET_NED &#x3D; 7    uint8 FRAME_BODY_NED &#x3D; 8    uint8 FRAME_BODY_OFFSET_NED &#x3D; 9    uint16 type_mask    uint16 IGNORE_PX &#x3D; 1    # Position ignore flags    uint16 IGNORE_PY &#x3D; 2    uint16 IGNORE_PZ &#x3D; 4    uint16 IGNORE_VX &#x3D; 8    # Velocity vector ignore flags    uint16 IGNORE_VY &#x3D; 16    uint16 IGNORE_VZ &#x3D; 32    uint16 IGNORE_AFX &#x3D; 64  # Acceleration&#x2F;Force vector ignore flags    uint16 IGNORE_AFY &#x3D; 128    uint16 IGNORE_AFZ &#x3D; 256    uint16 FORCE &#x3D; 512      # Force in af vector flag    uint16 IGNORE_YAW &#x3D; 1024    uint16 IGNORE_YAW_RATE &#x3D; 2048    geometry_msgs&#x2F;Point position    geometry_msgs&#x2F;Vector3 velocity    geometry_msgs&#x2F;Vector3 acceleration_or_force    float32 yaw    float32 yaw_rate<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> mavros </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS参数服务器</title>
      <link href="2021/03/26/ROS-ROS-param/"/>
      <url>2021/03/26/ROS-ROS-param/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="YAML文件"><a href="#YAML文件" class="headerlink" title="YAML文件"></a>YAML文件</h2><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">joint1_gains: &#123;p: 7.0, i: 8.0, d: 9.0&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;ros&#x2F;ros.h&gt;int main(int argc, char** argv)&#123;    ros::init(argc, argv, &quot;read_param_node&quot;);    ros::NodeHandle n;    double P_gain, D_gain, I_gain;    ROS_WARN(&quot;rosparam start&quot;);    if (n.getParam(&quot;&#x2F;gains&#x2F;p&quot;, P_gain)) &#123;        ROS_WARN(&quot;proportional gain set to %f&quot;, P_gain);    &#125;    else &#123;        ROS_WARN(&quot;Can&#39;t load param of P&quot;);    &#125;    ros::spin()    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="launch文件"><a href="#launch文件" class="headerlink" title="launch文件"></a><code>launch</code>文件</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>launch<span class="token operator">></span>    <span class="token operator">&lt;</span>rosparam command<span class="token operator">=</span><span class="token string">"load"</span> file<span class="token operator">=</span><span class="token string">"$(find ros_learning)/param/gains.yaml"</span><span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>node name<span class="token operator">=</span><span class="token string">"read_param_node"</span> pkg<span class="token operator">=</span><span class="token string">"ros_learning"</span> type<span class="token operator">=</span><span class="token string">"read_param_node"</span> output<span class="token operator">=</span><span class="token string">"screen"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>launch<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针</title>
      <link href="2021/03/25/C-C-%E6%8C%87%E9%92%88/"/>
      <url>2021/03/25/C-C-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="指针大小"><a href="#指针大小" class="headerlink" title="指针大小"></a>指针大小</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int main(int argc, char const *argv[])&#123;    cout &lt;&lt; sizeof(int) &lt;&lt; endl;    cout &lt;&lt; sizeof(char) &lt;&lt; endl;        cout &lt;&lt; sizeof(int*) &lt;&lt; endl;    cout &lt;&lt; sizeof(char*) &lt;&lt; endl;    return 0;&#125;4188<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见不管是什么类型的指针，大小都是<strong>8个字节</strong></p><h2 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h2><h3 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h3><ol><li><code>const</code>修饰的是<code>int</code>，说明<code>int</code>是常量不可修改，不能通过指针修改他的值，但可以指向别处</li><li>指针指向的对象可以不是<code>const</code>，但是还是不能用指针去修改他，可以用其他方法修改</li><li>必须用<code>const void*</code>才能指向<code>const</code>对象</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int* pInteger;    &#x2F;&#x2F; int const* pInteger;int num &#x3D; 10;           &#x2F;&#x2F; 不是constpInteger &#x3D; &amp;num;&#x2F;&#x2F; *pInteger &#x3D; 100;&#x2F;&#x2F; error, 不能用指针修改常量num &#x3D; 20;               &#x2F;&#x2F; yes，可以用其他方法修改int another &#x3D; 100;pInteger &#x3D; &amp;another;    &#x2F;&#x2F; yes，可以改变指针指向<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const char ch &#x3D; &#39;a&#39;;&#x2F;&#x2F; void* p &#x3D; &amp;ch;   &#x2F;&#x2F;errorconst void* p &#x3D; &amp;ch;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="常指针、const指针"><a href="#常指针、const指针" class="headerlink" title="常指针、const指针"></a>常指针、const指针</h3><ol><li><code>const</code>修饰的是指针，说明指针是常数，所以他存储的地址不能变，也就是不能改变指向，可以通过指针改变指向对象的值</li><li>常指针必须进行初始化</li><li>常指针不能指向<code>const</code>变量</li></ol><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int num &#x3D; 10;&#x2F;&#x2F; const int num &#x3D; 10;  &#x2F;&#x2F; error，const int* -&gt; int*int* const pInt &#x3D; &amp;num; int another &#x3D; 100;&#x2F;&#x2F; pInt &#x3D; &amp;another;     &#x2F;&#x2F; error, 常指针不能修改指向*pInt &#x3D; 100;            &#x2F;&#x2F; yes，变量不是const，可以改变他的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指向常量的常指针"><a href="#指向常量的常指针" class="headerlink" title="指向常量的常指针"></a>指向常量的常指针</h2><ul><li>只能指向<code>const</code>变量</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">const int num &#x3D; 10;const int* const ptr &#x3D; &amp;num;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>167_twoSum</title>
      <link href="2021/03/21/LeetCode-167-twoSum/"/>
      <url>2021/03/21/LeetCode-167-twoSum/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="LeetCode-167-两数之和-II-输入有序数组"><a href="#LeetCode-167-两数之和-II-输入有序数组" class="headerlink" title="LeetCode 167. 两数之和 II - 输入有序数组"></a>LeetCode 167. 两数之和 II - 输入有序数组</h2><p>给定一个已按照<strong>升序排列</strong>的整数数组<code>numbers</code>，请你从数组中找出两个数满足相加之和等于目标数<code>target</code>。</p><p>函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。<code>numbers</code> 的下标 从 1 开始计数 ，所以答案数组应当满足 <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length</code> 。</p><p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">输入：numbers &#x3D; [2,7,11,15], target &#x3D; 9输出：[1,2]解释：2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;用二分法优化右指针的位置vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;    int l &#x3D; 0, r &#x3D; numbers.size() - 1;    while (l &lt; r) &#123;        int  mid &#x3D; (l + r + 1) &gt;&gt; 1;        if (numbers[0] + numbers[mid] &lt;&#x3D; target) l &#x3D; mid;        else r &#x3D; mid - 1;    &#125;    int i &#x3D; 0, j &#x3D; r;    while (i &lt; j) &#123;        if (numbers[i] + numbers[j] &#x3D;&#x3D; target) return &#123;i + 1, j + 1&#125;;        else if (numbers[i] + numbers[j] &gt; target) --j;        else ++i;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">&#x2F;&#x2F;数组是有序的，可以用双指针法&#x2F;&#x2F;同时可以用二分法确定右指针的位置，进行优化&#x2F;&#x2F;Javaclass Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        int len &#x3D; nums.length;        int l &#x3D; 0;        int r &#x3D; len - 1;        while (l &lt; r) &#123;    &#x2F;&#x2F;模板二：小于等于某个数的最大值            int mid &#x3D; l + r + 1 &gt;&gt; 1;            if (nums[mid] &lt;&#x3D; target - nums[0]) l &#x3D; mid;            else r &#x3D; mid - 1;        &#125;        int left &#x3D; 0;        int right &#x3D; r;        while (left &lt; right) &#123;            int sum &#x3D; nums[left] + nums[right];            if (sum &#x3D;&#x3D; target)                 break;            else if (sum &lt; target)                left++;            else                right--;        &#125;        return new int[]&#123;left + 1, right + 1&#125;;    &#125;&#125;输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9输出: [1,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMakeForOpenCV</title>
      <link href="2021/03/21/OpenCV-CMakeForOpenCV/"/>
      <url>2021/03/21/OpenCV-CMakeForOpenCV/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="g-编译OpenCV"><a href="#g-编译OpenCV" class="headerlink" title="g++ 编译OpenCV"></a>g++ 编译OpenCV</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">g++ main.cpp -I D:&#x2F;software&#x2F;opencv&#x2F;opencv&#x2F;build&#x2F;x64&#x2F;mingw&#x2F;install&#x2F;include -L D:&#x2F;software&#x2F;opencv&#x2F;opencv&#x2F;build&#x2F;x64&#x2F;mingw&#x2F;install&#x2F;x64&#x2F;mingw&#x2F;lib -l libopencv_calib3d450 -l libopencv_core450 -l libopencv_dnn450 -l libopencv_features2d450 -l libopencv_flann450 -l libopencv_gapi450 -l libopencv_highgui450 -l libopencv_imgcodecs450 -l libopencv_imgproc450 -l libopencv_ml450 -l libopencv_objdetect450 -l libopencv_photo450 -l libopencv_stitching450 -l libopencv_video450 -l libopencv_videoio450 -l libopencv_world450 -o main.exe <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Ubuntu可以用pkg-config"><a href="#Ubuntu可以用pkg-config" class="headerlink" title="Ubuntu可以用pkg_config"></a>Ubuntu可以用<code>pkg_config</code></h2><p><strong>查看OpenCV路径和库</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ pkg-config --cflags --libs opencv -I&#x2F;usr&#x2F;local&#x2F;include&#x2F;opencv -I&#x2F;usr&#x2F;local&#x2F;include -L&#x2F;usr&#x2F;local&#x2F;lib -lopencv_dnn -lopencv_ml -lopencv_objdetect -lopencv_shape -lopencv_stitching -lopencv_superres -lopencv_videostab -lopencv_calib3d -lopencv_features2d -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs -lopencv_video -lopencv_photo -lopencv_imgproc -lopencv_flann -lopencv_viz -lopencv_coreg++ main.cpp -o main &#96;pkg-config --cflags --libs opencv&#96;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="CMake编译OpenCV"><a href="#CMake编译OpenCV" class="headerlink" title="CMake编译OpenCV"></a>CMake编译OpenCV</h2><pre class="line-numbers language-cmake" data-language="cmake"><code class="language-cmake">find_package(OpenCV REQUIRED)message(&quot;$&#123;OpenCV_INCLUDE_DIRS&#125;&quot;)# &#x2F;usr&#x2F;local&#x2F;includemessage(&quot;$&#123;OpenCV_LIBRARY_DIRS&#125;&quot;)# &#x2F;usr&#x2F;local&#x2F;include&#x2F;opencvmessage(&quot;$&#123;OpenCV_LIBS&#125;&quot;)# opencv_calib3d;opencv_core;...set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125;&quot;)set(CMAKE_BUILD_TYPE Debug)# 头文件目录include_directories($&#123;OpenCV_INCLUDE_DIRS&#125;)# 库文件目录link_directories($&#123;OpenCV_LIBRARY_DIRS&#125;)add_executable(main main.cpp)#链接target_link_libraries(main $&#123;OpenCV_LIBS&#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_2</title>
      <link href="2021/03/21/Eigen-Eigen-2/"/>
      <url>2021/03/21/Eigen-Eigen-2/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix.transpose()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="共轭矩阵"><a href="#共轭矩阵" class="headerlink" title="共轭矩阵"></a>共轭矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix.conjugate()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="伴随矩阵-共轭转置"><a href="#伴随矩阵-共轭转置" class="headerlink" title="伴随矩阵(共轭转置)"></a>伴随矩阵(共轭转置)</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix.adjoint()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix.inverse()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix.block(i,j,p,q)&#x2F;&#x2F; 起始于(i,j),提取块大小为(p,q)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">matrix.determinant()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;Eigen&#x2F;Dense&gt;using namespace Eigen;using namespace std;int main() &#123;    MatrixXd p(3, 3);    p &lt;&lt; 1, 2, 3,         4, 1, 6,         7, 8, 1;    cout &lt;&lt; p.transpose() &lt;&lt; endl;    &#x2F;&#x2F; 1 4 7    &#x2F;&#x2F; 2 1 8    &#x2F;&#x2F; 3 6 1    cout &lt;&lt; p.inverse() &lt;&lt; endl;    &#x2F;&#x2F; -0.451923   0.211538  0.0865385    &#x2F;&#x2F; 0.365385  -0.192308  0.0576923    &#x2F;&#x2F; 0.240385  0.0576923 -0.0673077    cout &lt;&lt; p.conjugate() &lt;&lt; endl;    &#x2F;&#x2F; 1 2 3    共轭矩阵，实数的共轭就是本身    &#x2F;&#x2F; 4 1 6    &#x2F;&#x2F; 7 8 1    cout &lt;&lt; p.adjoint() &lt;&lt; endl;    &#x2F;&#x2F; 1 4 7    伴随矩阵，转置+共轭    &#x2F;&#x2F; 2 1 8    &#x2F;&#x2F; 3 6 1    cout &lt;&lt; p.block(1,0,2,1) &lt;&lt; endl;    cout &lt;&lt; p.block&lt;2,1&gt;(1,0) &lt;&lt; endl;    &#x2F;&#x2F; 4    &#x2F;&#x2F; 7    cout &lt;&lt; p.determinant() &lt;&lt; endl;    &#x2F;&#x2F; 104    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_1</title>
      <link href="2021/03/21/Eigen-Eigen-1/"/>
      <url>2021/03/21/Eigen-Eigen-1/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>(1) 矩阵类型</p><p><mark><strong>MatrixSizeType</strong></mark> where Size can be 2,3,4 for fixed size square matrices or X for dynamic size, and where Type can be i for integer, f for float, d for double, cf for complex float, cd for complex double.</p><p><code>Matrix3d</code>: <em>double</em> 3X3 方阵<br><code>MatrixXf</code>: <em>float</em> 动态大小</p><p>(2) 向量类型<br><mark><strong>VectorSizeType</strong></mark>: 列向量<br><mark><strong>RowVectorSizeType</strong></mark>: 行向量<br><code>Vector4f</code>: <em>float</em> 4行的列向量</p><h2 id="零矩阵"><a href="#零矩阵" class="headerlink" title="零矩阵"></a>零矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">MatrixXd::Zero(rows,cols)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="随机矩阵"><a href="#随机矩阵" class="headerlink" title="随机矩阵"></a>随机矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">MatrixXd::Random(rows,cols)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="常数矩阵"><a href="#常数矩阵" class="headerlink" title="常数矩阵"></a>常数矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">MatrixXd::Constant(rows,cols,constant)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">MatrixXd::Identity(rows,cols)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;Eigen&#x2F;Dense&gt;using namespace Eigen;using namespace std;int main() &#123;    Eigen::MatrixXd q &#x3D; Eigen::MatrixXd::Zero(2,2);    cout &lt;&lt; q &lt;&lt; endl;    # 0 0    # 0 0        q.resize(4,4);    &#x2F;&#x2F; 仅限于0矩阵，其他会出大问题    cout &lt;&lt; q.rows() &lt;&lt; endl;    &#x2F;&#x2F; 4    cout &lt;&lt; q.cols() &lt;&lt; endl;    &#x2F;&#x2F; 4    cout &lt;&lt; q &lt;&lt; endl;    # 0 0 0 0    # 0 0 0 0    # 0 0 0 0    # 0 0 0 0    MatrixXd m2 &#x3D; MatrixXd::Random(3, 3);    cout &lt;&lt; m2 &lt;&lt; endl;    # 0.680375 0.59688 -0.329554    # -0.211234 0.823295 0.536459    # 0.566198 -0.604897 -0.444451    MatrixXd m3 &#x3D; MatrixXd::Constant(3, 3, 1.2);    cout &lt;&lt; m3 &lt;&lt; endl;    # 1.2 1.2 1.2    # 1.2 1.2 1.2    # 1.2 1.2 1.2        VectorXd v(2);    v &lt;&lt; 1, 2;    cout &lt;&lt; v &lt;&lt; endl;    # 1    # 2        cout &lt;&lt; m*v &lt;&lt; endl;    &#x2F;&#x2F; 矩阵和向量相乘    # 5    # 11    MatrixXd m4 &#x3D; MatrixXd::Identity(3, 4);    &#x2F;&#x2F; 1 0 0 0    &#x2F;&#x2F; 0 1 0 0    &#x2F;&#x2F; 0 0 1 0    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_Quaternion</title>
      <link href="2021/03/21/Eigen-Eigen-Quaternion/"/>
      <url>2021/03/21/Eigen-Eigen-Quaternion/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="旋转向量到旋转矩阵"><a href="#旋转向量到旋转矩阵" class="headerlink" title="旋转向量到旋转矩阵"></a>旋转向量到旋转矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">double alpha &#x3D; M_PI &#x2F; 3;AngleAxisd rotation_vector(alpha, Vector3d(1, 0, 0));&#x2F;&#x2F; x轴: 1 0 0&#x2F;&#x2F; y轴: 0 1 0&#x2F;&#x2F; z轴: 0 0 1MatrixXd rotation_matrix;rotation_matrix &#x3D; rotation_vector.matrix();&#x2F;&#x2F; rotation_matrix &#x3D; rotation_vector.toRotationMatrix();cout &lt;&lt; rotation_matrix &lt;&lt; endl;&#x2F;&#x2F; 1         0         0&#x2F;&#x2F; 0       0.5 -0.866025&#x2F;&#x2F; 0  0.866025       0.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="旋转向量到欧拉角"><a href="#旋转向量到欧拉角" class="headerlink" title="旋转向量到欧拉角"></a>旋转向量到欧拉角</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3d eulerAngle &#x3D; rotation_vector.matrix().eulerAngles(2, 1, 0);&#x2F;&#x2F; ZYX: 2, 1, 0cout &lt;&lt; eulerAngle &lt;&lt; endl;&#x2F;&#x2F;      0&#x2F;&#x2F;     -0&#x2F;&#x2F; 1.0472<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="旋转向量到四元数"><a href="#旋转向量到四元数" class="headerlink" title="旋转向量到四元数"></a>旋转向量到四元数</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Quaterniond quaternion(rotation_vector);cout &lt;&lt; quaternion.coeffs() &lt;&lt; endl;&#x2F;&#x2F;      0.5&#x2F;&#x2F;        0&#x2F;&#x2F;        0&#x2F;&#x2F; 0.866025cout &lt;&lt; quaternion.x() &lt;&lt; endl;cout &lt;&lt; quaternion.y() &lt;&lt; endl;cout &lt;&lt; quaternion.z() &lt;&lt; endl;cout &lt;&lt; quaternion.w() &lt;&lt; endl;&#x2F;&#x2F; 0.5&#x2F;&#x2F; 0&#x2F;&#x2F; 0&#x2F;&#x2F; 0.866025Quaterniond quaternion2;quaternion2 &#x3D; rotation_vector;  &#x2F;&#x2F; 重载了&#39;&#x3D;&#39;cout &lt;&lt; quaternion2.coeffs() &lt;&lt; endl;&#x2F;&#x2F;      0.5&#x2F;&#x2F;        0&#x2F;&#x2F;        0&#x2F;&#x2F; 0.866025&#x2F;&#x2F; 四元数的初始化Quaterniond quaternion(w, x, y, z);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_向量</title>
      <link href="2021/03/21/Eigen-Eigen-%E5%90%91%E9%87%8F/"/>
      <url>2021/03/21/Eigen-Eigen-%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">head(i)&#x2F;&#x2F; 头i个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="部分"><a href="#部分" class="headerlink" title="部分"></a>部分</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">segment(i, n)&#x2F;&#x2F; 取向量从i开始,长度为n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="尾部"><a href="#尾部" class="headerlink" title="尾部"></a>尾部</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">tail(i)&#x2F;&#x2F; 后i个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;Eigen&#x2F;Dense&gt;using namespace std;using namespace Eigen;int main(int argc, char const *argv[])&#123;    VectorXd x(6);    VectorXd a(2);    a &lt;&lt; 1,2;    cout &lt;&lt; a &lt;&lt; endl;    &#x2F;&#x2F; 1    &#x2F;&#x2F; 2    x.head(2) &#x3D; a;    cout &lt;&lt; x &lt;&lt; endl;    &#x2F;&#x2F; 1    &#x2F;&#x2F; 2    &#x2F;&#x2F; 0    &#x2F;&#x2F; 0    &#x2F;&#x2F; 0    &#x2F;&#x2F; 0    VectorXd b(2);    b &lt;&lt; 3,4;    x.segment(2,2) &#x3D; b;    cout &lt;&lt; x &lt;&lt; endl;    &#x2F;&#x2F; 1    &#x2F;&#x2F; 2    &#x2F;&#x2F; 3    &#x2F;&#x2F; 4    &#x2F;&#x2F; 0    &#x2F;&#x2F; 0        VectorXd c(2);    c &lt;&lt; 5,6;    x.tail(2) &#x3D; c;    cout &lt;&lt; x &lt;&lt; endl;    &#x2F;&#x2F; 1    &#x2F;&#x2F; 2    &#x2F;&#x2F; 3    &#x2F;&#x2F; 4    &#x2F;&#x2F; 5    &#x2F;&#x2F; 6    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_求秩</title>
      <link href="2021/03/21/Eigen-Eigen-%E6%B1%82%E7%A7%A9/"/>
      <url>2021/03/21/Eigen-Eigen-%E6%B1%82%E7%A7%A9/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="rank-基本用法"><a href="#rank-基本用法" class="headerlink" title="rank()基本用法"></a><code>rank()</code>基本用法</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">JacobiSVD&lt;MatrixXd&gt; svd(m);svd.rank()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &quot;Eigen&#x2F;Dense&quot;using namespace std;using namespace Eigen;int main()&#123;    MatrixXd a(3, 3);    a &lt;&lt; 1,  2, 0,         3, -1, 1,         0,  2, 0;    MatrixXd b(3, 1);    b &lt;&lt; 2,        1,        1;    MatrixXd m &#x3D; MatrixXd::Zero(3, 3);    m.col(0) &#x3D; b;    m.col(1) &#x3D; a * b;    m.col(2) &#x3D; a * a * b;    cout &lt;&lt; m &lt;&lt; endl;    JacobiSVD&lt;MatrixXd&gt; svd(m);    cout &lt;&lt; svd.rank() &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_矩阵属性</title>
      <link href="2021/03/21/Eigen-Eigen-%E7%9F%A9%E9%98%B5%E5%B1%9E%E6%80%A7/"/>
      <url>2021/03/21/Eigen-Eigen-%E7%9F%A9%E9%98%B5%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="元素累加累乘"><a href="#元素累加累乘" class="headerlink" title="元素累加累乘"></a>元素累加累乘</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mat.sum()mat.prod()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mat.mean()  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mat.minCoeff()mat.maxCoeff()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="迹"><a href="#迹" class="headerlink" title="迹"></a>迹</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mat.trace()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="对角元素"><a href="#对角元素" class="headerlink" title="对角元素"></a>对角元素</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">mat.diagonal()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">EigenSolver&lt;Matrix3d&gt; eigen_solver(mat);eigen_solver.pseudoEigenvalueMatrix()&#x2F;&#x2F; 特征值排成矩阵形式eigen_solver.pseudoEigenvectors()&#x2F;&#x2F; 每一列是一个特征向量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &quot;Eigen&#x2F;Dense&quot;using namespace std;using namespace Eigen;int main()&#123;    Matrix2d mat;    mat &lt;&lt; 1, 2,    3, 4;    cout &lt;&lt; &quot;Here is mat.sum():       &quot; &lt;&lt; mat.sum()       &lt;&lt; endl;    cout &lt;&lt; &quot;Here is mat.prod():      &quot; &lt;&lt; mat.prod()      &lt;&lt; endl;    cout &lt;&lt; &quot;Here is mat.mean():      &quot; &lt;&lt; mat.mean()      &lt;&lt; endl;    cout &lt;&lt; &quot;Here is mat.minCoeff():  &quot; &lt;&lt; mat.minCoeff()  &lt;&lt; endl;    cout &lt;&lt; &quot;Here is mat.maxCoeff():  &quot; &lt;&lt; mat.maxCoeff()  &lt;&lt; endl;    cout &lt;&lt; &quot;Here is mat.trace():     &quot; &lt;&lt; mat.trace()     &lt;&lt; endl;    &#x2F;&#x2F; Here is mat.sum():       10    &#x2F;&#x2F; Here is mat.prod():      24    &#x2F;&#x2F; Here is mat.mean():      2.5    &#x2F;&#x2F; Here is mat.minCoeff():  1    &#x2F;&#x2F; Here is mat.maxCoeff():  4    &#x2F;&#x2F; Here is mat.trace():     5    Matrix3d mat;mat &lt;&lt; 1, 2, 4,           3, 4, 5,           9, 8, 7;cout &lt;&lt; mat.diagonal() &lt;&lt; endl;    &#x2F;&#x2F; 1    &#x2F;&#x2F; 4    &#x2F;&#x2F; 7    cout &lt;&lt; mat.eigenvalues() &lt;&lt; endl;    &#x2F;&#x2F; (14.8426,0)    &#x2F;&#x2F; (-3.10313,0)    &#x2F;&#x2F; (0.260538,0)EigenSolver&lt;Matrix3d&gt; eigen_solver(mat);MatrixXd eig_value &#x3D; eigen_solver.pseudoEigenvalueMatrix();cout &lt;&lt; &quot;matrix values &#x3D; \n&quot; &lt;&lt; eig_value &lt;&lt; endl;    &#x2F;&#x2F; matrix values &#x3D;    &#x2F;&#x2F; 14.8426        0        0    &#x2F;&#x2F;     0   -3.10313        0    &#x2F;&#x2F;     0        0   0.260538MatrixXd eig_vector &#x3D; eigen_solver.pseudoEigenvectors();cout &lt;&lt; &quot;matrix vectors &#x3D; \n&quot; &lt;&lt; eig_vector &lt;&lt; endl;    &#x2F;&#x2F; matrix vectors &#x3D;    &#x2F;&#x2F; -0.307083 -0.629353  0.493782    &#x2F;&#x2F; -0.467283 -0.291072 -0.826916    &#x2F;&#x2F; -0.829064  0.791116  0.322174&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen_运算符</title>
      <link href="2021/03/21/Eigen-Eigen-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>2021/03/21/Eigen-Eigen-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h2 id="向量内积"><a href="#向量内积" class="headerlink" title="向量内积"></a>向量内积</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector2d m(1, 2);Vector2d n(4, 5);cout &lt;&lt; m.dot(n) &lt;&lt; endl;    &#x2F;&#x2F; 向量内积：14cout &lt;&lt; m.adjoint() * n &lt;&lt; endl;cout &lt;&lt; (m.adjoint() * n).value() &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="转置与伴随矩阵"><a href="#转置与伴随矩阵" class="headerlink" title="转置与伴随矩阵"></a>转置与伴随矩阵</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Matrix2d m, n;m &lt;&lt; 1, 2,     3, 4;n &#x3D; m.transpose();&#x2F;&#x2F; m.transposeInPlace();    &#x2F;&#x2F;m变成自己的转置矩阵n &#x3D; m.adjoint();    &#x2F;&#x2F;伴随矩阵，实数的伴随矩阵等于转置矩阵&#x2F;&#x2F; 1 3&#x2F;&#x2F; 2 4m.adjointInPlace();    &#x2F;&#x2F;m变成自己的伴随矩阵Matrix2cf m &#x3D; Matrix2cf::Random(); &#x2F;&#x2F;复数的伴随矩阵，除了转置，复数域要变号cout &lt;&lt; &quot;Here is the 2x2 complex matrix m:&quot; &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;cout &lt;&lt; &quot;Here is the adjoint of m:&quot; &lt;&lt; endl &lt;&lt; m.adjoint() &lt;&lt; endl;Here is the 2x2 complex matrix m:(0.127171,-0.997497) (-0.0402539,0.170019)(0.617481,-0.613392)  (0.791925,-0.299417)Here is the adjoint of m:(0.127171,0.997497)    (0.617481,0.613392)(-0.0402539,-0.170019)    (0.791925,0.299417)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="范数与单位化"><a href="#范数与单位化" class="headerlink" title="范数与单位化"></a>范数与单位化</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector2d vec1(3, 4);Vector2d vec2;double scalar &#x3D; vec1.norm();    &#x2F;&#x2F; 二阶范数 5    scalar &#x3D; vec1.squaredNorm();    &#x2F;&#x2F; 范数平方 25vec2 &#x3D; vec1.normalized();    &#x2F;&#x2F; 单位化 0.6; 0.8vec1.normalize();    &#x2F;&#x2F; inplace 自己变成自己的单位化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3d vec1(1, 2, 3);Vector3d vec2(3, 4, 5);cout &lt;&lt; &quot;cross: &quot; &lt;&lt; endl &lt;&lt; vec1.cross(vec2) &lt;&lt; endl; &#x2F;&#x2F; 叉积只适用于三维向量cross:     -2      4     -2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
